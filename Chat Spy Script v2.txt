print("-- Chat Spy Executed --")
print("Type \"/spy\" to toggle chat spy")
print("https://github.com/dehoisted/Chat-Spy")

-- Config
Config = {
    enabled = true,
    spyOnMyself = true,
    public = false,
    publicItalics = true
}

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local instance = (_G.chatSpyInstance or 0) + 1
_G.chatSpyInstance = instance

-- System message formatting
local function displaySystemMessage(text)
    TextChatService.TextChannels.RBXSystem:DisplaySystemMessage(
        string.format(
            '<font color="#00FFFF"><b>%s</b></font>',
            text
        )
    )
end

-- Core message processing
local function processPrivateMessage(speaker, rawMessage, channel)
    if not Config.enabled then return end
    if not speaker then return end
    if speaker == player and not Config.spyOnMyself then return end
    
    -- Clean message
    local cleanMsg = rawMessage:gsub("[\n\r]", ""):gsub("\t", " "):gsub(" +", " ")
    
    -- Determine if it's a team message
    local isTeamMessage = type(channel) == "string" and channel:find("Team$") ~= nil
    
    if Config.public then
        local prefix = Config.publicItalics and "/me " or ""
        local spyTag = isTeamMessage and "{TEAM SPY}" or "{SPY}"
        local formatted = prefix .. spyTag .. " [" .. speaker.Name .. "]: " .. cleanMsg
        TextChatService.TextChannels.RBXGeneral:SendAsync(formatted)
    else
        local spyTag = isTeamMessage and "{TEAM SPY}" or "{SPY}"
        displaySystemMessage(spyTag .. " [" .. speaker.Name .. "]: " .. cleanMsg)
    end
end

-- Proper implementation of OnIncomingMessage
local originalOnIncomingMessage
local function setupMessageHook()
    originalOnIncomingMessage = TextChatService.OnIncomingMessage
    
    TextChatService.OnIncomingMessage = function(messageObject)
        local result = originalOnIncomingMessage and originalOnIncomingMessage(messageObject)
        
        if _G.chatSpyInstance == instance then
            pcall(function()
                if messageObject.TextSource then
                    local speaker = Players:GetPlayerByUserId(messageObject.TextSource.UserId)
                    if speaker then
                        -- Identify private messages by channel
                        local channel = messageObject.TextChannel and messageObject.TextChannel.Name
                        if channel and channel ~= "RBXGeneral" and channel ~= "RBXSystem" then
                            processPrivateMessage(speaker, messageObject.Text, channel)
                        end
                    end
                end
            end)
        end
        
        return result
    end
end

-- Command handling
TextChatService.SendingMessage:Connect(function(params)
    if _G.chatSpyInstance ~= instance then return end
    
    local message = params.Text
    if string.sub(message:lower(), 1, 4) == "/spy" then
        Config.enabled = not Config.enabled
        task.wait(0.3)
        displaySystemMessage("{SPY " .. (Config.enabled and "EN" or "DIS") .. "ABLED}")
        params.Text = ""
        return
    end
end)

-- Handle all player messages (fallback)
local function handlePlayerMessage(speaker, message, channel)
    if _G.chatSpyInstance ~= instance then return end
    if not Config.enabled then return end
    if not speaker then return end
    if speaker == player and not Config.spyOnMyself then return end
    
    -- Only process commands/whispers/team chat
    if message:sub(1,3):lower() == "/w " or 
       message:sub(1,1) == "/" or 
       channel:find("Team$") then
        processPrivateMessage(speaker, message, channel)
    end
end

-- Setup player chat hooks
for _, otherPlayer in ipairs(Players:GetPlayers()) do
    if otherPlayer ~= player then
        otherPlayer.Chatted:Connect(function(message)
            handlePlayerMessage(otherPlayer, message, "All")
        end)
    end
end

Players.PlayerAdded:Connect(function(newPlayer)
    newPlayer.Chatted:Connect(function(message)
        handlePlayerMessage(newPlayer, message, "All")
    end)
end)

-- Handle own messages
player.Chatted:Connect(function(rawMessage)
    if not Config.enabled then return end
    if not Config.spyOnMyself then return end
    
    -- Only process commands/whispers
    if rawMessage:sub(1,3):lower() == "/w " or rawMessage:sub(1,1) == "/" then
        local channel = rawMessage:sub(1,3):lower() == "/w " and "RBXWhisper" or "Command"
        processPrivateMessage(player, rawMessage, channel)
    end
end)

-- Initialize the system
setupMessageHook()
displaySystemMessage("{SPY SYSTEM ACTIVE}")
displaySystemMessage("{SPY " .. (Config.enabled and "EN" or "DIS") .. "ABLED}")

-- Cleanup when script is replaced
local function cleanup()
    if originalOnIncomingMessage then
        TextChatService.OnIncomingMessage = originalOnIncomingMessage
    end
end

game:GetService("ScriptContext").DescendantRemoving:Connect(function(descendant)
    if descendant == script then
        cleanup()
    end
end)
