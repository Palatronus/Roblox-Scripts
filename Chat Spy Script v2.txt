--[[
	Infinite Yield-Style Chat Spy (2025)
	Type "/spy" to toggle
	Captures whispers, team chat & commands
	Uses channel-based detection instead of deprecated status enums
--]]

-- Wait for essential services to load
local success, err = pcall(function()
	-- Services
	local TextChatService = game:GetService("TextChatService")
	local Players = game:GetService("Players")
	local StarterGui = game:GetService("StarterGui")
	
	-- Wait for player to join
	local player = Players.LocalPlayer
	while not player do
		task.wait()
		player = Players.LocalPlayer
	end

	-- Config
	local Config = {
		enabled = true,          -- Default spy state
		spyOnMyself = true,      -- Capture own private messages
		public = false,          -- Broadcast spy logs publicly
		publicItalics = true,    -- Use italics for public messages
		filterCommands = true,   -- Hide commands like "/e dance"
	}

	-- System message appearance (IY-style cyan)
	local PrivateProperties = {
		Color = Color3.fromRGB(0, 255, 255),
		Font = Enum.Font.SourceSansBold,
		TextSize = 18
	}

	-- Anti-duplication tracking
	local instance = (_G.chatSpyInstance or 0) + 1
	_G.chatSpyInstance = instance

	-- Display initial status safely
	local function safeMessage(text)
		pcall(function()
			PrivateProperties.Text = text
			StarterGui:SetCore("ChatMakeSystemMessage", PrivateProperties)
		end)
	end

	-- ===== Fixed Message Handler ===== --
	TextChatService.OnIncomingMessage = function(message)
		-- Skip if disabled or wrong instance
		if _G.chatSpyInstance ~= instance or not Config.enabled then
			return true
		end
		
		-- Process only messages with text
		local text = message.Text or ""
		if text == "" then 
			return true 
		end
		
		-- INFINITE YIELD TECHNIQUE: Detect private messages by channel
		local isPrivate = false
		local channel = message.TextChannel
		if channel then
			-- Whisper: "RBXWhisper" channel | Team: "RBXTeam" channel
			isPrivate = channel.Name == "RBXWhisper" or channel.Name == "RBXTeam"
		end
		
		if not isPrivate then 
			return true 
		end
		
		-- Filter commands
		if Config.filterCommands and text:match("^%/%w+") then 
			return true 
		end

		-- Identify speaker
		local playerName = "System"
		local playerObj = nil
		if message.TextSource then
			playerObj = Players:GetPlayerByUserId(message.TextSource.UserId)
			if playerObj then
				playerName = playerObj.Name
				-- Skip own messages if disabled
				if playerObj == player and not Config.spyOnMyself then
					return true
				end
			end
		end

		-- Clean message text
		local cleanText = text:gsub("[\n\r]", ""):gsub("\t", " "):gsub("%s+", " ")
		
		-- ===== Output Handling ===== --
		task.defer(function()
			if Config.public then
				local prefix = Config.publicItalics and "/me " or ""
				local formatted = prefix .. "{SPY} [".. playerName .."]: " .. cleanText
				
				-- Safe public broadcasting
				pcall(function()
					local generalChannel = TextChatService:FindFirstChild("RBXGeneral")
					if generalChannel then
						generalChannel:SendAsync(formatted)
					end
				end)
			else
				-- Private logging
				safeMessage("{SPY} [".. playerName .."]: " .. cleanText)
			end
		end)
		
		return true
	end

	-- ===== Command Handling ===== --
	local function onChatted(msg)
		if _G.chatSpyInstance ~= instance then return end
		
		if msg:lower():sub(1, 4) == "/spy" then
			Config.enabled = not Config.enabled
			task.wait(0.3)
			safeMessage("{SPY "..(Config.enabled and "EN" or "DIS").."ABLED}")
		end
	end

	-- Initialize command handler
	player.Chatted:Connect(onChatted)

	-- Initial status message
	safeMessage("{SPY "..(Config.enabled and "EN" or "DIS").."ABLED}")
end)

-- Handle initialization errors
if not success then
	warn("Chat Spy initialization failed: " .. tostring(err))
end
