print("-- Chat Spy Executed --")
print("Type \"/spy\" to toggle chat spy")
print("https://github.com/dehoisted/Chat-Spy")

-- Config
Config = {
    enabled = true,
    spyOnMyself = true,
    public = false,
    publicItalics = true
}

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local instance = (_G.chatSpyInstance or 0) + 1
_G.chatSpyInstance = instance

-- System message formatting
local function displaySystemMessage(text)
    TextChatService.TextChannels.RBXSystem:DisplaySystemMessage(
        string.format(
            '<font color="#00FFFF"><b>%s</b></font>',
            text
        )
    )
end

-- Track visible public messages
local visibleMessages = {}
local messageTimers = {}

-- Core message processing with inverted visibility logic
local function processMessage(speaker, message, channel)
    if not Config.enabled then return end
    if speaker == player and not Config.spyOnMyself then return end
    
    -- Clean message for comparison
    local cleanMsg = message:gsub("[\n\r]", ""):gsub("\t", " "):gsub(" +", " ")
    local messageKey = speaker.UserId .. ":" .. cleanMsg
    
    -- Only log if message is NOT visible in public chat
    if not visibleMessages[messageKey] then
        -- Clean message for display
        local displayMsg = message:gsub("[\n\r]", ""):gsub("\t", " "):gsub(" +", " ")
        
        if Config.public then
            local formatted = (Config.publicItalics and "/me " or "") .. "{SPY} [" .. speaker.Name .. "]: " .. displayMsg
            TextChatService.TextChannels.RBXGeneral:SendAsync(formatted)
        else
            displaySystemMessage("{SPY} [" .. speaker.Name .. "]: " .. displayMsg)
        end
    end
end

-- Monitor public chat for visible messages
TextChatService.MessageReceived:Connect(function(message)
    if not message.TextSource then return end
    if message.TextChannel and message.TextChannel.Name == "RBXGeneral" then
        local speaker = Players:GetPlayerByUserId(message.TextSource.UserId)
        if speaker then
            local cleanMsg = message.Text:gsub("[\n\r]", ""):gsub("\t", " "):gsub(" +", " ")
            local messageKey = speaker.UserId .. ":" .. cleanMsg
            
            -- Mark as publicly visible
            visibleMessages[messageKey] = true
            
            -- Set timer to clear visibility marker
            if messageTimers[messageKey] then
                messageTimers[messageKey]:Disconnect()
            end
            messageTimers[messageKey] = task.delay(5, function()
                visibleMessages[messageKey] = nil
                messageTimers[messageKey] = nil
            end)
        end
    end
end)

-- Primary message processing
local function handleIncomingMessage(speaker, rawMessage, channel)
    if _G.chatSpyInstance ~= instance then return end
    if not speaker then return end
    
    -- Immediately process system messages
    if channel == "RBXSystem" then return end
    
    -- Process all other messages
    processMessage(speaker, rawMessage, channel)
end

-- Modern chat hook
TextChatService.MessageReceived:Connect(function(message)
    if not message.TextSource then return end
    local speaker = Players:GetPlayerByUserId(message.TextSource.UserId)
    if speaker then
        local channel = message.TextChannel and message.TextChannel.Name or "Unknown"
        handleIncomingMessage(speaker, message.Text, channel)
    end
end)

-- Legacy chat support
local function setupLegacyHook()
    local chatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
    if not chatEvents then return false end
    
    local onMessageDone = chatEvents:FindFirstChild("OnMessageDoneFiltering")
    if not onMessageDone then return false end
    
    onMessageDone.OnClientEvent:Connect(function(messageData)
        if not messageData.FromSpeaker then return end
        local speaker = Players:GetPlayerByUserId(messageData.FromSpeaker)
        if speaker then
            handleIncomingMessage(speaker, messageData.Message, messageData.OriginalChannel)
        end
    end)
    return true
end

setupLegacyHook()

-- Command handling
TextChatService.SendingMessage:Connect(function(params)
    if _G.chatSpyInstance ~= instance then return end
    
    local message = params.Text
    if string.sub(message:lower(), 1, 4) == "/spy" then
        Config.enabled = not Config.enabled
        task.wait(0.3)
        displaySystemMessage("{SPY " .. (Config.enabled and "EN" or "DIS") .. "ABLED}")
        params.Text = ""
        return
    end
end)

-- Handle own private messages
player.Chatted:Connect(function(rawMessage)
    if _G.chatSpyInstance ~= instance then return end
    if not Config.enabled then return end
    if not Config.spyOnMyself then return end
    
    -- Only process commands/whispers 
    if rawMessage:sub(1,3):lower() == "/w " or rawMessage:sub(1,1) == "/" then
        processMessage(player, rawMessage, "Private")
    end
end)

-- Initial status
displaySystemMessage("{SPY " .. (Config.enabled and "EN" or "DIS") .. "ABLED}")
