-- FE Advanced Fling V5.2 (Distance Fix)
-- [Keep all GUI code the same until the fling mechanics section]

-- Optimized Fling Mechanics (Updated Section)
local Flinging = false
local Target = nil
local PredictionFactor = 1.2  -- Reduced from 1.4
local BaseForce = 4200         -- Adjusted from 4500
local ForceMultiplier = 2.8    -- Reduced from 3.5
local DESIRED_DISTANCE = 8     -- Added optimal distance
local MAX_FORCE = 10000        -- Added safety cap

local function GetTarget()
    local targetPlayer = Players:FindFirstChild(TargetBox.Text)
    return targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
end

-- [Keep ApplyCollision function the same]

local function PrecisionFling()
    ApplyCollision(false)
    local HRP = LP.Character and LP.Character:WaitForChild("HumanoidRootPart")
    if not HRP or not Target then return end

    local BodyVelocity = Instance.new("BodyVelocity")
    BodyVelocity.Velocity = Vector3.new()
    BodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    BodyVelocity.P = 100000
    BodyVelocity.Parent = HRP

    while Flinging and task.wait() do
        if not Target.Parent or not HRP.Parent then
            Target = GetTarget()
            if not Target then break end
            HRP = LP.Character:WaitForChild("HumanoidRootPart")
        end

        -- Improved Distance Calculation
        local targetPos = Target.Position
        local targetVel = Target.Velocity
        local currentDist = (HRP.Position - targetPos).Magnitude
        
        -- Dynamic Prediction Control
        local prediction = targetVel * PredictionFactor * math.clamp(targetVel.Magnitude/20, 0, 1)
        local predictedPos = targetPos + prediction
        
        -- Smart Force Adjustment
        local distanceRatio = math.clamp(currentDist/DESIRED_DISTANCE, 0.5, 2)
        local force = BaseForce * (distanceRatio > 1 and ForceMultiplier or 1) * math.log(distanceRatio + 1)
        force = math.clamp(force, 1000, MAX_FORCE)
        
        -- Directional Control
        local direction = (predictedPos - HRP.Position).Unit
        local verticalComp = math.clamp((targetPos.Y - HRP.Position.Y) * 0.4, -2, 2)  -- Reduced vertical boost
        
        BodyVelocity.Velocity = (direction + Vector3.new(0, verticalComp, 0)) * force
        
        -- Proximity Dampening
        if currentDist < DESIRED_DISTANCE then
            BodyVelocity.Velocity = BodyVelocity.Velocity * 0.7  -- Reduce force when close
        end
    end

    BodyVelocity:Destroy()
    ApplyCollision(true)
end

-- [Keep the rest of the code the same]
