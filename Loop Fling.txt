local Players = game:GetService("Players")
local LP = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Client-side collision bypass
local function ghostCharacter(character)
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
                part.Massless = true
                part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
            end
        end
    end
end

-- Auto-apply to existing character
if LP.Character then
    ghostCharacter(LP.Character)
end
LP.CharacterAdded:Connect(ghostCharacter)

-- Enhanced Fling System
local Flinging = false
local ActiveCoroutine = nil
local PredictionTime = 0.45

local function FlingTarget(target)
    while Flinging and task.wait() do
        if target and target.Character and LP.Character then
            local tHRP = target.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = LP.Character:FindFirstChild("HumanoidRootPart")
            
            if tHRP and myHRP then
                -- Advanced prediction with velocity averaging
                local targetVel = tHRP.Velocity * 1.25
                local predictedPos = tHRP.Position + (targetVel * PredictionTime)
                local distance = (predictedPos - myHRP.Position).Magnitude
                
                -- Teleportation with smart positioning
                if distance > 25 then
                    myHRP.CFrame = CFrame.new(predictedPos + Vector3.new(0,5,0)) * 
                                  CFrame.Angles(math.rad(math.random(-15,15)), 
                                           math.rad(180 + math.random(-15,15)), 
                                           0)
                end
                
                -- Force application with rotational boost
                local dir = (predictedPos - myHRP.Position).Unit
                myHRP.Velocity = dir * 8500 + 
                                (targetVel * 0.9) + 
                                Vector3.new(0, 3250 + math.abs(targetVel.Y * 0.5), 0)
            end
        else
            Flinging = false
            Toggle.Text = "TOGGLE FLING"
            break
        end
    end
end

-- Smoother Camera System
local Tracking = false
local CameraDistance = 12
local targetZoom = 12
local smoothness = 0.85

local function TrackTarget(target)
    RunService.Heartbeat:Connect(function(delta)
        if Tracking and target and target.Character then
            local hrp = target.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                -- Smooth zoom interpolation
                CameraDistance = CameraDistance + (targetZoom - CameraDistance) * (1 - smoothness)
                
                -- Orbital camera with dynamic positioning
                local angle = tick() * 2
                Camera.CFrame = CFrame.new(
                    hrp.Position + Vector3.new(
                        math.sin(angle) * 3.5,
                        5 + math.cos(angle * 0.7) * 0.8,
                        math.cos(angle) * CameraDistance
                    ),
                    hrp.Position + Vector3.new(0, 2.5, 0)
                )
            end
        end
    end)
end

-- Improved Zoom Control
UIS.InputChanged:Connect(function(input)
    if Tracking and input.UserInputType == Enum.UserInputType.MouseWheel then
        targetZoom = math.clamp(targetZoom - input.Position.Y * 3.5, 8, 25)
    end
end)

-- Keep your original GUI code and button handlers
-- ... [Your existing GUI implementation] ...
