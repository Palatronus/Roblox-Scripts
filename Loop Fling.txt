local Players = game:GetService("Players")
local LP = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local PhysicsService = game:GetService("PhysicsService")

-- Collision groups setup
PhysicsService:CreateCollisionGroup("Flinger")
PhysicsService:CreateCollisionGroup("TargetPlayer")
PhysicsService:CollisionGroupSetCollidable("Flinger", "TargetPlayer", true)
PhysicsService:CollisionGroupSetCollidable("Flinger", "Default", false)

-- GUI Setup
local GUI = Instance.new("ScreenGui")
GUI.Parent = game.CoreGui

local Main = Instance.new("Frame")
Main.Size = UDim2.new(0, 300, 0, 200)
Main.Position = UDim2.new(0.5, -150, 0.5, -100)
Main.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
Main.Active = true
Main.Parent = GUI

-- Username Input (unchanged)
-- ... [Keep the original username input and suggestions code] ...

-- Fling System Modifications
local Flinging = false
local ActiveCoroutine = nil
local PredictionTime = 0.35

local function setCollisions(character, group)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            PhysicsService:SetPartCollisionGroup(part, group)
        end
    end
end

local function FlingTarget(target)
    while Flinging and task.wait(0.02) do
        if target and target.Character and LP.Character then
            -- Apply collision groups
            setCollisions(LP.Character, "Flinger")
            setCollisions(target.Character, "TargetPlayer")

            local tHRP = target.Character:FindFirstChild("HumanoidRootPart")
            local myHRP = LP.Character:FindFirstChild("HumanoidRootPart")
            local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
            
            if tHRP and myHRP and humanoid and humanoid.Health > 0 then
                -- Dynamic prediction based on target speed
                local targetSpeed = tHRP.Velocity.Magnitude
                local dynamicPrediction = math.clamp(PredictionTime * (1 + targetSpeed/50), 0.35, 1.2)
                
                local predictedPos = tHRP.Position + (tHRP.Velocity * dynamicPrediction)
                local distance = (predictedPos - myHRP.Position).Magnitude
                
                -- Improved teleportation with offset
                if distance > 30 then
                    myHRP.CFrame = CFrame.new(predictedPos + Vector3.new(0, 5, 0)) 
                                  * CFrame.Angles(0, math.rad(180), 0)
                end
                
                -- Enhanced velocity application
                local dirVector = (predictedPos - myHRP.Position).Unit
                myHRP.Velocity = dirVector * 7200 + (tHRP.Velocity * 0.8) + Vector3.new(
                    0, 
                    math.clamp(2800 + (distance * 5), 2800, 5000), 
                    0
                )
            end
        else
            Flinging = false
            Toggle.Text = "TOGGLE FLING"
            break
        end
    end
end

-- Improved Camera System
local Tracking = false
local OriginalCameraType = Camera.CameraType
local CameraDistance = 10
local targetCameraDistance = 10
local ZoomMomentum = 0
local timeOffset = 0

local function TrackTarget(target)
    local conn
    conn = RunService.Heartbeat:Connect(function(deltaTime)
        timeOffset = timeOffset + deltaTime
        CameraDistance = CameraDistance + (targetCameraDistance - CameraDistance) * 0.1
        
        if not Tracking then 
            conn:Disconnect()
            return 
        end
        
        if target and target.Character then
            local hrp = target.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                Camera.CameraType = Enum.CameraType.Scriptable
                local baseOffset = Vector3.new(
                    math.sin(timeOffset) * 2.5,
                    4 + math.cos(timeOffset * 0.8) * 0.5,
                    CameraDistance + ZoomMomentum
                )
                
                -- Smooth camera movement
                Camera.CFrame = Camera.CFrame:Lerp(
                    CFrame.new(hrp.Position + baseOffset, hrp.Position + Vector3.new(0, 2, 0)),
                    0.3
                )
            end
        else
            Tracking = false
            CamButton.Text = "TOGGLE CAMERA"
            Camera.CameraType = OriginalCameraType
        end
    end)
end

-- Improved Zoom Control
UIS.InputChanged:Connect(function(input)
    if Tracking and input.UserInputType == Enum.UserInputType.MouseWheel then
        local scrollDelta = input.Position.Y
        targetCameraDistance = math.clamp(targetCameraDistance - scrollDelta * 2.5, 5, 25)
        ZoomMomentum = math.clamp(ZoomMomentum + scrollDelta * 1.5, -4, 4)
    end
end)

-- Keep the original dragging system and button handlers
-- ... [Keep the original GUI dragging and button handling code] ...
