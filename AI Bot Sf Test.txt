[file name]: AI Bot Sf Prototypes_Debugged.txt
[file content begin]
--[[
    Linked Sword AI Combat Script (Fixed Version)
    
    This script implements autonomous sword fighting AI for the Linked Sword tool in Roblox.
    Optimized specifically for external executor usage with improved error handling and debugging.
]]

-- Force print to output console immediately
local function forcePrint(...)
    local message = table.concat({...}, " ")
    print(message)
    print("") -- Force flush
end

-- Debug function with timestamps
local function debugPrint(category, ...)
    local args = {...}
    local message = "[" .. category .. "] " .. table.concat(args, " ")
    local timestamp = os.date("%H:%M:%S")
    forcePrint(timestamp .. " - " .. message)
end

forcePrint("LinkedSwordAI: Script starting...")
debugPrint("INIT", "Debug logging enabled")

-- Garbage Collection Configuration
local GC_CONFIG = {
    ENABLED = true,
    COLLECTION_INTERVAL = 30,          -- Run GC every 30 seconds
    AGGRESSIVE_THRESHOLD = 100,        -- MB threshold for aggressive GC
    MAX_CACHE_ENTRIES = 20,            -- Limit cache sizes
    MAX_HISTORY_ENTRIES = 30,          -- Limit movement history
    CLEANUP_BATCH_SIZE = 50,           -- Objects to clean per batch
}

-- Global persistent data to maintain state across respawns
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {},
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        MovementHistory = {},
        FailedPaths = {},
        LastEquipAttempt = 0,
        EquipmentReady = false,
        KnownVoidAreas = {},
        PathCache = {},
        LastPathfindingTime = 0,
        PerformanceStats = {
            PathfindingTime = 0,
            CombatTime = 0,
            MovementTime = 0,
            LastOptimizationTime = 0,
            MemoryUsage = 0,
            GarbageCollections = 0,
            ObjectsCleaned = 0,
            LastGCTime = 0,
        },
        AlternativePaths = {},
        CurrentCombatBehavior = nil,
        LastBehaviorChangeTime = 0,
        PathCacheCount = 0,
        
        -- Garbage Collection System
        GarbageCollector = {
            LastCollectionTime = 0,
            MemorySnapshot = 0,
            ObjectsToClean = {},
            CleanupQueue = {},
            IsRunning = false
        }
    }
end

local persistentData = _G.LinkedSwordAIPersistentData

-- Configuration
local CONFIG = {
    DETECTION_RADIUS = 200,
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.7,
    LUNGE_DELAY = 0.1,
    STUCK_CHECK_DISTANCE = 1.5,
    STUCK_CHECK_TIME = 1.0,
    MAX_TARGET_DISTANCE = 250,
    MIN_HEALTH_CHECK = 0,
    RETARGET_CHECK_TIME = 1.5,
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -100,
    FORCEFIELD_FLEE_DISTANCE = 0,
    SWORD_CHECK_INTERVAL = 7,
    RESPAWN_EQUIP_DELAY = 1.5,
    MOVEMENT_MEMORY_TIME = 0.7,
    SAFE_GAP_DISTANCE = 10,
    PATH_SMOOTHING_FACTOR = 0.7,
    MOVEMENT_RETRY_DELAY = 1.0,
    NARROW_PASSAGE_WIDTH = 3.5,
    PATHFINDING_STEPS = 10,
    COMBAT_BEHAVIOR_CHANGE_TIME = 4.0,
    COMBAT_DEFENSIVE_CHANCE = 0.25,
    COMBAT_OFFENSIVE_CHANCE = 0.45,
    STRAFE_DISTANCE = 4,
    BRIDGE_CHECK_DISTANCE = 25,
    PERFORMANCE_MODE = true,
    PATH_CACHE_TIME = 3.0,
    ALTERNATIVE_PATH_COUNT = 4,
    MIN_ATTACK_DISTANCE = 3
}

-- Safe memory monitoring function
local function GetMemoryUsage()
    local success, result = pcall(function()
        return collectgarbage("count") / 1024
    end)
    return success and result or 0
end

-- Safe garbage collection system
local function RunGarbageCollection(aggressive)
    if not GC_CONFIG.ENABLED or (persistentData.GarbageCollector and persistentData.GarbageCollector.IsRunning) then
        return
    end
    
    if not persistentData.GarbageCollector then
        persistentData.GarbageCollector = {
            LastCollectionTime = 0,
            MemorySnapshot = 0,
            ObjectsToClean = {},
            CleanupQueue = {},
            IsRunning = false
        }
    end
    
    persistentData.GarbageCollector.IsRunning = true
    local startTime = tick()
    local stats = persistentData.PerformanceStats or {}
    local objectsCleaned = 0
    
    debugPrint("GC", "Starting garbage collection" .. (aggressive and " (aggressive)" or ""))
    
    -- Safe cleanup of PathCache
    if persistentData.PathCache then
        local currentTime = tick()
        for k, v in pairs(persistentData.PathCache) do
            if v and currentTime - (v.time or 0) > CONFIG.PATH_CACHE_TIME then
                persistentData.PathCache[k] = nil
                objectsCleaned = objectsCleaned + 1
            end
        end
    end
    
    -- Safe cleanup of FailedPaths
    if persistentData.FailedPaths then
        while #persistentData.FailedPaths > GC_CONFIG.MAX_CACHE_ENTRIES do
            table.remove(persistentData.FailedPaths, 1)
            objectsCleaned = objectsCleaned + 1
        end
    end
    
    -- Safe cleanup of KnownVoidAreas
    if persistentData.KnownVoidAreas then
        while #persistentData.KnownVoidAreas > GC_CONFIG.MAX_CACHE_ENTRIES do
            table.remove(persistentData.KnownVoidAreas, 1)
            objectsCleaned = objectsCleaned + 1
        end
    end
    
    -- Safe cleanup of MovementHistory
    if persistentData.MovementHistory then
        while #persistentData.MovementHistory > GC_CONFIG.MAX_HISTORY_ENTRIES do
            table.remove(persistentData.MovementHistory, 1)
            objectsCleaned = objectsCleaned + 1
        end
    end
    
    -- Safe cleanup of AlternativePaths
    if persistentData.AlternativePaths then
        local currentTime = tick()
        for k, v in pairs(persistentData.AlternativePaths) do
            if v and currentTime - (v.lastUsed or 0) > 60 then
                persistentData.AlternativePaths[k] = nil
                objectsCleaned = objectsCleaned + 1
            end
        end
    end
    
    -- Safe cleanup of player cache
    if persistentData.PlayersWithForceField then
        local validPlayers = {}
        for playerName, player in pairs(persistentData.PlayersWithForceField) do
            if player and player.Parent and player.Character then
                validPlayers[playerName] = player
            else
                objectsCleaned = objectsCleaned + 1
            end
        end
        persistentData.PlayersWithForceField = validPlayers
    end
    
    -- Aggressive cleaning if memory is high
    if aggressive or (stats.MemoryUsage or 0) > GC_CONFIG.AGGRESSIVE_THRESHOLD then
        debugPrint("GC", "Running aggressive cleanup - Memory: " .. string.format("%.1fMB", stats.MemoryUsage or 0))
        
        -- Clear all caches safely
        if persistentData.PathCache then persistentData.PathCache = {} end
        if persistentData.AlternativePaths then persistentData.AlternativePaths = {} end
        if persistentData.FailedPaths then persistentData.FailedPaths = {} end
        if persistentData.KnownVoidAreas then persistentData.KnownVoidAreas = {} end
        if persistentData.MovementHistory then persistentData.MovementHistory = {} end
        
        objectsCleaned = objectsCleaned + 20
        
        -- Force Lua garbage collection
        pcall(collectgarbage, "collect")
    end
    
    -- Update statistics safely
    if stats then
        stats.GarbageCollections = (stats.GarbageCollections or 0) + 1
        stats.ObjectsCleaned = (stats.ObjectsCleaned or 0) + objectsCleaned
        stats.LastGCTime = tick()
    end
    
    if persistentData.GarbageCollector then
        persistentData.GarbageCollector.LastCollectionTime = tick()
        persistentData.GarbageCollector.IsRunning = false
    end
    
    local gcTime = tick() - startTime
    debugPrint("GC", string.format("Collection completed: %d objects in %.3fs", objectsCleaned, gcTime))
    debugPrint("GC", string.format("Memory: %.1fMB -> %.1fMB", stats.MemoryUsage or 0, GetMemoryUsage()))
end

-- Safe lightweight periodic cleanup
local function RunLightCleanup()
    local currentTime = tick()
    local cleaned = 0
    
    -- Safe cleanup of FailedPaths
    if persistentData.FailedPaths and #persistentData.FailedPaths > GC_CONFIG.MAX_CACHE_ENTRIES then
        table.remove(persistentData.FailedPaths, 1)
        cleaned = cleaned + 1
    end
    
    -- Safe cleanup of KnownVoidAreas
    if persistentData.KnownVoidAreas and #persistentData.KnownVoidAreas > GC_CONFIG.MAX_CACHE_ENTRIES then
        table.remove(persistentData.KnownVoidAreas, 1)
        cleaned = cleaned + 1
    end
    
    -- Safe cleanup of MovementHistory
    if persistentData.MovementHistory and #persistentData.MovementHistory > GC_CONFIG.MAX_HISTORY_ENTRIES then
        table.remove(persistentData.MovementHistory, 1)
        cleaned = cleaned + 1
    end
    
    if cleaned > 0 then
        debugPrint("CLEAN", "Light cleanup: " .. cleaned .. " objects")
    end
end

-- Create status GUI
local function CreateStatusGUI()
    local gui = {}
    
    -- Try different parent options for compatibility
    local parentOptions = {
        game:GetService("CoreGui"),
        game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui"),
        game:GetService("Players").LocalPlayer.Character
    }
    
    local screenGui
    for _, parent in ipairs(parentOptions) do
        if parent then
            local success, result = pcall(function()
                local newGui = Instance.new("ScreenGui")
                newGui.Name = "LinkedSwordAI_Status"
                newGui.Parent = parent
                return newGui
            end)
            
            if success then
                screenGui = result
                break
            end
        end
    end
    
    if not screenGui then
        forcePrint("LinkedSwordAI: Failed to create GUI - No valid parent found")
        return nil
    end
    
    -- Create frame
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 120)
    frame.Position = UDim2.new(0.8, 0, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.5
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    frame.Parent = screenGui
    
    -- Status text
    local status = Instance.new("TextLabel")
    status.Size = UDim2.new(1, -10, 0, 20)
    status.Position = UDim2.new(0, 5, 0, 5)
    status.BackgroundTransparency = 1
    status.TextColor3 = Color3.fromRGB(255, 255, 255)
    status.Text = "Status: Initializing..."
    status.Font = Enum.Font.SourceSans
    status.TextSize = 14
    status.TextXAlignment = Enum.TextXAlignment.Left
    status.Parent = frame
    
    -- Target text
    local target = Instance.new("TextLabel")
    target.Size = UDim2.new(1, -10, 0, 20)
    target.Position = UDim2.new(0, 5, 0, 30)
    target.BackgroundTransparency = 1
    target.TextColor3 = Color3.fromRGB(255, 150, 150)
    target.Text = "Target: None"
    target.Font = Enum.Font.SourceSans
    target.TextSize = 14
    target.TextXAlignment = Enum.TextXAlignment.Left
    target.Parent = frame
    
    -- Distance text
    local distance = Instance.new("TextLabel")
    distance.Size = UDim2.new(1, -10, 0, 20)
    distance.Position = UDim2.new(0, 5, 0, 55)
    distance.BackgroundTransparency = 1
    distance.TextColor3 = Color3.fromRGB(150, 255, 150)
    distance.Text = "Distance: N/A"
    distance.Font = Enum.Font.SourceSans
    distance.TextSize = 14
    distance.TextXAlignment = Enum.TextXAlignment.Left
    distance.Parent = frame
    
    -- Debug text
    local debug = Instance.new("TextLabel")
    debug.Size = UDim2.new(1, -10, 0, 20)
    debug.Position = UDim2.new(0, 5, 0, 80)
    debug.BackgroundTransparency = 1
    debug.TextColor3 = Color3.fromRGB(255, 255, 0)
    debug.Text = "Debug: Starting..."
    debug.Font = Enum.Font.SourceSans
    debug.TextSize = 14
    debug.TextXAlignment = Enum.TextXAlignment.Left
    debug.Parent = frame
    
    -- GUI functions with nil checks
    function gui.UpdateStatus(text)
        if status and status.Parent then
            status.Text = "Status: " .. (text or "N/A")
        end
    end
    
    function gui.UpdateTarget(text)
        if target and target.Parent then
            target.Text = "Target: " .. (text or "None")
        end
    end
    
    function gui.UpdateDistance(dist)
        if distance and distance.Parent then
            distance.Text = "Distance: " .. (dist and string.format("%.1f", dist) or "N/A")
        end
    end
    
    function gui.UpdateDebug(text)
        if debug and debug.Parent then
            debug.Text = "Debug: " .. (text or "N/A")
        end
    end
    
    function gui.Destroy()
        if screenGui and screenGui.Parent then
            screenGui:Destroy()
        end
    end
    
    return gui
end

-- Safe main execution with comprehensive error handling
local function InitializeAI()
    -- Services with error handling
    local Players, RunService, Workspace
    local success, err = pcall(function()
        Players = game:GetService("Players")
        RunService = game:GetService("RunService")
        Workspace = game:GetService("Workspace")
    end)
    
    if not success or not Players then
        forcePrint("LinkedSwordAI: Failed to get services - " .. tostring(err))
        return false
    end
    
    -- Get player and character with error handling
    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        forcePrint("LinkedSwordAI: LocalPlayer not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: LocalPlayer found - " .. LocalPlayer.Name)
    
    local Character = LocalPlayer.Character
    if not Character then
        forcePrint("LinkedSwordAI: Character not found")
        return false
    end
    
    -- Wait for character to fully load
    wait(1)
    
    Character = LocalPlayer.Character
    if not Character then
        forcePrint("LinkedSwordAI: Character still not found after wait")
        return false
    end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    
    if not Humanoid or not HumanoidRootPart then
        forcePrint("LinkedSwordAI: Humanoid or HumanoidRootPart not found")
        -- Try again after a delay
        wait(1)
        Humanoid = Character:FindFirstChild("Humanoid")
        HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
        
        if not Humanoid or not HumanoidRootPart then
            forcePrint("LinkedSwordAI: Humanoid components still missing after retry")
            return false
        end
    end
    
    forcePrint("LinkedSwordAI: Character components found")
    
    -- Initialize missing persistent data fields safely
    if not persistentData.FailedPaths then persistentData.FailedPaths = {} end
    if not persistentData.KnownVoidAreas then persistentData.KnownVoidAreas = {} end
    if not persistentData.MovementHistory then persistentData.MovementHistory = {} end
    if not persistentData.PathCache then persistentData.PathCache = {} end
    if not persistentData.AlternativePaths then persistentData.AlternativePaths = {} end
    if not persistentData.PlayersWithForceField then persistentData.PlayersWithForceField = {} end
    if not persistentData.PerformanceStats then persistentData.PerformanceStats = {} end
    if not persistentData.GarbageCollector then 
        persistentData.GarbageCollector = {
            LastCollectionTime = 0,
            MemorySnapshot = 0,
            ObjectsToClean = {},
            CleanupQueue = {},
            IsRunning = false
        }
    end
    
    -- Create status GUI if it doesn't exist
    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
        if not persistentData.StatusGUI then
            forcePrint("LinkedSwordAI: Failed to create status GUI")
        else
            forcePrint("LinkedSwordAI: Status GUI created")
        end
    end
    
    -- Safe function to find Linked Sword tool
    local function FindLinkedSword()
        if not Character or not LocalPlayer then return nil end
        
        -- First check if we have a stored sword name and try to find that specific sword
        if persistentData.SwordToolName then
            -- Check character for the specific sword
            local storedSword = Character:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found stored sword: " .. storedSword.Name) 
                end
                forcePrint("LinkedSwordAI: Found stored sword - " .. storedSword.Name)
                return storedSword
            end
            
            -- Check backpack for the specific sword
            local backpack = LocalPlayer:FindFirstChild("Backpack")
            if backpack then
                storedSword = backpack:FindFirstChild(persistentData.SwordToolName)
                if storedSword and storedSword:IsA("Tool") then
                    if persistentData.StatusGUI then 
                        persistentData.StatusGUI.UpdateStatus("Found stored sword in backpack: " .. storedSword.Name) 
                    end
                    forcePrint("LinkedSwordAI: Found stored sword in backpack - " .. storedSword.Name)
                    return storedSword
                end
            end
        end
        
        -- If we couldn't find the stored sword, look for any sword
        for _, tool in pairs(Character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found sword: " .. tool.Name) 
                end
                forcePrint("LinkedSwordAI: Found sword - " .. tool.Name)
                return tool
            end
        end
        
        -- Check backpack if not found in character
        local backpack = LocalPlayer:FindFirstChild("Backpack")
        if backpack then
            for _, tool in pairs(backpack:GetChildren()) do
                if tool:IsA("Tool") and tool.Name:find("Sword") then
                    persistentData.SwordToolName = tool.Name
                    if persistentData.StatusGUI then 
                        persistentData.StatusGUI.UpdateStatus("Found sword in backpack: " .. tool.Name) 
                    end
                    forcePrint("LinkedSwordAI: Found sword in backpack - " .. tool.Name)
                    return tool
                end
            end
        end
        
        if persistentData.StatusGUI then 
            persistentData.StatusGUI.UpdateStatus("No sword found") 
        end
        forcePrint("LinkedSwordAI: No sword found")
        return nil
    end
    
    -- Safe check for sword periodically
    local function CheckForSword()
        if not Character then return end
        
        local currentTime = tick()
        if currentTime - (persistentData.LastSwordCheckTime or 0) > CONFIG.SWORD_CHECK_INTERVAL then
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword = FindLinkedSword()
            end
            persistentData.LastSwordCheckTime = currentTime
        end
    end
    
    -- Safe function to find players in range
    local function FindPlayersInRange()
        local playersInRange = {}
        
        if not HumanoidRootPart then return playersInRange end
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and 
               player.Character:FindFirstChild("HumanoidRootPart") and
               player.Character:FindFirstChild("Humanoid") and
               (player.Character.Humanoid.Health or 0) > CONFIG.MIN_HEALTH_CHECK then
                
                local playerHRP = player.Character.HumanoidRootPart
                local distance = (playerHRP.Position - HumanoidRootPart.Position).Magnitude
                
                if distance <= CONFIG.DETECTION_RADIUS then
                    -- Check if player has ForceField
                    local hasForceField = false
                    for _, child in pairs(player.Character:GetChildren()) do
                        if child:IsA("ForceField") then
                            hasForceField = true
                            persistentData.PlayersWithForceField[player.Name] = player
                            break
                        end
                    end
                    
                    if not hasForceField and persistentData.PlayersWithForceField[player.Name] then
                        persistentData.PlayersWithForceField[player.Name] = nil
                    end
                    
                    table.insert(playersInRange, {
                        player = player,
                        distance = distance,
                        hasForceField = hasForceField
                    })
                end
            end
        end
        
        -- Sort by distance
        table.sort(playersInRange, function(a, b)
            return (a.distance or 0) < (b.distance or 0)
        end)
        
        return playersInRange
    end
    
    -- Safe function to check if position is in void area
    local function IsVoidArea(position)
        if not position then return true end
        
        -- Check against known void areas first
        if persistentData.KnownVoidAreas then
            for i, voidPos in ipairs(persistentData.KnownVoidAreas) do
                if voidPos and (position - voidPos).Magnitude < 5 then
                    return true
                end
            end
        end
        
        -- Basic Y-threshold check
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            -- Add to known void areas if not too many stored
            if not persistentData.KnownVoidAreas then persistentData.KnownVoidAreas = {} end
            if #persistentData.KnownVoidAreas < 50 then
                table.insert(persistentData.KnownVoidAreas, position)
            else
                -- Replace oldest entry
                table.remove(persistentData.KnownVoidAreas, 1)
                table.insert(persistentData.KnownVoidAreas, position)
            end
            return true
        end
        
        -- Raycast to check for ground
        local ray = Ray.new(position, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
        local hit, _ = Workspace:FindPartOnRay(ray, Character)
        
        if not hit then
            -- Add to known void areas if not too many stored
            if not persistentData.KnownVoidAreas then persistentData.KnownVoidAreas = {} end
            if #persistentData.KnownVoidAreas < 50 then
                table.insert(persistentData.KnownVoidAreas, position)
            else
                -- Replace oldest entry
                table.remove(persistentData.KnownVoidAreas, 1)
                table.insert(persistentData.KnownVoidAreas, position)
            end
            return true
        end
        
        return false
    end
    
    -- Safe function to check if gap is safe to traverse
    local function IsSafeGap(startPos, endPos)
        if not startPos or not endPos then return false end
        
        local distance = (endPos - startPos).Magnitude
        
        -- For small gaps, just check the end position
        if distance < 3 then
            return not IsVoidArea(endPos)
        end
        
        -- For medium gaps, check for ground on the other side
        if distance < CONFIG.SAFE_GAP_DISTANCE then
            local ray = Ray.new(endPos, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
            local hit, _ = Workspace:FindPartOnRay(ray, Character)
            return hit ~= nil
        end
        
        -- For larger gaps, check multiple points along the path
        local direction = (endPos - startPos).Unit
        local checkCount = math.ceil(distance / 2)
        
        for i = 1, checkCount do
            local checkPoint = startPos + direction * (i * 2)
            local ray = Ray.new(checkPoint, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
            local hit, _ = Workspace:FindPartOnRay(ray, Character)
            
            if not hit then
                return false
            end
        end
        
        return true
    end
    
    -- Safe function to check if passage is narrow
    local function IsNarrowPassage(position, direction)
        if not position or not direction then return false end
        
        local leftRay = Ray.new(position, direction:Cross(Vector3.new(0, 1, 0)).Unit * CONFIG.NARROW_PASSAGE_WIDTH)
        local rightRay = Ray.new(position, direction:Cross(Vector3.new(0, 1, 0)).Unit * -CONFIG.NARROW_PASSAGE_WIDTH)
        
        local leftHit, _ = Workspace:FindPartOnRay(leftRay, Character)
        local rightHit, _ = Workspace:FindPartOnRay(rightRay, Character)
        
        return leftHit and rightHit
    end
    
    -- Safe function to find bridge path
    local function FindBridgePath(startPos, endPos)
        if not startPos or not endPos then return nil end
        
        local direction = (endPos - startPos).Unit
        local distance = (endPos - startPos).Magnitude
        
        -- Check for bridges at different distances
        for dist = 5, math.min(CONFIG.BRIDGE_CHECK_DISTANCE, distance), 5 do
            local checkPoint = startPos + direction * dist
            
            -- Check below for bridge
            for y = 0, -20, -2 do
                local bridgeCheckPoint = checkPoint + Vector3.new(0, y, 0)
                local ray = Ray.new(bridgeCheckPoint, Vector3.new(0, -5, 0))
                local hit, hitPos = Workspace:FindPartOnRay(ray, Character)
                
                if hit then
                    -- Found potential bridge, check if it leads to target
                    local bridgePath = hitPos + Vector3.new(0, 3, 0)
                    
                    -- Check if we can reach the bridge and if it's safe
                    if IsSafeGap(startPos, bridgePath) then
                        return bridgePath
                    end
                end
            end
        end
        
        return nil
    end
    
    -- Safe function to check if path is safe
    local function IsSafePath(targetPosition)
        if not targetPosition or not HumanoidRootPart then return false end
        
        -- Performance optimization: Check cache first
        if CONFIG.PERFORMANCE_MODE then
            local currentTime = tick()
            local hashKey = math.floor(targetPosition.X) .. "," .. 
                           math.floor(targetPosition.Y) .. "," .. 
                           math.floor(targetPosition.Z)
            
            if persistentData.PathCache then
                local data = persistentData.PathCache[hashKey]
                if data and currentTime - (data.time or 0) < CONFIG.PATH_CACHE_TIME then
                    debugPrint("PATH", "Using cached path result: " .. ((data.safe and "SAFE") or "UNSAFE"))
                    return data.safe, data.bridgePath, data.alternativePath
                end
            end
        end
        
        local startPos = HumanoidRootPart.Position
        local direction = (targetPosition - startPos).Unit
        local distance = (targetPosition - startPos).Magnitude
        
        -- Check if we're in a narrow passage
        local isNarrow = IsNarrowPassage(startPos, direction)
        
        -- If in narrow passage, use more careful pathfinding
        if isNarrow then
            local narrowIncrement = math.min(2, distance / 8)
            
            for i = narrowIncrement, distance, narrowIncrement do
                local checkPos = startPos + direction * i
                
                if not IsNarrowPassage(checkPos, direction) then
                    if IsVoidArea(checkPos) then
                        if persistentData.FailedPaths and #persistentData.FailedPaths >= 10 then
                            table.remove(persistentData.FailedPaths, 1)
                        end
                        if not persistentData.FailedPaths then persistentData.FailedPaths = {} end
                        table.insert(persistentData.FailedPaths, {
                            position = targetPosition,
                            time = tick()
                        })
                        
                        if CONFIG.PERFORMANCE_MODE and persistentData.PathCache then
                            local hashKey = math.floor(targetPosition.X) .. "," .. 
                                           math.floor(targetPosition.Y) .. "," .. 
                                           math.floor(targetPosition.Z)
                            
                            persistentData.PathCache[hashKey] = {
                                safe = false,
                                time = tick(),
                                bridgePath = nil
                            }
                            
                            persistentData.PathCacheCount = (persistentData.PathCacheCount or 0) + 1
                            if persistentData.PathCacheCount > 20 then
                                local cacheEntries = {}
                                for k, v in pairs(persistentData.PathCache) do
                                    table.insert(cacheEntries, {key = k, time = v.time or 0})
                                end
                                
                                table.sort(cacheEntries, function(a, b) return (a.time or 0) < (b.time or 0) end)
                                
                                local removeCount = math.floor(persistentData.PathCacheCount * 0.25)
                                for i = 1, removeCount do
                                    if cacheEntries[i] then
                                        persistentData.PathCache[cacheEntries[i].key] = nil
                                    end
                                end
                                persistentData.PathCacheCount = persistentData.PathCacheCount - removeCount
                            end
                        end
                        
                        return false
                    end
                    break
                end
            end
        else
            local increment = math.min(5, distance / 5)
            
            for i = increment, distance, increment do
                local checkPos = startPos + direction * i
                if IsVoidArea(checkPos) then
                    local bridgePath = FindBridgePath(startPos, targetPosition)
                    if bridgePath then
                        if CONFIG.PERFORMANCE_MODE and persistentData.PathCache then
                            persistentData.PathCache[targetPosition] = {
                                safe = true,
                                time = tick(),
                                bridgePath = bridgePath
                            }
                        end
                        return true, bridgePath
                    end
                    
                    local halfDistance = distance * 0.5
                    local piDivided = math.pi / CONFIG.ALTERNATIVE_PATH_COUNT
                    local upVector = Vector3.new(0, 1, 0)
                    
                    for altIndex = 1, CONFIG.ALTERNATIVE_PATH_COUNT do
                        local angle = altIndex * piDivided
                        local altDirection = CFrame.fromAxisAngle(upVector, angle) * direction
                        local altTargetPos = startPos + altDirection * halfDistance
                        
                        local altSafe = true
                        for j = increment, distance * 0.5, increment do
                            local altCheckPos = startPos + altDirection * j
                            if IsVoidArea(altCheckPos) then
                                altSafe = false
                                break
                            end
                        end
                        
                        if altSafe then
                            if not persistentData.AlternativePaths then persistentData.AlternativePaths = {} end
                            persistentData.AlternativePaths[targetPosition] = altTargetPos
                            
                            if CONFIG.PERFORMANCE_MODE and persistentData.PathCache then
                                persistentData.PathCache[targetPosition] = {
                                    safe = false,
                                    time = tick(),
                                    bridgePath = nil,
                                    alternativePath = altTargetPos
                                }
                            end
                            
                            return false, nil, altTargetPos
                        end
                    end
                    
                    if persistentData.FailedPaths and #persistentData.FailedPaths >= 10 then
                        table.remove(persistentData.FailedPaths, 1)
                    end
                    if not persistentData.FailedPaths then persistentData.FailedPaths = {} end
                    table.insert(persistentData.FailedPaths, {
                        position = targetPosition,
                        time = tick()
                    })
                    
                    if CONFIG.PERFORMANCE_MODE and persistentData.PathCache then
                        persistentData.PathCache[targetPosition] = {
                            safe = false,
                            time = tick(),
                            bridgePath = nil
                        }
                    end
                    
                    return false
                end
            end
        end
        
        if IsVoidArea(targetPosition) then
            if persistentData.FailedPaths and #persistentData.FailedPaths >= 10 then
                table.remove(persistentData.FailedPaths, 1)
            end
            if not persistentData.FailedPaths then persistentData.FailedPaths = {} end
            table.insert(persistentData.FailedPaths, {
                position = targetPosition,
                time = tick()
            })
            
            if CONFIG.PERFORMANCE_MODE and persistentData.PathCache then
                persistentData.PathCache[targetPosition] = {
                    safe = false,
                    time = tick(),
                    bridgePath = nil
                }
            end
            
            return false
        end
        
        if CONFIG.PERFORMANCE_MODE and persistentData.PathCache then
            persistentData.PathCache[targetPosition] = {
                safe = true,
                time = tick(),
                bridgePath = nil
            }
        end
        
        return true
    end
    
    -- Safe function to check if stuck
    local function CheckIfStuck()
        if not HumanoidRootPart then return false end
        
        if not persistentData.LastStuckPosition then
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = tick()
            return false
        end
        
        local currentTime = tick()
        local timeDiff = currentTime - (persistentData.LastStuckTime or 0)
        
        if timeDiff > CONFIG.STUCK_CHECK_TIME then
            local distance = (HumanoidRootPart.Position - persistentData.LastStuckPosition).Magnitude
            
            if distance < CONFIG.STUCK_CHECK_DISTANCE then
                persistentData.IsStuck = true
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Stuck detected") end
                return true
            end
            
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = currentTime
        end
        
        return false
    end
    
    -- Safe function to handle being stuck
    local function HandleStuckOnPlayer()
        if not HumanoidRootPart or not Humanoid then return false end
        
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Unstucking from player") end
        
        local directions = {
            Vector3.new(1, 0, 0),
            Vector3.new(-1, 0, 0),
            Vector3.new(0, 0, 1),
            Vector3.new(0, 0, -1),
            Vector3.new(1, 0, 1).Unit,
            Vector3.new(-1, 0, 1).Unit,
            Vector3.new(1, 0, -1).Unit,
            Vector3.new(-1, 0, -1).Unit
        }
        
        for _, direction in ipairs(directions) do
            local targetPosition = HumanoidRootPart.Position + direction * 5
            
            if IsSafePath(targetPosition) then
                pcall(function() Humanoid:MoveTo(targetPosition) end)
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Moving to unstuck") end
                return true
            end
        end
        
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("No safe path to unstuck") end
        return false
    end
    
    -- Safe function to handle fleeing from ForceField players
    local function HandleFleeFromForceField()
        if CONFIG.FORCEFIELD_FLEE_DISTANCE <= 0 or not HumanoidRootPart or not Humanoid then
            return false
        end
        
        local nearestFFPlayer = nil
        local nearestDistance = math.huge
        
        if persistentData.PlayersWithForceField then
            for _, ffPlayer in pairs(persistentData.PlayersWithForceField) do
                if ffPlayer and ffPlayer.Character and ffPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local distance = (ffPlayer.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                    
                    if distance < nearestDistance then
                        nearestFFPlayer = ffPlayer
                        nearestDistance = distance
                    end
                end
            end
        end
        
        if nearestFFPlayer and nearestDistance < CONFIG.FORCEFIELD_FLEE_DISTANCE then
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateStatus("Fleeing from " .. nearestFFPlayer.Name .. " (ForceField)")
                persistentData.StatusGUI.UpdateDebug("ForceField detected at " .. string.format("%.1f", nearestDistance) .. " studs")
            end
            
            local fleeDirection = (HumanoidRootPart.Position - nearestFFPlayer.Character.HumanoidRootPart.Position).Unit
            local fleeTarget = HumanoidRootPart.Position + fleeDirection * CONFIG.FORCEFIELD_FLEE_DISTANCE
            
            if IsSafePath(fleeTarget) then
                pcall(function() Humanoid:MoveTo(fleeTarget) end)
                return true
            else
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Warning: No safe path to flee") end
                
                local alternativeDirections = {
                    (fleeDirection + Vector3.new(0.3, 0, 0.3)).Unit,
                    (fleeDirection + Vector3.new(-0.3, 0, 0.3)).Unit,
                    (fleeDirection + Vector3.new(0.3, 0, -0.3)).Unit,
                    (fleeDirection + Vector3.new(-0.3, 0, -0.3)).Unit
                }
                
                for _, altDir in ipairs(alternativeDirections) do
                    local altTarget = HumanoidRootPart.Position + altDir * CONFIG.FORCEFIELD_FLEE_DISTANCE
                    if IsSafePath(altTarget) then
                        pcall(function() Humanoid:MoveTo(altTarget) end)
                        return true
                    end
                end
                
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Warning: All flee paths unsafe") end
            end
        end
        
        return false
    end
    
    -- Safe movement function
    local function MoveTo(targetPosition, bridgePath, alternativePath)
        if not HumanoidRootPart or not Humanoid then return false end
        
        local startTime = tick()
        
        if bridgePath then
            targetPosition = bridgePath
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Using bridge path")
            end
        end
        
        if alternativePath then
            targetPosition = alternativePath
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Using alternative path")
            end
        end
        
        local currentDirection = (targetPosition - HumanoidRootPart.Position).Unit
        local currentTime = tick()
        
        local smoothedDirection = currentDirection
        if persistentData.LastMovementDirection and 
           currentTime - (persistentData.LastMovementTime or 0) < CONFIG.MOVEMENT_MEMORY_TIME then
            smoothedDirection = (persistentData.LastMovementDirection * CONFIG.PATH_SMOOTHING_FACTOR + 
                               currentDirection * (1 - CONFIG.PATH_SMOOTHING_FACTOR)).Unit
        end
        
        local smoothedTarget = HumanoidRootPart.Position + smoothedDirection * 
                              math.min(5, (targetPosition - HumanoidRootPart.Position).Magnitude)
        
        local isNarrow = IsNarrowPassage(HumanoidRootPart.Position, smoothedDirection)
        
        if isNarrow then
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Navigating narrow passage")
            end
            
            smoothedDirection = currentDirection
            smoothedTarget = HumanoidRootPart.Position + smoothedDirection * 
                           math.min(2, (targetPosition - HumanoidRootPart.Position).Magnitude)
        end
        
        if IsSafeGap(HumanoidRootPart.Position, smoothedTarget) then
            persistentData.LastMovementDirection = smoothedDirection
            persistentData.LastMovementTime = currentTime
            
            pcall(function() Humanoid:MoveTo(smoothedTarget) end)
            
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Moving: " .. 
                    string.format("(%.1f, %.1f, %.1f)", 
                    smoothedDirection.X, smoothedDirection.Y, smoothedDirection.Z))
            end
            
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PerformanceStats.MovementTime = tick() - startTime
            end
            
            return true
        else
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Unsafe path detected")
            end
            return false
        end
    end
    
    -- Safe attack execution
    local function ExecuteAttack()
        if not persistentData.LinkedSword then
            forcePrint("LinkedSwordAI: Cannot attack - No sword equipped")
            return
        end
        
        if persistentData.AttackSequenceActive then
            return
        end
        
        persistentData.AttackSequenceActive = true
        persistentData.LastAttackTime = tick()
        
        if not persistentData.CurrentCombatBehavior or 
           tick() - (persistentData.LastBehaviorChangeTime or 0) > CONFIG.COMBAT_BEHAVIOR_CHANGE_TIME then
            
            local rand = math.random()
            if rand < CONFIG.COMBAT_DEFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "defensive"
            elseif rand < CONFIG.COMBAT_DEFENSIVE_CHANCE + CONFIG.COMBAT_OFFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "offensive"
            else
                persistentData.CurrentCombatBehavior = "offensive-defensive"
            end
            
            persistentData.LastBehaviorChangeTime = tick()
            
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateStatus("Combat: " .. persistentData.CurrentCombatBehavior)
            end
        end
        
        if persistentData.CurrentTarget and 
           persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") and
           HumanoidRootPart then
            
            local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
            pcall(function()
                HumanoidRootPart.CFrame = CFrame.new(
                    HumanoidRootPart.Position,
                    Vector3.new(targetPos.X, HumanoidRootPart.Position.Y, targetPos.Z)
                )
            end)
        end
        
        if persistentData.StatusGUI then
            persistentData.StatusGUI.UpdateDebug("Executing " .. (persistentData.CurrentCombatBehavior or "unknown") .. " attack")
        end
        
        spawn(function()
            if persistentData.CurrentCombatBehavior == "defensive" then
                forcePrint("LinkedSwordAI: Defensive attack")
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.2)
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.5)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") and
                   HumanoidRootPart then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (HumanoidRootPart.Position - targetPos).Unit
                    local backPos = HumanoidRootPart.Position + moveDir * 2
                    
                    MoveTo(backPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            elseif persistentData.CurrentCombatBehavior == "offensive" then
                forcePrint("LinkedSwordAI: Offensive attack")
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.6)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") and
                   HumanoidRootPart then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local forwardPos = HumanoidRootPart.Position + moveDir * 3
                    
                    MoveTo(forwardPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.7)
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            else
                forcePrint("LinkedSwordAI: Offensive-defensive attack")
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") and
                   HumanoidRootPart then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local strafeDir = moveDir:Cross(Vector3.new(0, 1, 0)).Unit
                    
                    if math.random() > 0.5 then
                        strafeDir = -strafeDir
                    end
                    
                    local strafePos = HumanoidRootPart.Position + strafeDir * CONFIG.STRAFE_DISTANCE
                    MoveTo(strafePos)
                end
                
                wait(CONFIG.LUNGE_DELAY)
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") and
                   HumanoidRootPart then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local approachPos = HumanoidRootPart.Position + moveDir * 2
                    
                    MoveTo(approachPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
            end
            
            wait(0.2)
            persistentData.AttackSequenceActive = false
        end)
    end
    
    -- Enhanced main update function with comprehensive error handling
    local function Update()
        -- Update memory usage safely
        pcall(function()
            persistentData.PerformanceStats.MemoryUsage = GetMemoryUsage()
        end)
        
        -- Run light cleanup
        pcall(RunLightCleanup)
        
        -- Run garbage collection periodically
        local currentTime = tick()
        if currentTime - (persistentData.GarbageCollector.LastCollectionTime or 0) > GC_CONFIG.COLLECTION_INTERVAL then
            local aggressive = (persistentData.PerformanceStats.MemoryUsage or 0) > GC_CONFIG.AGGRESSIVE_THRESHOLD
            pcall(RunGarbageCollection, aggressive)
        end
        
        -- Original performance optimization
        if CONFIG.PERFORMANCE_MODE and currentTime - (persistentData.PerformanceStats.LastOptimizationTime or 0) > 30 then
            if persistentData.PathCache then
                local oldestTime = math.huge
                local oldestKey = nil
                local cacheCount = 0
                
                for k, v in pairs(persistentData.PathCache) do
                    cacheCount = cacheCount + 1
                    if (v.time or 0) < oldestTime then
                        oldestTime = v.time or 0
                        oldestKey = k
                    end
                end
                
                if cacheCount > 20 and oldestKey then
                    persistentData.PathCache[oldestKey] = nil
                end
            end
            
            if persistentData.FailedPaths then
                for i = #persistentData.FailedPaths, 1, -1 do
                    if currentTime - (persistentData.FailedPaths[i].time or 0) > 20 then
                        table.remove(persistentData.FailedPaths, i)
                    end
                end
            end
            
            persistentData.PerformanceStats.LastOptimizationTime = currentTime
            debugPrint("PERF", "Memory optimization complete")
        end
        
        -- Check for sword
        pcall(CheckForSword)
        
        -- Check if character components still exist
        if not Character or not Character.Parent or not Humanoid or not HumanoidRootPart then
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateStatus("Character missing")
            end
            return
        end
        
        local needNewTarget = not persistentData.CurrentTarget or 
                             not persistentData.CurrentTarget.Character or 
                             not persistentData.CurrentTarget.Character.Parent or
                             not persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        
        local checkForCloserTarget = currentTime - (persistentData.LastRetargetTime or 0) > CONFIG.RETARGET_CHECK_TIME
        
        if needNewTarget or checkForCloserTarget then
            local playersInRange = pcall(FindPlayersInRange) and FindPlayersInRange() or {}
            
            if #playersInRange > 0 then
                local validTargets = playersInRange
                
                if #validTargets > 0 then
                    local newTarget = validTargets[1].player
                    
                    if newTarget ~= persistentData.CurrentTarget then
                        persistentData.CurrentTarget = newTarget
                        if persistentData.StatusGUI then 
                            persistentData.StatusGUI.UpdateTarget(newTarget.Name)
                            persistentData.StatusGUI.UpdateStatus("Targeting " .. newTarget.Name)
                        end
                        debugPrint("TARGET", "New target - " .. newTarget.Name)
                    end
                else
                    if persistentData.StatusGUI then 
                        persistentData.StatusGUI.UpdateTarget("None")
                        persistentData.StatusGUI.UpdateStatus("No valid targets")
                    end
                    persistentData.CurrentTarget = nil
                end
            else
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("No targets in range")
                    persistentData.StatusGUI.UpdateTarget("None")
                end
                persistentData.CurrentTarget = nil
            end
            
            persistentData.LastRetargetTime = currentTime
        end
        
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character.Parent and
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetHRP = persistentData.CurrentTarget.Character.HumanoidRootPart
            local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
            
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateDistance(distance)
            end
            
            if pcall(CheckIfStuck) and CheckIfStuck() then
                pcall(HandleStuckOnPlayer)
                return
            else
                persistentData.IsStuck = false
            end
            
            local isSafe, bridgePath, alternativePath = pcall(IsSafePath, targetHRP.Position)
            isSafe = isSafe and (bridgePath or alternativePath or true)
            
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PerformanceStats.PathfindingTime = tick() - currentTime
            end
            
            if isSafe then
                pcall(MoveTo, targetHRP.Position, bridgePath)
                
                if HumanoidRootPart then
                    pcall(function()
                        HumanoidRootPart.CFrame = CFrame.lookAt(
                            HumanoidRootPart.Position, 
                            Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
                        )
                    end)
                end
                
                if distance <= CONFIG.ATTACK_RANGE and 
                   persistentData.LinkedSword and 
                   currentTime - (persistentData.LastAttackTime or 0) > CONFIG.ATTACK_COOLDOWN then
                    pcall(ExecuteAttack)
                elseif distance <= CONFIG.MIN_ATTACK_DISTANCE and 
                       persistentData.LinkedSword and 
                       currentTime - (persistentData.LastAttackTime or 0) > CONFIG.ATTACK_COOLDOWN then
                    debugPrint("COMBAT", "Close range attack")
                    persistentData.CurrentCombatBehavior = "offensive"
                    pcall(ExecuteAttack)
                end
            elseif alternativePath then
                debugPrint("PATH", "Using alternative path")
                pcall(MoveTo, alternativePath)
                
                if HumanoidRootPart then
                    pcall(function()
                        HumanoidRootPart.CFrame = CFrame.lookAt(
                            HumanoidRootPart.Position, 
                            Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
                        )
                    end)
                end
                
                if distance <= CONFIG.ATTACK_RANGE and 
                   persistentData.LinkedSword and 
                   currentTime - (persistentData.LastAttackTime or 0) > CONFIG.ATTACK_COOLDOWN then
                    pcall(ExecuteAttack)
                end
            else
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Finding safe path")
                    persistentData.StatusGUI.UpdateDebug("Checking bridge paths")
                end
                
                local bridgePath = pcall(FindBridgePath, HumanoidRootPart.Position, targetHRP.Position)
                if bridgePath then
                    if persistentData.StatusGUI then 
                        persistentData.StatusGUI.UpdateDebug("Using bridge path")
                    end
                    pcall(MoveTo, bridgePath)
                    return
                end
                
                local alternativeDirections = {
                    Vector3.new(1, 0, 0),
                    Vector3.new(-1, 0, 0),
                    Vector3.new(0, 0, 1),
                    Vector3.new(0, 0, -1),
                    Vector3.new(1, 0, 1).Unit,
                    Vector3.new(-1, 0, 1).Unit,
                    Vector3.new(1, 0, -1).Unit,
                    Vector3.new(-1, 0, -1).Unit
                }
                
                local foundSafePath = false
                for _, dir in ipairs(alternativeDirections) do
                    local alternativeTarget = HumanoidRootPart.Position + dir * 10
                    local altSafe, altBridgePath = pcall(IsSafePath, alternativeTarget)
                    
                    if altSafe then
                        if persistentData.StatusGUI then 
                            persistentData.StatusGUI.UpdateDebug("Found alternative path")
                        end
                        pcall(MoveTo, alternativeTarget, altBridgePath)
                        foundSafePath = true
                        break
                    end
                end
                
                if not foundSafePath and persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateDebug("No safe path found")
                end
            end
        else
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateStatus("Idle")
            end
        end
    end
    
    -- Handle sword equipping on respawn
    spawn(function()
        wait(CONFIG.RESPAWN_EQUIP_DELAY)
        
        if not Character or not Character.Parent then return end
        
        persistentData.LinkedSword = pcall(FindLinkedSword) and FindLinkedSword() or nil
        if persistentData.LinkedSword then
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateStatus("Sword found: " .. persistentData.LinkedSword.Name)
            end
            
            if persistentData.LinkedSword.Parent ~= Character then
                pcall(function() persistentData.LinkedSword.Parent = Character end)
                wait(0.5)
                
                if persistentData.LinkedSword.Parent == Character then
                    persistentData.EquipmentReady = true
                    if persistentData.StatusGUI then
                        persistentData.StatusGUI.UpdateStatus("Sword equipped successfully")
                    end
                else
                    wait(0.5)
                    if persistentData.LinkedSword then
                        pcall(function() persistentData.LinkedSword.Parent = Character end)
                        wait(0.5)
                        persistentData.EquipmentReady = true
                        if persistentData.StatusGUI then
                            persistentData.StatusGUI.UpdateStatus("Sword equipped on retry")
                        end
                    end
                end
            else
                persistentData.EquipmentReady = true
                if persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateStatus("Sword already equipped")
                end
            end
        else
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateStatus("No sword found to equip")
            end
        end
    end)
    
    -- Initialize
    persistentData.LinkedSword = pcall(FindLinkedSword) and FindLinkedSword() or nil
    persistentData.LastSwordCheckTime = tick()
    
    -- Connect update function with comprehensive error handling
    local updateConnection
    updateConnection = RunService.Heartbeat:Connect(function()
        local success, error = pcall(Update)
        if not success then
            forcePrint("LinkedSwordAI: Error in update - " .. tostring(error))
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateStatus("Error: " .. tostring(error)) 
            end
        end
    end)
    
    -- Handle character respawn
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        forcePrint("LinkedSwordAI: Character respawned, reinitializing...")
        
        -- Clean up connections
        if updateConnection then
            updateConnection:Disconnect()
        end
        
        -- Clean up GUI
        if persistentData.StatusGUI then
            pcall(persistentData.StatusGUI.Destroy)
            persistentData.StatusGUI = nil
        end
        
        wait(2) -- Wait for character to fully load
        pcall(InitializeAI)
    end)
    
    if persistentData.StatusGUI then 
        persistentData.StatusGUI.UpdateStatus("AI Running") 
    end
    forcePrint("LinkedSwordAI: Script initialized successfully")
    
    return true
end

-- Enhanced startup with comprehensive error handling
local function SafeStartup()
    forcePrint("LinkedSwordAI: Starting with enhanced error handling...")
    
    -- Initialize memory tracking
    pcall(function()
        persistentData.PerformanceStats.MemoryUsage = GetMemoryUsage()
        persistentData.GarbageCollector.LastCollectionTime = tick()
    end)
    
    -- Start the AI with maximum error protection
    local success, errorMsg = pcall(InitializeAI)
    
    if not success then
        forcePrint("LinkedSwordAI: Critical error - " .. tostring(errorMsg))
        
        -- Attempt cleanup on error
        pcall(RunGarbageCollection, true)
        
        -- Try to recover after a delay
        forcePrint("LinkedSwordAI: Attempting recovery in 5 seconds...")
        wait(5)
        pcall(SafeStartup)
    end
    
    return success
end

-- Start the AI safely
SafeStartup()
[file content end]
