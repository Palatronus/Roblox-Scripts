--[[ 
    Linked Sword AI Combat Script (v8 - Full)
    Includes:
    - Segmented node-based pathfinding
    - Expanded safe pathfinding (16 alternatives)
    - Continuous movement & smooth path transitions
    - ForceField proximity detection + fleeing/evasion
    - Offensive-defensive sword combat with strafing and deceptive lunges
    - Transparent platform avoidance + intelligent jumping
    - Faster, robust respawn/equip logic
    - Max slope angle detection for small jumps
    Based on prototype file: AI Bot Working ver.txt
--]]

-- Force immediate printing
local function forcePrint(...)
    local message = table.concat({...}, " ")
    print(message)
    print("") -- attempt flush
end

local function debugPrint(category, ...)
    local args = {...}
    local message = "[" .. category .. "] " .. table.concat(args, " ")
    local timestamp = os.date("%H:%M:%S")
    forcePrint(timestamp .. " - " .. message)
end

forcePrint("LinkedSwordAI: v8 starting...")
debugPrint("INIT", "Enhanced debug logging enabled")

-- Persistent global across respawns
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {},
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        MovementHistory = {},
        FailedPaths = {},
        LastEquipAttempt = 0,
        EquipmentReady = false,
        KnownVoidAreas = {},
        PathCache = {},
        LastPathfindingTime = 0,
        PerformanceStats = {
            PathfindingTime = 0,
            CombatTime = 0,
            MovementTime = 0,
            LastOptimizationTime = 0
        },
        AlternativePaths = {},
        CurrentNavigationTarget = nil,
        NavigationTransitionStart = 0,
        LastGCTime = 0,
        GCInterval = 30,
        LastInRangeTime = 0,
        NodeGraph = nil,
        Connections = {}
    }
end

local persistentData = _G.LinkedSwordAIPersistentData

-- Configuration
local CONFIG = {
    DETECTION_RADIUS = 200,
    ATTACK_RANGE = 15,
    IMMEDIATE_ATTACK_RADIUS = 8,
    ATTACK_COOLDOWN = 0.6,
    LUNGE_DELAY = 0.08,
    LUNGE_SPEED_MULTIPLIER = 1.6,
    STUCK_CHECK_DISTANCE = 1.5,
    STUCK_CHECK_TIME = 1.0,
    MAX_TARGET_DISTANCE = 250,
    MIN_HEALTH_CHECK = 0,
    RETARGET_CHECK_TIME = 1.5,
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -100,
    FORCEFIELD_FLEE_DISTANCE = 18,
    SWORD_CHECK_INTERVAL = 6,
    RESPAWN_EQUIP_DELAY = 0.3,
    MOVEMENT_MEMORY_TIME = 0.7,
    SAFE_GAP_DISTANCE = 10,
    PATH_SMOOTHING_FACTOR = 0.7,
    MOVEMENT_RETRY_DELAY = 1.0,
    NARROW_PASSAGE_WIDTH = 3.5,
    PATHFINDING_STEPS = 10,
    COMBAT_BEHAVIOR_CHANGE_TIME = 4.0,
    COMBAT_DEFENSIVE_CHANCE = 0.2,
    COMBAT_OFFENSIVE_CHANCE = 0.5,
    STRAFE_DISTANCE = 4,
    BRIDGE_CHECK_DISTANCE = 25,
    PERFORMANCE_MODE = true,
    PATH_CACHE_TIME = 3.0,
    ALTERNATIVE_PATH_COUNT = 16,
    MIN_ATTACK_DISTANCE = 3,
    OUT_OF_RANGE_AGGRESSION_TIME = 3.0,
    TRANSPARENT_THRESHOLD = 0.8,
    IMMEDIATE_RESPAWN_FIGHT = true,
    JUMP_SAFE_MARGIN = 2,
    MAX_KNOWN_VOID_AREAS = 80,
    PATH_CACHE_CAPACITY = 40,
    GC_MIN_INTERVAL = 15,
    GC_MAX_INTERVAL = 60,
    MAX_SLOPE_ANGLE = 35,
    SWING_RANGE = 12
}

-- Safe wrappers
local function SafeHumanoidMoveTo(humanoid, pos)
    if humanoid and humanoid.MoveTo then
        local ok, err = pcall(function()
            humanoid:MoveTo(pos)
        end)
        if not ok then
            debugPrint("ERROR", "SafeHumanoidMoveTo failed", tostring(err))
        end
    end
end

local function SafeHumanoidChangeState(humanoid, state)
    if humanoid and humanoid.ChangeState then
        local ok, err = pcall(function()
            humanoid:ChangeState(state)
        end)
        if not ok then
            debugPrint("ERROR", "SafeHumanoidChangeState failed", tostring(err))
        end
    end
end

-- Forward declarations
local MoveTo, TryJumpTo, ExecuteAttack
local DetectObstacleAhead, ComputeNodePathBetweenPositions, FollowNodePath
local BuildFixedNodeGraph, FindNearestNamedNode
local IsVoidArea, IsSafeGap, IsNarrowPassage, FindBridgePath, isPartUnsafe
local GetAreaNameForPosition, IsSafePath

-- GUI
local function CreateStatusGUI()
    local gui = {}
    local Players = game:GetService("Players")
    local screenGui
    local success, result = pcall(function()
        local g = Instance.new("ScreenGui")
        g.Name = "LinkedSwordAI_Status"
        g.ResetOnSpawn = false
        g.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
        return g
    end)
    if success then
        screenGui = result
    else
        return nil
    end
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 220, 0, 140)
    frame.Position = UDim2.new(0.78, 0, 0.08, 0)
    frame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    frame.BackgroundTransparency = 0.4
    frame.BorderSizePixel = 1
    frame.Parent = screenGui

    local function makeLabel(y, color, text)
        local lbl = Instance.new("TextLabel")
        lbl.Size = UDim2.new(1, -10, 0, 22)
        lbl.Position = UDim2.new(0, 5, 0, y)
        lbl.BackgroundTransparency = 1
        lbl.TextColor3 = color
        lbl.Text = text
        lbl.Font = Enum.Font.SourceSans
        lbl.TextSize = 13
        lbl.TextXAlignment = Enum.TextXAlignment.Left
        lbl.Parent = frame
        return lbl
    end

    local status = makeLabel(6, Color3.new(1,1,1), "Status: Initializing...")
    local target = makeLabel(30, Color3.new(1,0.6,0.6), "Target: None")
    local distance = makeLabel(54, Color3.new(0.6,1,0.6), "Distance: N/A")
    local debug = makeLabel(78, Color3.new(1,1,0.4), "Debug: Starting...")
    local perf = makeLabel(102, Color3.new(0.6,0.8,1), "Perf: Idle")

    function gui.UpdateStatus(text) if status then status.Text = "Status: " .. text end end
    function gui.UpdateTarget(text) if target then target.Text = "Target: " .. text end end
    function gui.UpdateDistance(d) if distance then distance.Text = "Distance: " .. (d and string.format("%.1f", d) or "N/A") end end
    function gui.UpdateDebug(t) if debug then debug.Text = "Debug: " .. t end end
    function gui.UpdatePerf(t) if perf then perf.Text = "Perf: " .. t end end

    return gui
end

-- ========================================
-- Core environment helpers
-- ========================================
local Workspace = game:GetService("Workspace")

local function isPartUnsafe(part)
    if not part then return true end
    if part.Transparency and part.Transparency >= CONFIG.TRANSPARENT_THRESHOLD then return true end
    if part.CanCollide == false then return true end
    return false
end

IsVoidArea = function(position)
    for i, vp in ipairs(persistentData.KnownVoidAreas) do
        if (position - vp).Magnitude < 5 then
            return true
        end
    end

    if position.Y < CONFIG.VOID_Y_THRESHOLD then
        if #persistentData.KnownVoidAreas < CONFIG.MAX_KNOWN_VOID_AREAS then
            table.insert(persistentData.KnownVoidAreas, position)
        end
        return true
    end

    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {}
    params.FilterType = Enum.RaycastFilterType.Blacklist
    local rayRes = Workspace:Raycast(position, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0), params)

    if not rayRes or not rayRes.Instance then
        table.insert(persistentData.KnownVoidAreas, position)
        return true
    else
        if isPartUnsafe(rayRes.Instance) then
            table.insert(persistentData.KnownVoidAreas, position)
            return true
        end
    end
    return false
end

IsSafeGap = function(startPos, endPos)
    local distance = (endPos - startPos).Magnitude
    if distance < 3 then
        return not IsVoidArea(endPos)
    end
    local direction = (endPos - startPos).Unit
    local steps = math.ceil(distance / 2)
    for i = 1, steps do
        local checkPoint = startPos + direction * (i * 2)
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {}
        params.FilterType = Enum.RaycastFilterType.Blacklist
        local rayRes = Workspace:Raycast(checkPoint, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0), params)
        if not rayRes or not rayRes.Instance or isPartUnsafe(rayRes.Instance) then
            return false
        end
    end
    return true
end

IsNarrowPassage = function(position, direction)
    local cross = direction:Cross(Vector3.new(0,1,0)).Unit
    local leftRay = Ray.new(position, cross * CONFIG.NARROW_PASSAGE_WIDTH)
    local rightRay = Ray.new(position, -cross * CONFIG.NARROW_PASSAGE_WIDTH)
    local leftHit = Workspace:FindPartOnRay(leftRay)
    local rightHit = Workspace:FindPartOnRay(rightRay)
    return leftHit and rightHit
end

FindBridgePath = function(startPos, endPos)
    local direction = (endPos - startPos).Unit
    local distance = (endPos - startPos).Magnitude
    for dist = 5, math.min(CONFIG.BRIDGE_CHECK_DISTANCE, distance), 5 do
        local checkPoint = startPos + direction * dist
        for y = 0, -20, -2 do
            local bridgeCheckPoint = checkPoint + Vector3.new(0, y, 0)
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local rayRes = Workspace:Raycast(bridgeCheckPoint, Vector3.new(0, -5, 0), params)
            if rayRes and rayRes.Instance and not isPartUnsafe(rayRes.Instance) then
                local bridgePath = rayRes.Position + Vector3.new(0, 3, 0)
                if IsSafeGap(startPos, bridgePath) then
                    return bridgePath
                end
            end
        end
    end
    return nil
end

-- ========================================
-- Safe path check (moved earlier)
-- ========================================
IsSafePath = function(targetPosition)
    if CONFIG.PERFORMANCE_MODE then
        local currentTime = tick()
        local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
        local cached = persistentData.PathCache[hashKey]
        if cached and currentTime - cached.time < CONFIG.PATH_CACHE_TIME then
            return cached.safe, cached.bridgePath, cached.alternativePath
        end
    end

    local startPos = persistentData.Character and persistentData.Character:FindFirstChild("HumanoidRootPart") and persistentData.Character.HumanoidRootPart.Position or Vector3.new(0,0,0)
    local direction = (targetPosition - startPos)
    if direction.Magnitude == 0 then
        return not IsVoidArea(targetPosition)
    end
    direction = direction.Unit
    local distance = (targetPosition - startPos).Magnitude

    local increment = math.min(5, math.max(2, distance / 5))
    for i = increment, distance, increment do
        local checkPos = startPos + direction * i
        if IsVoidArea(checkPos) then
            local bridgePath = FindBridgePath(startPos, targetPosition)
            if bridgePath then
                return true, bridgePath
            end
            return false
        end
    end

    if IsVoidArea(targetPosition) then
        return false
    end
    return true
end

-- ========================================
-- Movement and jumping
-- ========================================
MoveTo = function(targetPosition, bridgePath, alternativePath)
    local char = persistentData.Character
    if not char then return end
    local humanoid = char:FindFirstChild("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return end

    if bridgePath then
        targetPosition = bridgePath
    elseif alternativePath then
        targetPosition = alternativePath
    end

    local dirVec = (targetPosition - hrp.Position)
    if dirVec.Magnitude == 0 then
        dirVec = Vector3.new(0.01, 0, 0.01)
    end
    dirVec = dirVec.Unit

    local moveDistance = math.min(5, (targetPosition - hrp.Position).Magnitude)
    local smoothedTarget = hrp.Position + dirVec * moveDistance

    if IsSafeGap(hrp.Position, smoothedTarget) then
        SafeHumanoidMoveTo(humanoid, smoothedTarget)
    else
        -- Try alternatives
        for i = 0, 15 do
            local angle = (i / 16) * 2 * math.pi
            local dir = Vector3.new(math.cos(angle), 0, math.sin(angle)).Unit
            local altPos = hrp.Position + dir * math.max(4, moveDistance)
            if IsSafePath(altPos) then
                SafeHumanoidMoveTo(humanoid, altPos)
                return true
            end
        end
    end
end

TryJumpTo = function(targetPos)
    local char = persistentData.Character
    if not char then return end
    local humanoid = char:FindFirstChild("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return end

    local distance = (targetPos - hrp.Position).Magnitude
    if distance < 3 then
        SafeHumanoidChangeState(humanoid, Enum.HumanoidStateType.Jumping)
        SafeHumanoidMoveTo(humanoid, targetPos)
        return true
    end
    if IsSafePath(targetPos) then
        SafeHumanoidChangeState(humanoid, Enum.HumanoidStateType.Jumping)
        SafeHumanoidMoveTo(humanoid, targetPos)
        return true
    end
    return false
end

-- ========================================
-- Combat
-- ========================================
ExecuteAttack = function(targetHRP)
    if not persistentData.LinkedSword then return end
    if persistentData.AttackSequenceActive then return end
    persistentData.AttackSequenceActive = true
    persistentData.LastAttackTime = tick()

    local char = persistentData.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if hrp and targetHRP then
        hrp.CFrame = CFrame.new(hrp.Position, Vector3.new(targetHRP.Position.X, hrp.Position.Y, targetHRP.Position.Z))
    end

    spawn(function()
        pcall(function() persistentData.LinkedSword:Activate() end)
        task.wait(CONFIG.LUNGE_DELAY)
        pcall(function() persistentData.LinkedSword:Activate() end)
        task.wait(CONFIG.LUNGE_DELAY * 1.2)
        persistentData.AttackSequenceActive = false
    end)
end

-- ========================================
-- Node Graph
-- ========================================
local fixedNodes = {
    Center = Vector3.new(0, 249.67, 0),
    BottomArea = Vector3.new(0, 234.09, -38),
    HillBottom1 = Vector3.new(31, 249.3, -122),
    HillStair1 = Vector3.new(5, 263.7, -106),
    HillStair2 = Vector3.new(5, 275.7, -116),
    HillStair3 = Vector3.new(20, 285.27, -140),
    Hill = Vector3.new(-6, 286.26, -131),
    UpperBridge1 = Vector3.new(-42, 288.87, -131),
    UpperBridge2 = Vector3.new(-55, 288.88, -20),
    RegenArea = Vector3.new(-116, 258.9, -9),
    ArmorArea = Vector3.new(0, 249.3, 330),
    Base = Vector3.new(0, 249.3, 197),
}

BuildFixedNodeGraph = function()
    persistentData.NodeGraph = { nodes = {}, edges = {} }
    for name, pos in pairs(fixedNodes) do
        persistentData.NodeGraph.nodes[name] = pos
        persistentData.NodeGraph.edges[name] = {}
    end
    local function connect(a, b)
        table.insert(persistentData.NodeGraph.edges[a], b)
        table.insert(persistentData.NodeGraph.edges[b], a)
    end
    connect("Center","BottomArea")
    connect("BottomArea","HillBottom1")
    connect("HillBottom1","HillStair1")
    connect("HillStair1","HillStair2")
    connect("HillStair2","HillStair3")
    connect("HillStair3","Hill")
    connect("Hill","UpperBridge1")
    connect("UpperBridge1","UpperBridge2")
    connect("Center","RegenArea")
    connect("Base","ArmorArea")
end

FindNearestNamedNode = function(position)
    local nearest, bestDist
    for name, pos in pairs(fixedNodes) do
        local dist = (pos - position).Magnitude
        if not bestDist or dist < bestDist then
            nearest, bestDist = name, dist
        end
    end
    return nearest
end

ComputeNodePathBetweenPositions = function(startPos, endPos)
    local startNode = FindNearestNamedNode(startPos)
    local endNode = FindNearestNamedNode(endPos)
    if not startNode or not endNode then return nil end
    if not persistentData.NodeGraph then BuildFixedNodeGraph() end

    local queue = {{startNode}}
    local visited = {[startNode]=true}
    while #queue > 0 do
        local path = table.remove(queue,1)
        local last = path[#path]
        if last == endNode then return path end
        for _, neighbor in ipairs(persistentData.NodeGraph.edges[last]) do
            if not visited[neighbor] then
                visited[neighbor]=true
                local newPath = {unpack(path)}
                table.insert(newPath, neighbor)
                table.insert(queue, newPath)
            end
        end
    end
    return nil
end

FollowNodePath = function(humanoid, hrp, path)
    for _, nodeName in ipairs(path) do
        local pos = persistentData.NodeGraph.nodes[nodeName]
        if pos then
            SafeHumanoidMoveTo(humanoid, pos)
            task.wait(0.3)
        end
    end
end

-- ========================================
-- AI Initialization
-- ========================================
local function InitializeAI(char)
    persistentData.Character = char
    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
    end

    local humanoid = char:WaitForChild("Humanoid")
    local hrp = char:WaitForChild("HumanoidRootPart")

    -- Sword finder
    local function FindLinkedSword()
        if persistentData.SwordToolName then
            local stored = char:FindFirstChild(persistentData.SwordToolName)
            if stored and stored:IsA("Tool") then return stored end
            stored = game.Players.LocalPlayer.Backpack:FindFirstChild(persistentData.SwordToolName)
            if stored and stored:IsA("Tool") then return stored end
        end
        for _, tool in pairs(char:GetChildren()) do
            if tool:IsA("Tool") and tostring(tool.Name):lower():find("sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        for _, tool in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tostring(tool.Name):lower():find("sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        return nil
    end

    -- Periodic sword checks
    spawn(function()
        while true do
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= char then
                persistentData.LinkedSword = FindLinkedSword()
                if persistentData.LinkedSword and persistentData.LinkedSword.Parent ~= char then
                    persistentData.LinkedSword.Parent = char
                end
            end
            task.wait(CONFIG.SWORD_CHECK_INTERVAL)
        end
    end)

    -- Build node graph once
    if not persistentData.NodeGraph then
        BuildFixedNodeGraph()
    end

    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("AI Ready") end
end

-- ========================================
-- Main update loop hookup
-- ========================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local function OnCharacterAdded(char)
    task.wait(0.5)
    InitializeAI(char)
end

-- Connect character added
if persistentData.Connections.CharacterAddedConn then
    persistentData.Connections.CharacterAddedConn:Disconnect()
end
persistentData.Connections.CharacterAddedConn = LocalPlayer.CharacterAdded:Connect(OnCharacterAdded)

if LocalPlayer.Character then
    task.defer(function()
        OnCharacterAdded(LocalPlayer.Character)
    end)
end

-- Heartbeat update
if persistentData.Connections.UpdateConn then
    persistentData.Connections.UpdateConn:Disconnect()
end

persistentData.Connections.UpdateConn = RunService.Heartbeat:Connect(function(dt)
    local ok, err = pcall(function()
        local char = persistentData.Character
        if not char then return end
        local humanoid = char:FindFirstChild("Humanoid")
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not humanoid or not hrp then return end

        -- Acquire target
        local target
        local closestDist = CONFIG.MAX_TARGET_DISTANCE
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (hrp.Position - plr.Character.HumanoidRootPart.Position).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    target = plr
                end
            end
        end

        if not target or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then
            return
        end

        local targetHRP = target.Character.HumanoidRootPart
        local distance = (hrp.Position - targetHRP.Position).Magnitude

        -- Combat
        if distance < CONFIG.IMMEDIATE_ATTACK_RADIUS then
            ExecuteAttack(targetHRP)
        elseif distance < CONFIG.SWING_RANGE then
            ExecuteAttack(targetHRP)
        end

        -- Navigation
        if not IsSafePath(targetHRP.Position) then
            if not persistentData.NodeGraph or not persistentData.NodeGraph.nodes then
                BuildFixedNodeGraph()
            end
            local path = ComputeNodePathBetweenPositions(hrp.Position, targetHRP.Position)
            if path and #path > 0 then
                FollowNodePath(humanoid, hrp, path)
            end
        else
            MoveTo(targetHRP.Position)
        end

    end)
    if not ok then
        forcePrint("LinkedSwordAI: Update error - " .. tostring(err))
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Error: " .. tostring(err)) end
    end
end)

forcePrint("LinkedSwordAI: v8 running.")
