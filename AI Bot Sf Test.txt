--[[ 
    Linked Sword AI Combat Script (Enhanced Version)
    Implemented improvements per user request:
    - Adaptive periodic garbage collection
    - Expanded safe pathfinding (16 alternatives)
    - Continuous movement & smooth path transitions
    - ForceField proximity detection + fleeing/evasion
    - Offensive-defensive sword combat with strafing and deceptive lunges
    - Transparent platform avoidance + intelligent jumping
    - Faster, robust respawn/equip logic
    Based on original prototype file: AI Bot Sf Prototypes :contentReference[oaicite:1]{index=1}
--]]

-- Force immediate printing
local function forcePrint(...)
    local message = table.concat({...}, " ")
    print(message)
    print("") -- attempt flush
end

local function debugPrint(category, ...)
    local args = {...}
    local message = "[" .. category .. "] " .. table.concat(args, " ")
    local timestamp = os.date("%H:%M:%S")
    forcePrint(timestamp .. " - " .. message)
end

forcePrint("LinkedSwordAI: Enhanced script starting...")
debugPrint("INIT", "Enhanced debug logging enabled")

-- Persistent global across respawns
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {},
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        MovementHistory = {},
        FailedPaths = {},
        LastEquipAttempt = 0,
        EquipmentReady = false,
        KnownVoidAreas = {},
        PathCache = {},
        LastPathfindingTime = 0,
        PerformanceStats = {
            PathfindingTime = 0,
            CombatTime = 0,
            MovementTime = 0,
            LastOptimizationTime = 0
        },
        AlternativePaths = {},
        -- New navigation state:
        CurrentNavigationTarget = nil,
        NavigationTransitionStart = 0,
        LastGCTime = 0,
        GCInterval = 30, -- default, adaptive below
        LastInRangeTime = 0
    }
end

local persistentData = _G.LinkedSwordAIPersistentData

-- Configuration (tweak these values for tuning)
local CONFIG = {
    DETECTION_RADIUS = 200,
    ATTACK_RANGE = 15,
    IMMEDIATE_ATTACK_RADIUS = 8,      -- immediate attack trigger
    ATTACK_COOLDOWN = 0.6,
    LUNGE_DELAY = 0.08,               -- faster lunges
    LUNGE_SPEED_MULTIPLIER = 1.6,     -- relative lunge speed
    STUCK_CHECK_DISTANCE = 1.5,
    STUCK_CHECK_TIME = 1.0,
    MAX_TARGET_DISTANCE = 250,
    MIN_HEALTH_CHECK = 0,
    RETARGET_CHECK_TIME = 1.5,
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -100,
    FORCEFIELD_FLEE_DISTANCE = 18,    -- repaired flee distance (in studs)
    SWORD_CHECK_INTERVAL = 6,
    RESPAWN_EQUIP_DELAY = 0.3,        -- faster respawn equip attempts
    MOVEMENT_MEMORY_TIME = 0.7,
    SAFE_GAP_DISTANCE = 10,
    PATH_SMOOTHING_FACTOR = 0.7,
    MOVEMENT_RETRY_DELAY = 1.0,
    NARROW_PASSAGE_WIDTH = 3.5,
    PATHFINDING_STEPS = 10,
    COMBAT_BEHAVIOR_CHANGE_TIME = 4.0,
    COMBAT_DEFENSIVE_CHANCE = 0.2,
    COMBAT_OFFENSIVE_CHANCE = 0.5,
    STRAFE_DISTANCE = 4,
    BRIDGE_CHECK_DISTANCE = 25,
    PERFORMANCE_MODE = true,
    PATH_CACHE_TIME = 3.0,
    ALTERNATIVE_PATH_COUNT = 16,      -- expanded to 16 paths
    MIN_ATTACK_DISTANCE = 3,
    OUT_OF_RANGE_AGGRESSION_TIME = 3.0, -- if target out of attack range for this many seconds -> aggressive
    TRANSPARENT_THRESHOLD = 0.8,      -- treat parts with transparency >= this as vanishing
    IMMEDIATE_RESPAWN_FIGHT = true,   -- start fighting immediately on spawn
    JUMP_SAFE_MARGIN = 2,             -- extra margin for jumps
    MAX_KNOWN_VOID_AREAS = 80,
    PATH_CACHE_CAPACITY = 40,
    GC_MIN_INTERVAL = 15,
    GC_MAX_INTERVAL = 60
}

-- Create status GUI (same logic, minor label improvements)
local function CreateStatusGUI()
    local gui = {}
    local Players = game:GetService("Players")
    local parentOptions = {
        game:GetService("CoreGui"),
        Players.LocalPlayer and Players.LocalPlayer:FindFirstChild("PlayerGui"),
        Players.LocalPlayer and Players.LocalPlayer.Character
    }
    local screenGui
    for _, parent in ipairs(parentOptions) do
        if parent then
            local success, result = pcall(function()
                local g = Instance.new("ScreenGui")
                g.Name = "LinkedSwordAI_Status"
                g.ResetOnSpawn = false
                g.Parent = parent
                return g
            end)
            if success then
                screenGui = result
                break
            end
        end
    end
    if not screenGui then
        forcePrint("LinkedSwordAI: Failed to create GUI")
        return nil
    end
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 220, 0, 140)
    frame.Position = UDim2.new(0.78, 0, 0.08, 0)
    frame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    frame.BackgroundTransparency = 0.4
    frame.BorderSizePixel = 1
    frame.Parent = screenGui

    local function makeLabel(y, color, text)
        local lbl = Instance.new("TextLabel")
        lbl.Size = UDim2.new(1, -10, 0, 22)
        lbl.Position = UDim2.new(0, 5, 0, y)
        lbl.BackgroundTransparency = 1
        lbl.TextColor3 = color
        lbl.Text = text
        lbl.Font = Enum.Font.SourceSans
        lbl.TextSize = 13
        lbl.TextXAlignment = Enum.TextXAlignment.Left
        lbl.Parent = frame
        return lbl
    end

    local status = makeLabel(6, Color3.new(1,1,1), "Status: Initializing...")
    local target = makeLabel(30, Color3.new(1,0.6,0.6), "Target: None")
    local distance = makeLabel(54, Color3.new(0.6,1,0.6), "Distance: N/A")
    local debug = makeLabel(78, Color3.new(1,1,0.4), "Debug: Starting...")
    local perf = makeLabel(102, Color3.new(0.6,0.8,1), "Perf: Idle")

    function gui.UpdateStatus(text) if status then status.Text = "Status: " .. text end end
    function gui.UpdateTarget(text) if target then target.Text = "Target: " .. text end end
    function gui.UpdateDistance(d) if distance then distance.Text = "Distance: " .. (d and string.format("%.1f", d) or "N/A") end end
    function gui.UpdateDebug(t) if debug then debug.Text = "Debug: " .. t end end
    function gui.UpdatePerf(t) if perf then perf.Text = "Perf: " .. t end end

    return gui
end

-- Initialize AI (protected)
local function InitializeAI()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")

    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        forcePrint("LinkedSwordAI: LocalPlayer not found")
        return false
    end

    forcePrint("LinkedSwordAI: LocalPlayer found - " .. LocalPlayer.Name)

    local Character = LocalPlayer.Character
    if not Character then
        forcePrint("LinkedSwordAI: Character not found")
        return false
    end

    local Humanoid = Character:FindFirstChild("Humanoid")
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not Humanoid or not HumanoidRootPart then
        forcePrint("LinkedSwordAI: Humanoid or HumanoidRootPart not found")
        return false
    end

    forcePrint("LinkedSwordAI: Character components found")

    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
    end

    -- Robust sword finder (tries backpack and character)
    local function FindLinkedSword()
        if persistentData.SwordToolName then
            local stored = Character:FindFirstChild(persistentData.SwordToolName)
            if stored and stored:IsA("Tool") then return stored end
            stored = LocalPlayer.Backpack:FindFirstChild(persistentData.SwordToolName)
            if stored and stored:IsA("Tool") then return stored end
        end

        for _, tool in pairs(Character:GetChildren()) do
            if tool:IsA("Tool") and tostring(tool.Name):lower():find("sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end

        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tostring(tool.Name):lower():find("sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end

        return nil
    end

    -- Periodic check for sword
    local function CheckForSword()
        local currentTime = tick()
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword = FindLinkedSword()
            end
            persistentData.LastSwordCheckTime = currentTime
        end
    end

    -- Players in range
    local function FindPlayersInRange()
        local players = {}
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and
               player.Character:FindFirstChild("HumanoidRootPart") and
               player.Character:FindFirstChild("Humanoid") and
               player.Character.Humanoid.Health > CONFIG.MIN_HEALTH_CHECK then

                local hrp = player.Character.HumanoidRootPart
                local distance = (hrp.Position - HumanoidRootPart.Position).Magnitude

                if distance <= CONFIG.DETECTION_RADIUS then
                    local hasFF = false
                    for _, c in pairs(player.Character:GetChildren()) do
                        if c:IsA("ForceField") then
                            hasFF = true
                            persistentData.PlayersWithForceField[player.Name] = player
                            break
                        end
                    end
                    if not hasFF and persistentData.PlayersWithForceField[player.Name] then
                        persistentData.PlayersWithForceField[player.Name] = nil
                    end

                    table.insert(players, {player = player, distance = distance, hasForceField = hasFF})
                end
            end
        end

        table.sort(players, function(a,b) return a.distance < b.distance end)
        return players
    end

    -- Treat transparent or non-collidable parts as void (vanishing platforms)
    local function isPartUnsafe(part)
        if not part then return true end
        if part.Transparency and part.Transparency >= CONFIG.TRANSPARENT_THRESHOLD then return true end
        if part.CanCollide == false then return true end
        return false
    end

    -- Check if a position is in a void (improved)
    local function IsVoidArea(position)
        -- Known void areas quick check
        for i, vp in ipairs(persistentData.KnownVoidAreas) do
            if (position - vp).Magnitude < 5 then
                return true
            end
        end

        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            if #persistentData.KnownVoidAreas < CONFIG.MAX_KNOWN_VOID_AREAS then
                table.insert(persistentData.KnownVoidAreas, position)
            else
                table.remove(persistentData.KnownVoidAreas, 1)
                table.insert(persistentData.KnownVoidAreas, position)
            end
            return true
        end

        -- Raycast downwards and inspect hit
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {Character}
        params.FilterType = Enum.RaycastFilterType.Blacklist
        local rayRes = Workspace:Raycast(position, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0), params)

        if not rayRes or not rayRes.Instance then
            if #persistentData.KnownVoidAreas < CONFIG.MAX_KNOWN_VOID_AREAS then
                table.insert(persistentData.KnownVoidAreas, position)
            else
                table.remove(persistentData.KnownVoidAreas, 1)
                table.insert(persistentData.KnownVoidAreas, position)
            end
            return true
        else
            local hitPart = rayRes.Instance
            if isPartUnsafe(hitPart) then
                -- treat this as void-like because platform vanishes or non-collidable
                if #persistentData.KnownVoidAreas < CONFIG.MAX_KNOWN_VOID_AREAS then
                    table.insert(persistentData.KnownVoidAreas, position)
                else
                    table.remove(persistentData.KnownVoidAreas, 1)
                    table.insert(persistentData.KnownVoidAreas, position)
                end
                return true
            end
        end

        return false
    end

    -- IsSafeGap (unchanged fundamentals but uses IsVoidArea improvements)
    local function IsSafeGap(startPos, endPos)
        local distance = (endPos - startPos).Magnitude
        if distance < 3 then
            return not IsVoidArea(endPos)
        end
        if distance < CONFIG.SAFE_GAP_DISTANCE then
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {Character}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local rayRes = Workspace:Raycast(endPos, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0), params)
            return rayRes ~= nil and rayRes.Instance ~= nil and not isPartUnsafe(rayRes.Instance)
        end
        local direction = (endPos - startPos).Unit
        local checkCount = math.ceil(distance / 2)
        for i = 1, checkCount do
            local checkPoint = startPos + direction * (i * 2)
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {Character}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local rayRes = Workspace:Raycast(checkPoint, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0), params)
            if not rayRes or not rayRes.Instance or isPartUnsafe(rayRes.Instance) then
                return false
            end
        end
        return true
    end

    local function IsNarrowPassage(position, direction)
        local cross = direction:Cross(Vector3.new(0,1,0)).Unit
        local leftRay = Ray.new(position, cross * CONFIG.NARROW_PASSAGE_WIDTH)
        local rightRay = Ray.new(position, -cross * CONFIG.NARROW_PASSAGE_WIDTH)
        local leftHit, _ = Workspace:FindPartOnRay(leftRay, Character)
        local rightHit, _ = Workspace:FindPartOnRay(rightRay, Character)
        return leftHit and rightHit
    end

    local function FindBridgePath(startPos, endPos)
        local direction = (endPos - startPos).Unit
        local distance = (endPos - startPos).Magnitude
        for dist = 5, math.min(CONFIG.BRIDGE_CHECK_DISTANCE, distance), 5 do
            local checkPoint = startPos + direction * dist
            for y = 0, -20, -2 do
                local bridgeCheckPoint = checkPoint + Vector3.new(0, y, 0)
                local params = RaycastParams.new()
                params.FilterDescendantsInstances = {Character}
                params.FilterType = Enum.RaycastFilterType.Blacklist
                local rayRes = Workspace:Raycast(bridgeCheckPoint, Vector3.new(0, -5, 0), params)
                if rayRes and rayRes.Instance and not isPartUnsafe(rayRes.Instance) then
                    local bridgePath = rayRes.Position + Vector3.new(0, 3, 0)
                    if IsSafeGap(startPos, bridgePath) then
                        return bridgePath
                    end
                end
            end
        end
        return nil
    end

    -- IsSafePath (expanded alternatives and caching)
    local function IsSafePath(targetPosition)
        if CONFIG.PERFORMANCE_MODE then
            local currentTime = tick()
            local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
            local cached = persistentData.PathCache[hashKey]
            if cached and currentTime - cached.time < CONFIG.PATH_CACHE_TIME then
                debugPrint("PATH", "Using cached result")
                return cached.safe, cached.bridgePath, cached.alternativePath
            end
        end

        local startTime = tick()

        local failedCount = #persistentData.FailedPaths
        if failedCount > 0 then
            for i = failedCount, math.max(1, failedCount - 4), -1 do
                local fp = persistentData.FailedPaths[i]
                if fp and (targetPosition - fp.position).Magnitude < 5 and tick() - fp.time < 10 then
                    return false
                end
            end
        end

        local startPos = (Character and Character:FindFirstChild("HumanoidRootPart") and Character.HumanoidRootPart.Position) or persistentData.LastStuckPosition or Vector3.new(0,0,0)
        local direction = (targetPosition - startPos)
        if direction.Magnitude == 0 then
            return not IsVoidArea(targetPosition)
        end
        direction = direction.Unit
        local distance = (targetPosition - startPos).Magnitude

        local isNarrow = IsNarrowPassage(startPos, direction)
        if isNarrow then
            local narrowIncrement = math.min(2, distance / 8)
            for i = narrowIncrement, distance, narrowIncrement do
                local checkPos = startPos + direction * i
                if IsVoidArea(checkPos) then
                    if #persistentData.FailedPaths >= 12 then table.remove(persistentData.FailedPaths, 1) end
                    table.insert(persistentData.FailedPaths, {position = targetPosition, time = tick()})
                    if CONFIG.PERFORMANCE_MODE then
                        local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
                        persistentData.PathCache[hashKey] = {safe = false, time = tick(), bridgePath = nil}
                    end
                    return false
                end
            end
        else
            local increment = math.min(5, math.max(2, distance / 5))
            for i = increment, distance, increment do
                local checkPos = startPos + direction * i
                if IsVoidArea(checkPos) then
                    local bridgePath = FindBridgePath(startPos, targetPosition)
                    if bridgePath then
                        if CONFIG.PERFORMANCE_MODE then
                            local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
                            persistentData.PathCache[hashKey] = {safe = true, time = tick(), bridgePath = bridgePath}
                            persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                        end
                        return true, bridgePath
                    end

                    -- Try expanded alternative directions (16 angles)
                    local halfDistance = distance * 0.5
                    local piDivided = (2 * math.pi) / CONFIG.ALTERNATIVE_PATH_COUNT
                    local upVector = Vector3.new(0,1,0)
                    for altIndex = 0, CONFIG.ALTERNATIVE_PATH_COUNT - 1 do
                        local angle = altIndex * piDivided
                        local rotation = CFrame.fromAxisAngle(upVector, angle)
                        local altDir = (rotation * CFrame.new(direction)).lookVector
                        local altTargetPos = startPos + altDir * halfDistance
                        local altSafe = true
                        for j = increment, math.max(2, halfDistance), increment do
                            local altCheckPos = startPos + altDir * j
                            if IsVoidArea(altCheckPos) then
                                altSafe = false
                                break
                            end
                        end
                        if altSafe then
                            persistentData.AlternativePaths[targetPosition] = altTargetPos
                            if CONFIG.PERFORMANCE_MODE then
                                local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
                                persistentData.PathCache[hashKey] = {safe = false, time = tick(), bridgePath = nil, alternativePath = altTargetPos}
                                persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                            end
                            return false, nil, altTargetPos
                        end
                    end

                    if #persistentData.FailedPaths >= 12 then table.remove(persistentData.FailedPaths, 1) end
                    table.insert(persistentData.FailedPaths, {position = targetPosition, time = tick()})
                    if CONFIG.PERFORMANCE_MODE then
                        local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
                        persistentData.PathCache[hashKey] = {safe = false, time = tick(), bridgePath = nil}
                        persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                    end
                    return false
                end
            end
        end

        if IsVoidArea(targetPosition) then
            if #persistentData.FailedPaths >= 12 then table.remove(persistentData.FailedPaths, 1) end
            table.insert(persistentData.FailedPaths, {position = targetPosition, time = tick()})
            if CONFIG.PERFORMANCE_MODE then
                local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
                persistentData.PathCache[hashKey] = {safe = false, time = tick(), bridgePath = nil}
                persistentData.PerformanceStats.PathfindingTime = tick() - startTime
            end
            return false
        end

        if CONFIG.PERFORMANCE_MODE then
            local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
            persistentData.PathCache[hashKey] = {safe = true, time = tick(), bridgePath = nil}
            persistentData.PerformanceStats.PathfindingTime = tick() - startTime
        end

        return true
    end

    -- Stuck detection
    local function CheckIfStuck()
        if not persistentData.LastStuckPosition then
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = tick()
            return false
        end

        local currentTime = tick()
        if currentTime - persistentData.LastStuckTime > CONFIG.STUCK_CHECK_TIME then
            local dist = (HumanoidRootPart.Position - persistentData.LastStuckPosition).Magnitude
            if dist < CONFIG.STUCK_CHECK_DISTANCE then
                persistentData.IsStuck = true
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Stuck detected") end
                return true
            end
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = currentTime
        end
        return false
    end

    -- Unstucking: expanded directions (16)
    local function HandleStuckOnPlayer()
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Unstucking") end
        local directions = {}
        for i = 0, 15 do
            local angle = (i / 16) * 2 * math.pi
            table.insert(directions, Vector3.new(math.cos(angle), 0, math.sin(angle)).Unit)
        end
        for _, dir in ipairs(directions) do
            local targetPosition = HumanoidRootPart.Position + dir * 6
            if IsSafePath(targetPosition) then
                Humanoid:MoveTo(targetPosition)
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Moving to unstuck") end
                return true
            end
        end
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("No safe unstuck path") end
        return false
    end

    -- Flee from ForceField players (repaired & functional)
    local function HandleFleeFromForceField()
        if CONFIG.FORCEFIELD_FLEE_DISTANCE <= 0 then return false end
        local nearestFF, nearestDist = nil, math.huge
        for _, ffPlayer in pairs(persistentData.PlayersWithForceField) do
            if ffPlayer and ffPlayer.Character and ffPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (ffPlayer.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                if dist < nearestDist then
                    nearestFF = ffPlayer
                    nearestDist = dist
                end
            end
        end
        if nearestFF and nearestDist < CONFIG.FORCEFIELD_FLEE_DISTANCE then
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateStatus("Fleeing FF: " .. nearestFF.Name)
                persistentData.StatusGUI.UpdateDebug("FF distance: " .. string.format("%.1f", nearestDist))
            end
            -- Primary flee direction: away from FF
            local fleeDir = (HumanoidRootPart.Position - nearestFF.Character.HumanoidRootPart.Position)
            if fleeDir.Magnitude == 0 then
                fleeDir = Vector3.new(math.random()-0.5, 0, math.random()-0.5).Unit
            else
                fleeDir = fleeDir.Unit
            end
            -- Preferred flee target at configured distance
            local fleeTarget = HumanoidRootPart.Position + fleeDir * CONFIG.FORCEFIELD_FLEE_DISTANCE

            -- If not safe, try perpendicular evasive maneuvers
            if IsSafePath(fleeTarget) then
                MoveTo(fleeTarget)
                return true
            else
                local altDirs = {
                    (fleeDir + Vector3.new(0.4, 0, 0.2)).Unit,
                    (fleeDir + Vector3.new(-0.4, 0, 0.2)).Unit,
                    (fleeDir + Vector3.new(0.2, 0, -0.4)).Unit,
                    (fleeDir + Vector3.new(-0.2, 0, -0.4)).Unit
                }
                for _, ad in ipairs(altDirs) do
                    local altT = HumanoidRootPart.Position + ad * CONFIG.FORCEFIELD_FLEE_DISTANCE
                    if IsSafePath(altT) then
                        MoveTo(altT)
                        return true
                    end
                end
            end
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("FF: No safe flee path") end
        end
        return false
    end

    -- Movement with smoothing and continuous operation (improved)
    local function MoveTo(targetPosition, bridgePath, alternativePath)
        -- Always try to maintain continuous movement; if path unsafe pick alternative and keep moving
        local startTime = tick()

        if bridgePath then
            targetPosition = bridgePath
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Using bridge path") end
        end
        if alternativePath then
            targetPosition = alternativePath
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Using alternative path") end
        end

        -- Compute direction (guard against zero)
        local dirVec = (targetPosition - HumanoidRootPart.Position)
        if dirVec.Magnitude == 0 then
            -- tiny random nudge to keep movement alive
            dirVec = Vector3.new(0.01, 0, 0.01)
        end
        dirVec = dirVec.Unit

        local currentTime = tick()
        local smoothedDirection = dirVec
        if persistentData.LastMovementDirection and currentTime - persistentData.LastMovementTime < CONFIG.MOVEMENT_MEMORY_TIME then
            smoothedDirection = (persistentData.LastMovementDirection * CONFIG.PATH_SMOOTHING_FACTOR +
                                 dirVec * (1 - CONFIG.PATH_SMOOTHING_FACTOR)).Unit
        end

        local moveDistance = math.min(5, (targetPosition - HumanoidRootPart.Position).Magnitude)
        local smoothedTarget = HumanoidRootPart.Position + smoothedDirection * moveDistance

        -- Narrow passage handling (less smoothing)
        if IsNarrowPassage(HumanoidRootPart.Position, smoothedDirection) then
            smoothedDirection = dirVec
            smoothedTarget = HumanoidRootPart.Position + smoothedDirection * math.min(2, (targetPosition - HumanoidRootPart.Position).Magnitude)
        end

        -- If safe gap, move; otherwise attempt to find nearest safe alternative (do not stop)
        if IsSafeGap(HumanoidRootPart.Position, smoothedTarget) then
            persistentData.LastMovementDirection = smoothedDirection
            persistentData.LastMovementTime = currentTime
            persistentData.CurrentNavigationTarget = targetPosition
            persistentData.NavigationTransitionStart = currentTime
            Humanoid:MoveTo(smoothedTarget)
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Moving to smoothed target") end
            if CONFIG.PERFORMANCE_MODE then persistentData.PerformanceStats.MovementTime = tick() - startTime end
            return true
        else
            -- find alternative targets around (16 directions), choose the safest nearest one, keep moving
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Unsafe path - finding alternatives") end
            local bestAlt = nil
            local bestScore = math.huge
            for i = 0, 15 do
                local angle = (i / 16) * 2 * math.pi
                local dir = Vector3.new(math.cos(angle), 0, math.sin(angle)).Unit
                local altPos = HumanoidRootPart.Position + dir * math.max(4, moveDistance)
                local safe, altBridge = IsSafePath(altPos)
                if safe then
                    local score = (altPos - targetPosition).Magnitude
                    if score < bestScore then
                        bestScore = score
                        bestAlt = altPos
                    end
                end
            end
            -- if we found an alternative, move there; otherwise try small jump forward if plausible
            if bestAlt then
                persistentData.LastMovementDirection = (bestAlt - HumanoidRootPart.Position).Unit
                persistentData.LastMovementTime = currentTime
                Humanoid:MoveTo(bestAlt)
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Moving to alternative") end
                return true
            else
                -- try a careful jump forward toward target if gap small and jump likely safe
                local jumpVec = HumanoidRootPart.Position + dirVec * (moveDistance + CONFIG.JUMP_SAFE_MARGIN)
                if IsSafePath(jumpVec) then
                    -- attempt jump: trigger Humanoid jump and move to landing
                    pcall(function()
                        Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    end)
                    Humanoid:MoveTo(jumpVec)
                    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Attempting jump") end
                    return true
                end
            end
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("No safe alt found - waiting minimal time") end
            return false
        end
    end

    -- Intelligent jump helper for traversing void areas (used sparingly)
    local function TryJumpTo(targetPos)
        -- compute required velocity/timing heuristics (simple)
        local distance = (targetPos - HumanoidRootPart.Position).Magnitude
        if distance < 3 then
            -- close - simple jump
            pcall(function() Humanoid:ChangeState(Enum.HumanoidStateType.Jumping) end)
            Humanoid:MoveTo(targetPos)
            return true
        end
        -- For longer jumps, ensure landing spot safe
        if IsSafePath(targetPos) then
            pcall(function() Humanoid:ChangeState(Enum.HumanoidStateType.Jumping) end)
            Humanoid:MoveTo(targetPos)
            return true
        end
        return false
    end

    -- Attack execution with enhanced tactics
    local function ExecuteAttack()
        if not persistentData.LinkedSword then
            debugPrint("COMBAT", "Cannot attack - no sword")
            return
        end
        if persistentData.AttackSequenceActive then return end
        persistentData.AttackSequenceActive = true
        persistentData.LastAttackTime = tick()

        -- pick behavior if needed
        if not persistentData.CurrentCombatBehavior or tick() - (persistentData.LastBehaviorChangeTime or 0) > CONFIG.COMBAT_BEHAVIOR_CHANGE_TIME then
            local r = math.random()
            if r < CONFIG.COMBAT_DEFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "defensive"
            elseif r < CONFIG.COMBAT_DEFENSIVE_CHANCE + CONFIG.COMBAT_OFFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "offensive"
            else
                persistentData.CurrentCombatBehavior = "offensive-defensive"
            end
            persistentData.LastBehaviorChangeTime = tick()
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Combat: " .. persistentData.CurrentCombatBehavior) end
        end

        -- Face target
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character and persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
            HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(targetPos.X, HumanoidRootPart.Position.Y, targetPos.Z))
        end

        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Attacking: " .. (persistentData.CurrentCombatBehavior or "unknown")) end

        -- Attack sequence (spawned so movement loop not blocked)
        spawn(function()
            local behavior = persistentData.CurrentCombatBehavior or "offensive-defensive"
            local targetHRP = persistentData.CurrentTarget and persistentData.CurrentTarget.Character and persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
            local distance = targetHRP and (targetHRP.Position - HumanoidRootPart.Position).Magnitude or math.huge

            -- Determine if we should perform deceptive partial lunge (bait)
            local doDeceptive = (distance > CONFIG.MIN_ATTACK_DISTANCE and distance <= CONFIG.ATTACK_RANGE + 4) and math.random() < 0.5

            if behavior == "defensive" then
                -- Defensive: keep range, bait, then strike
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.3)
                if doDeceptive then
                    -- small forward lunge to bait
                    if targetHRP then
                        local dir = (targetHRP.Position - HumanoidRootPart.Position).Unit
                        local baitPos = HumanoidRootPart.Position + dir * 1.6
                        MoveTo(baitPos)
                        wait(0.12)
                        pcall(function() persistentData.LinkedSword:Activate() end)
                        -- back off
                        local backPos = HumanoidRootPart.Position - dir * 2
                        MoveTo(backPos)
                    end
                else
                    pcall(function() persistentData.LinkedSword:Activate() end)
                end
                wait(CONFIG.LUNGE_DELAY * 1.6)
                pcall(function() persistentData.LinkedSword:Activate() end)

            elseif behavior == "offensive" then
                -- Aggressive approach, faster lunges and follow-up
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.5)
                if targetHRP then
                    local dir = (targetHRP.Position - HumanoidRootPart.Position).Unit
                    -- Quick lunge forward with increased speed: move closer
                    local forwardPos = HumanoidRootPart.Position + dir * (2.5 * CONFIG.LUNGE_SPEED_MULTIPLIER)
                    MoveTo(forwardPos)
                end
                wait(CONFIG.LUNGE_DELAY * 0.6)
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.5)
                pcall(function() persistentData.LinkedSword:Activate() end)

            else
                -- offensive-defensive with strafing
                pcall(function() persistentData.LinkedSword:Activate() end)

                if targetHRP then
                    local dir = (targetHRP.Position - HumanoidRootPart.Position).Unit
                    local strafeDir = dir:Cross(Vector3.new(0,1,0)).Unit
                    if math.random() > 0.5 then strafeDir = -strafeDir end
                    local strafePos = HumanoidRootPart.Position + strafeDir * CONFIG.STRAFE_DISTANCE
                    MoveTo(strafePos)
                    wait(0.06)
                end

                wait(CONFIG.LUNGE_DELAY)
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY)
                if targetHRP then
                    local dir = (targetHRP.Position - HumanoidRootPart.Position).Unit
                    local approachPos = HumanoidRootPart.Position + dir * 1.8
                    MoveTo(approachPos)
                end
                pcall(function() persistentData.LinkedSword:Activate() end)
            end

            -- Increased chance of aggressive follow-up when target was out of range for some time
            local timeSinceInRange = tick() - (persistentData.LastInRangeTime or 0)
            if timeSinceInRange > CONFIG.OUT_OF_RANGE_AGGRESSION_TIME then
                -- immediate aggressive burst
                local bursts = math.random(1,2)
                for i = 1, bursts do
                    wait(0.06)
                    pcall(function() persistentData.LinkedSword:Activate() end)
                end
            end

            -- short cooldown
            wait(0.18)
            persistentData.AttackSequenceActive = false
        end)
    end

    -- Update loop logic
    local function Update()
        -- adaptive periodic garbage collection
        local currentTime = tick()
        local perf = persistentData.PerformanceStats

        -- use recorded pathfinding time (default to 0 if nil)
        local recentPath = perf.PathfindingTime or 0

        -- adapt GC interval based on recent pathfinding time
        local targetVal = 30 - math.min(20, recentPath)
        local newInterval = math.clamp(targetVal, CONFIG.GC_MIN_INTERVAL, CONFIG.GC_MAX_INTERVAL)
        persistentData.GCInterval = newInterval

        if currentTime - (persistentData.LastGCTime or 0) > persistentData.GCInterval then
            -- attempt collector (Roblox/Luau: collectgarbage available in many environments)
            pcall(function()
                if collectgarbage then
                    collectgarbage("collect")
                end
            end)
            persistentData.LastGCTime = currentTime
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdatePerf("GC at " .. string.format("%.1f", currentTime)) end
            debugPrint("PERF", "Garbage collected; next in", persistentData.GCInterval)
        end

        -- Periodic maintenance / cleanup of caches
        if CONFIG.PERFORMANCE_MODE and currentTime - (perf.LastOptimizationTime or 0) > 25 then
            -- Trim path cache oldest entries if too large
            local count = 0
            local oldestKey, oldestTime = nil, math.huge
            for k, v in pairs(persistentData.PathCache) do
                count = count + 1
                if v.time < oldestTime then
                    oldestTime = v.time
                    oldestKey = k
                end
            end
            if count > CONFIG.PATH_CACHE_CAPACITY and oldestKey then
                persistentData.PathCache[oldestKey] = nil
            end
            -- Cleanup failed paths older than 25s
            for i = #persistentData.FailedPaths, 1, -1 do
                if currentTime - persistentData.FailedPaths[i].time > 25 then
                    table.remove(persistentData.FailedPaths, i)
                end
            end
            perf.LastOptimizationTime = currentTime
            debugPrint("PERF", "Optimization complete")
        end

        -- Sword checks
        CheckForSword()

        -- Target selection & retargeting
        local needNewTarget = not persistentData.CurrentTarget or not persistentData.CurrentTarget.Character or not persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        local shouldCheck = currentTime - persistentData.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME

        if needNewTarget or shouldCheck then
            local playersInRange = FindPlayersInRange()
            if #playersInRange > 0 then
                local newTarget = playersInRange[1].player
                if newTarget ~= persistentData.CurrentTarget then
                    persistentData.CurrentTarget = newTarget
                    if persistentData.StatusGUI then
                        persistentData.StatusGUI.UpdateTarget(newTarget.Name)
                        persistentData.StatusGUI.UpdateStatus("Targeting " .. newTarget.Name)
                    end
                    debugPrint("TARGET", "New target - " .. newTarget.Name)
                end
            else
                if persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateStatus("No targets in range")
                    persistentData.StatusGUI.UpdateTarget("None")
                end
                persistentData.CurrentTarget = nil
            end
            persistentData.LastRetargetTime = currentTime
        end

        -- If we have a target: movement + combat decisions
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character and persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            local targetHRP = persistentData.CurrentTarget.Character.HumanoidRootPart
            local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDistance(distance) end

            -- Track last time we were in attack range
            if distance <= CONFIG.ATTACK_RANGE then
                persistentData.LastInRangeTime = currentTime
            end

            -- Stuck handling
            if CheckIfStuck() then
                HandleStuckOnPlayer()
                return
            else
                persistentData.IsStuck = false
            end

            -- ForceField flee priority (if necessary)
            if HandleFleeFromForceField() then
                -- When fleeing, skip other actions this frame
                return
            end

            -- Path safety check
            local isSafe, bridgePath, alternativePath = IsSafePath(targetHRP.Position)
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PerformanceStats.PathfindingTime = tick() - currentTime
            end

            -- Continuous movement: prefer safe path; if not safe use alternative / bridge / find other routes without stopping
            if isSafe then
                MoveTo(targetHRP.Position, bridgePath, alternativePath)
                -- always face target horizontally
                HumanoidRootPart.CFrame = CFrame.lookAt(HumanoidRootPart.Position, Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z))

                -- Attack triggers
                if distance <= CONFIG.IMMEDIATE_ATTACK_RADIUS and persistentData.LinkedSword and currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    -- Immediate close-range attack
                    ExecuteAttack()
                elseif distance <= CONFIG.ATTACK_RANGE and persistentData.LinkedSword and currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    -- normal attack window
                    ExecuteAttack()
                elseif distance <= CONFIG.MIN_ATTACK_DISTANCE and persistentData.LinkedSword and currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    -- forced offensive at extremely close range
                    persistentData.CurrentCombatBehavior = "offensive"
                    ExecuteAttack()
                else
                    -- If target remained out of range for a while -> switch to aggressive behavior and attempt to lunge/close
                    if tick() - (persistentData.LastInRangeTime or 0) > CONFIG.OUT_OF_RANGE_AGGRESSION_TIME then
                        persistentData.CurrentCombatBehavior = "offensive"
                        -- attempt a longer lunge/closing maneuver
                        if not persistentData.AttackSequenceActive then
                            ExecuteAttack()
                        end
                    end
                end

            elseif alternativePath then
                -- use computed alternative path
                debugPrint("PATH", "Using precomputed alternative")
                MoveTo(alternativePath)
                HumanoidRootPart.CFrame = CFrame.new(
    HumanoidRootPart.Position,
    Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
)
                if distance <= CONFIG.ATTACK_RANGE and persistentData.LinkedSword and currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    ExecuteAttack()
                end
            else
                -- No direct safe path: attempt bridge; otherwise search many alternative dirs and keep moving
                if persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateStatus("Finding safe path")
                    persistentData.StatusGUI.UpdateDebug("No safe direct path")
                end

                local bridge = FindBridgePath(HumanoidRootPart.Position, targetHRP.Position)
                if bridge then
                    MoveTo(bridge)
                    return
                end

                -- try radial alternatives (16)
                local found = false
                for i = 0, 15 do
                    local angle = (i / 16) * 2 * math.pi
                    local dir = Vector3.new(math.cos(angle), 0, math.sin(angle)).Unit
                    local altTarget = HumanoidRootPart.Position + dir * 10
                    local altSafe, altBridge = IsSafePath(altTarget)
                    if altSafe then
                        MoveTo(altTarget, altBridge)
                        found = true
                        break
                    end
                end

                if not found and persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateDebug("No safe alternatives found this update")
                end
            end

            -- Defensive stance when stationary and opponent proximity
            if HumanoidRootPart.Velocity.Magnitude < 1.5 and distance <= (CONFIG.ATTACK_RANGE + 6) then
                -- face opponent and take guarded posture (back off slightly)
                if distance < CONFIG.ATTACK_RANGE then
                    local dir = (HumanoidRootPart.Position - targetHRP.Position).Unit
                    local backPos = HumanoidRootPart.Position + dir * 1.6
                    MoveTo(backPos)
                    persistentData.CurrentCombatBehavior = "defensive"
                end
            end

        else
            -- Idle fallback behavior: small patrol to avoid standing still
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Idle") end
            -- small wander: attempt a short safe move if present
            if not persistentData.CurrentNavigationTarget or (tick() - (persistentData.NavigationTransitionStart or 0)) > 3 then
                local randDir = Vector3.new(math.random()-0.5, 0, math.random()-0.5).Unit
                local wanderTarget = HumanoidRootPart.Position + randDir * 4
                if IsSafePath(wanderTarget) then
                    MoveTo(wanderTarget)
                end
            end
        end
    end

    -- Faster, robust sword equip that retries (works around tool disappearing issues)
    spawn(function()
        wait(CONFIG.RESPAWN_EQUIP_DELAY)
        local attempts = 0
        while attempts < 8 do
            attempts = attempts + 1
            persistentData.LinkedSword = FindLinkedSword()
            if persistentData.LinkedSword then
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Sword found: " .. persistentData.LinkedSword.Name) end
                -- attempt equip by parenting to character
                if persistentData.LinkedSword.Parent ~= Character then
                    persistentData.LinkedSword.Parent = Character
                    wait(0.25)
                    if persistentData.LinkedSword.Parent == Character then
                        persistentData.EquipmentReady = true
                        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Sword equipped") end
                        break
                    else
                        -- retry quickly
                        wait(0.25)
                    end
                else
                    persistentData.EquipmentReady = true
                    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Sword already equipped") end
                    break
                end
            else
                -- no sword found; keep trying until attempts exhausted
                wait(0.25)
            end
        end
        if not persistentData.EquipmentReady then
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Failed to equip sword") end
        end
    end)

    -- initialize pointers
    persistentData.LinkedSword = FindLinkedSword()
    persistentData.LastSwordCheckTime = tick()

    -- Heartbeat update connection
    local updateConn
    updateConn = game:GetService("RunService").Heartbeat:Connect(function()
        local ok, err = pcall(Update)
        if not ok then
            forcePrint("LinkedSwordAI: Update error - " .. tostring(err))
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Error: " .. tostring(err)) end
        end
    end)

    -- Character respawn handling: re-initialize cleanly on CharacterAdded
    local Players = game:GetService("Players")
    Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        forcePrint("LinkedSwordAI: Character respawned - reinitializing")
        -- minimal wait for character to be usable
        wait(0.6)
        -- refresh references in-place instead of full re-run to avoid duplicates
        Character = newCharacter
        Humanoid = Character:WaitForChild("Humanoid")
        HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
        persistentData.LinkedSword = FindLinkedSword()
        persistentData.EquipmentReady = false
        -- try immediate equip attempts
        spawn(function()
            local tries = 0
            while tries < 8 do
                tries = tries + 1
                persistentData.LinkedSword = FindLinkedSword()
                if persistentData.LinkedSword and persistentData.LinkedSword.Parent ~= Character then
                    persistentData.LinkedSword.Parent = Character
                    wait(0.25)
                end
                if persistentData.LinkedSword and persistentData.LinkedSword.Parent == Character then
                    persistentData.EquipmentReady = true
                    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Equipped on respawn") end
                    break
                end
                wait(0.25)
            end
        end)
    end)

    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("AI Running") end
    forcePrint("LinkedSwordAI: Enhanced script initialized successfully")
    return true
end

-- Launch
local success, err = pcall(InitializeAI)
if not success then
    forcePrint("LinkedSwordAI: Initialization failed - " .. tostring(err))
end
