[file name]: AI Bot Sf Prototypes_WithGC.txt
[file content begin]
--[[
    Linked Sword AI Combat Script (Fixed Version)
    
    This script implements autonomous sword fighting AI for the Linked Sword tool in Roblox.
    Optimized specifically for external executor usage with improved error handling and debugging.
]]

-- Force print to output console immediately
local function forcePrint(...)
    local message = table.concat({...}, " ")
    print(message)
    print("") -- Force flush
end

-- Debug function with timestamps
local function debugPrint(category, ...)
    local args = {...}
    local message = "[" .. category .. "] " .. table.concat(args, " ")
    local timestamp = os.date("%H:%M:%S")
    forcePrint(timestamp .. " - " .. message)
end

forcePrint("LinkedSwordAI: Script starting...")
debugPrint("INIT", "Debug logging enabled")

-- Garbage Collection Configuration
local GC_CONFIG = {
    ENABLED = true,
    COLLECTION_INTERVAL = 30,          -- Run GC every 30 seconds
    AGGRESSIVE_THRESHOLD = 100,        -- MB threshold for aggressive GC
    MAX_CACHE_ENTRIES = 20,            -- Limit cache sizes
    MAX_HISTORY_ENTRIES = 30,          -- Limit movement history
    CLEANUP_BATCH_SIZE = 50,           -- Objects to clean per batch
}

-- Global persistent data to maintain state across respawns
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {},
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        MovementHistory = {},
        FailedPaths = {},
        LastEquipAttempt = 0,
        EquipmentReady = false,
        KnownVoidAreas = {},
        PathCache = {},           -- NEW: Cache for pathfinding results
        LastPathfindingTime = 0,  -- NEW: Track last pathfinding operation
        PerformanceStats = {      -- NEW: Track performance metrics
            PathfindingTime = 0,
            CombatTime = 0,
            MovementTime = 0,
            LastOptimizationTime = 0,
            MemoryUsage = 0,           -- GC: Track memory usage
            GarbageCollections = 0,    -- GC: Track GC runs
            ObjectsCleaned = 0,        -- GC: Track cleanup effectiveness
            LastGCTime = 0,            -- GC: Track last GC run
        },
        AlternativePaths = {},     -- NEW: Store alternative paths
        
        -- GC: Garbage Collection System
        GarbageCollector = {
            LastCollectionTime = 0,
            MemorySnapshot = 0,
            ObjectsToClean = {},
            CleanupQueue = {},
            IsRunning = false
        }
    }
end

local persistentData = _G.LinkedSwordAIPersistentData

-- Configuration
local CONFIG = {
    DETECTION_RADIUS = 200,        -- INCREASED: Stud radius for detecting players (was 100)
    ATTACK_RANGE = 15,             -- Start attacking when within this range
    ATTACK_COOLDOWN = 0.7,         -- IMPROVED: Slightly faster attacks (was 0.8)
    LUNGE_DELAY = 0.1,             -- Delay between attacks for lunge combo
    STUCK_CHECK_DISTANCE = 1.5,    -- Distance to check if stuck on player
    STUCK_CHECK_TIME = 1.0,        -- Time to wait before considering stuck
    MAX_TARGET_DISTANCE = 250,     -- INCREASED: Maximum effective reach in studs (was 150)
    MIN_HEALTH_CHECK = 0,          -- Minimum health to consider player valid
    RETARGET_CHECK_TIME = 1.5,     -- OPTIMIZED: Less frequent retargeting (was 1.0)
    VOID_CHECK_DISTANCE = 50,      -- Distance to check for void areas
    VOID_Y_THRESHOLD = -100,       -- Y position threshold for void detection
    FORCEFIELD_FLEE_DISTANCE = 0,  -- Set to 0 to prevent fleeing from ForceField players
    SWORD_CHECK_INTERVAL = 7,      -- OPTIMIZED: Less frequent sword checks (was 5)
    RESPAWN_EQUIP_DELAY = 1.5,     -- Delay before equipping sword after respawn
    MOVEMENT_MEMORY_TIME = 0.7,    -- IMPROVED: Remember movement direction longer (was 0.5)
    SAFE_GAP_DISTANCE = 10,        -- IMPROVED: Increased safe gap distance (was 8)
    PATH_SMOOTHING_FACTOR = 0.7,   -- IMPROVED: Smoother movement (was 0.6)
    MOVEMENT_RETRY_DELAY = 1.0,    -- OPTIMIZED: Longer delay before retrying (was 0.5)
    NARROW_PASSAGE_WIDTH = 3.5,    -- IMPROVED: Slightly wider passage detection (was 3)
    PATHFINDING_STEPS = 10,        -- IMPROVED: More pathfinding steps (was 8)
    COMBAT_BEHAVIOR_CHANGE_TIME = 4.0, -- OPTIMIZED: Less frequent behavior changes (was 3.0)
    COMBAT_DEFENSIVE_CHANCE = 0.25, -- IMPROVED: Less defensive behavior (was 0.33)
    COMBAT_OFFENSIVE_CHANCE = 0.45, -- IMPROVED: More offensive behavior (was 0.33)
    STRAFE_DISTANCE = 4,           -- IMPROVED: Increased strafe distance (was 3)
    BRIDGE_CHECK_DISTANCE = 25,    -- IMPROVED: Increased bridge check distance (was 20)
    PERFORMANCE_MODE = true,       -- NEW: Enable performance optimizations
    PATH_CACHE_TIME = 3.0,         -- NEW: How long to cache path results
    ALTERNATIVE_PATH_COUNT = 4,    -- NEW: Number of alternative paths to try
    MIN_ATTACK_DISTANCE = 3        -- NEW: Minimum distance to maintain aggression
}

-- GC: Memory monitoring function
local function GetMemoryUsage()
    return collectgarbage("count") / 1024 -- Convert KB to MB
end

-- GC: Efficient garbage collection system
local function RunGarbageCollection(aggressive)
    if not GC_CONFIG.ENABLED or persistentData.GarbageCollector.IsRunning then
        return
    end
    
    persistentData.GarbageCollector.IsRunning = true
    local startTime = tick()
    local stats = persistentData.PerformanceStats
    local objectsCleaned = 0
    
    debugPrint("GC", "Starting garbage collection" .. (aggressive and " (aggressive)" or ""))
    
    -- Clean up PathCache
    local currentTime = tick()
    for k, v in pairs(persistentData.PathCache) do
        if currentTime - v.time > CONFIG.PATH_CACHE_TIME then
            persistentData.PathCache[k] = nil
            objectsCleaned = objectsCleaned + 1
        end
    end
    
    -- Clean up FailedPaths (limit size)
    while #persistentData.FailedPaths > GC_CONFIG.MAX_CACHE_ENTRIES do
        table.remove(persistentData.FailedPaths, 1)
        objectsCleaned = objectsCleaned + 1
    end
    
    -- Clean up KnownVoidAreas (limit size)
    while #persistentData.KnownVoidAreas > GC_CONFIG.MAX_CACHE_ENTRIES do
        table.remove(persistentData.KnownVoidAreas, 1)
        objectsCleaned = objectsCleaned + 1
    end
    
    -- Clean up MovementHistory (limit size)
    while #persistentData.MovementHistory > GC_CONFIG.MAX_HISTORY_ENTRIES do
        table.remove(persistentData.MovementHistory, 1)
        objectsCleaned = objectsCleaned + 1
    end
    
    -- Clean up AlternativePaths (remove old entries)
    for k, v in pairs(persistentData.AlternativePaths) do
        if currentTime - (v.lastUsed or 0) > 60 then -- 60 second timeout
            persistentData.AlternativePaths[k] = nil
            objectsCleaned = objectsCleaned + 1
        end
    end
    
    -- Clean up player cache (remove players no longer in game)
    local validPlayers = {}
    for playerName, player in pairs(persistentData.PlayersWithForceField) do
        if player and player.Parent and player.Character then
            validPlayers[playerName] = player
        else
            objectsCleaned = objectsCleaned + 1
        end
    end
    persistentData.PlayersWithForceField = validPlayers
    
    -- Aggressive cleaning if memory is high
    if aggressive or stats.MemoryUsage > GC_CONFIG.AGGRESSIVE_THRESHOLD then
        debugPrint("GC", "Running aggressive cleanup - Memory: " .. string.format("%.1fMB", stats.MemoryUsage))
        
        -- Clear all caches
        persistentData.PathCache = {}
        persistentData.AlternativePaths = {}
        persistentData.FailedPaths = {}
        persistentData.KnownVoidAreas = {}
        persistentData.MovementHistory = {}
        
        objectsCleaned = objectsCleaned + 20 -- Estimate for bulk cleanup
        
        -- Force Lua garbage collection
        collectgarbage("collect")
    end
    
    -- Update statistics
    stats.GarbageCollections = stats.GarbageCollections + 1
    stats.ObjectsCleaned = stats.ObjectsCleaned + objectsCleaned
    stats.LastGCTime = tick()
    
    persistentData.GarbageCollector.LastCollectionTime = tick()
    persistentData.GarbageCollector.IsRunning = false
    
    local gcTime = tick() - startTime
    debugPrint("GC", string.format("Collection completed: %d objects in %.3fs", objectsCleaned, gcTime))
    debugPrint("GC", string.format("Memory: %.1fMB -> %.1fMB", stats.MemoryUsage, GetMemoryUsage()))
end

-- GC: Lightweight periodic cleanup
local function RunLightCleanup()
    local currentTime = tick()
    local cleaned = 0
    
    -- Quick cleanup of oldest cache entries
    if #persistentData.FailedPaths > GC_CONFIG.MAX_CACHE_ENTRIES then
        table.remove(persistentData.FailedPaths, 1)
        cleaned = cleaned + 1
    end
    
    if #persistentData.KnownVoidAreas > GC_CONFIG.MAX_CACHE_ENTRIES then
        table.remove(persistentData.KnownVoidAreas, 1)
        cleaned = cleaned + 1
    end
    
    -- Clean old movement history
    if #persistentData.MovementHistory > GC_CONFIG.MAX_HISTORY_ENTRIES then
        table.remove(persistentData.MovementHistory, 1)
        cleaned = cleaned + 1
    end
    
    if cleaned > 0 then
        debugPrint("CLEAN", "Light cleanup: " .. cleaned .. " objects")
    end
end

-- Create status GUI
local function CreateStatusGUI()
    local gui = {}
    
    -- Try different parent options for compatibility
    local parentOptions = {
        game:GetService("CoreGui"),
        game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui"),
        game:GetService("Players").LocalPlayer.Character
    }
    
    local screenGui
    for _, parent in ipairs(parentOptions) do
        if parent then
            local success, result = pcall(function()
                local newGui = Instance.new("ScreenGui")
                newGui.Name = "LinkedSwordAI_Status"
                newGui.Parent = parent
                return newGui
            end)
            
            if success then
                screenGui = result
                break
            end
        end
    end
    
    if not screenGui then
        forcePrint("LinkedSwordAI: Failed to create GUI - No valid parent found")
        return nil
    end
    
    -- Create frame
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 120)
    frame.Position = UDim2.new(0.8, 0, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.5
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    frame.Parent = screenGui
    
    -- Status text
    local status = Instance.new("TextLabel")
    status.Size = UDim2.new(1, -10, 0, 20)
    status.Position = UDim2.new(0, 5, 0, 5)
    status.BackgroundTransparency = 1
    status.TextColor3 = Color3.fromRGB(255, 255, 255)
    status.Text = "Status: Initializing..."
    status.Font = Enum.Font.SourceSans
    status.TextSize = 14
    status.TextXAlignment = Enum.TextXAlignment.Left
    status.Parent = frame
    
    -- Target text
    local target = Instance.new("TextLabel")
    target.Size = UDim2.new(1, -10, 0, 20)
    target.Position = UDim2.new(0, 5, 0, 30)
    target.BackgroundTransparency = 1
    target.TextColor3 = Color3.fromRGB(255, 150, 150)
    target.Text = "Target: None"
    target.Font = Enum.Font.SourceSans
    target.TextSize = 14
    target.TextXAlignment = Enum.TextXAlignment.Left
    target.Parent = frame
    
    -- Distance text
    local distance = Instance.new("TextLabel")
    distance.Size = UDim2.new(1, -10, 0, 20)
    distance.Position = UDim2.new(0, 5, 0, 55)
    distance.BackgroundTransparency = 1
    distance.TextColor3 = Color3.fromRGB(150, 255, 150)
    distance.Text = "Distance: N/A"
    distance.Font = Enum.Font.SourceSans
    distance.TextSize = 14
    distance.TextXAlignment = Enum.TextXAlignment.Left
    distance.Parent = frame
    
    -- Debug text
    local debug = Instance.new("TextLabel")
    debug.Size = UDim2.new(1, -10, 0, 20)
    debug.Position = UDim2.new(0, 5, 0, 80)
    debug.BackgroundTransparency = 1
    debug.TextColor3 = Color3.fromRGB(255, 255, 0)
    debug.Text = "Debug: Starting..."
    debug.Font = Enum.Font.SourceSans
    debug.TextSize = 14
    debug.TextXAlignment = Enum.TextXAlignment.Left
    debug.Parent = frame
    
    -- GUI functions
    function gui.UpdateStatus(text)
        if status then
            status.Text = "Status: " .. text
        end
    end
    
    function gui.UpdateTarget(text)
        if target then
            target.Text = "Target: " .. text
        end
    end
    
    function gui.UpdateDistance(dist)
        if distance then
            distance.Text = "Distance: " .. (dist and string.format("%.1f", dist) or "N/A")
        end
    end
    
    function gui.UpdateDebug(text)
        if debug then
            debug.Text = "Debug: " .. text
        end
    end
    
    return gui
end

-- Main execution in protected call
local function InitializeAI()
    -- Services
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    
    -- Get player and character
    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        forcePrint("LinkedSwordAI: LocalPlayer not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: LocalPlayer found - " .. LocalPlayer.Name)
    
    local Character = LocalPlayer.Character
    if not Character then
        forcePrint("LinkedSwordAI: Character not found")
        return false
    end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    
    if not Humanoid or not HumanoidRootPart then
        forcePrint("LinkedSwordAI: Humanoid or HumanoidRootPart not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: Character components found")
    
    -- Create status GUI if it doesn't exist
    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
        if not persistentData.StatusGUI then
            forcePrint("LinkedSwordAI: Failed to create status GUI")
        else
            forcePrint("LinkedSwordAI: Status GUI created")
        end
    end
    
    -- Find the Linked Sword tool
    local function FindLinkedSword()
        -- First check if we have a stored sword name and try to find that specific sword
        if persistentData.SwordToolName then
            -- Check character for the specific sword
            local storedSword = Character:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found stored sword: " .. storedSword.Name) 
                end
                forcePrint("LinkedSwordAI: Found stored sword - " .. storedSword.Name)
                return storedSword
            end
            
            -- Check backpack for the specific sword
            storedSword = LocalPlayer.Backpack:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found stored sword in backpack: " .. storedSword.Name) 
                end
                forcePrint("LinkedSwordAI: Found stored sword in backpack - " .. storedSword.Name)
                return storedSword
            end
        end
        
        -- If we couldn't find the stored sword, look for any sword
        for _, tool in pairs(Character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found sword: " .. tool.Name) 
                end
                forcePrint("LinkedSwordAI: Found sword - " .. tool.Name)
                return tool
            end
        end
        
        -- Check backpack if not found in character
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found sword in backpack: " .. tool.Name) 
                end
                forcePrint("LinkedSwordAI: Found sword in backpack - " .. tool.Name)
                return tool
            end
        end
        
        if persistentData.StatusGUI then 
            persistentData.StatusGUI.UpdateStatus("No sword found") 
        end
        forcePrint("LinkedSwordAI: No sword found")
        return nil
    end
    
    -- Check for sword periodically
    local function CheckForSword()
        local currentTime = tick()
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword = FindLinkedSword()
            end
            persistentData.LastSwordCheckTime = currentTime
        end
    end
    
    -- Find players in range
    local function FindPlayersInRange()
        local playersInRange = {}
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and 
               player.Character:FindFirstChild("HumanoidRootPart") and
               player.Character:FindFirstChild("Humanoid") and
               player.Character.Humanoid.Health > CONFIG.MIN_HEALTH_CHECK then
                
                local playerHRP = player.Character.HumanoidRootPart
                local distance = (playerHRP.Position - HumanoidRootPart.Position).Magnitude
                
                if distance <= CONFIG.DETECTION_RADIUS then
                    -- Check if player has ForceField
                    local hasForceField = false
                    for _, child in pairs(player.Character:GetChildren()) do
                        if child:IsA("ForceField") then
                            hasForceField = true
                            persistentData.PlayersWithForceField[player.Name] = player
                            break
                        end
                    end
                    
                    if not hasForceField and persistentData.PlayersWithForceField[player.Name] then
                        persistentData.PlayersWithForceField[player.Name] = nil
                    end
                    
                    table.insert(playersInRange, {
                        player = player,
                        distance = distance,
                        hasForceField = hasForceField
                    })
                end
            end
        end
        
        -- Sort by distance
        table.sort(playersInRange, function(a, b)
            return a.distance < b.distance
        end)
        
        return playersInRange
    end
    
    -- Check if a position is in a void area
    local function IsVoidArea(position)
        -- Check against known void areas first
        for i, voidPos in ipairs(persistentData.KnownVoidAreas) do
            if (position - voidPos).Magnitude < 5 then
                return true
            end
        end
        
        -- Basic Y-threshold check
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            -- Add to known void areas if not too many stored
            if #persistentData.KnownVoidAreas < 50 then
                table.insert(persistentData.KnownVoidAreas, position)
            else
                -- Replace oldest entry
                table.remove(persistentData.KnownVoidAreas, 1)
                table.insert(persistentData.KnownVoidAreas, position)
            end
            return true
        end
        
        -- Raycast to check for ground
        local ray = Ray.new(position, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
        local hit, _ = Workspace:FindPartOnRay(ray, Character)
        
        if not hit then
            -- Add to known void areas if not too many stored
            if #persistentData.KnownVoidAreas < 50 then
                table.insert(persistentData.KnownVoidAreas, position)
            else
                -- Replace oldest entry
                table.remove(persistentData.KnownVoidAreas, 1)
                table.insert(persistentData.KnownVoidAreas, position)
            end
            return true
        end
        
        return false
    end
    
    -- Check if a gap between two points is safe to traverse
    local function IsSafeGap(startPos, endPos)
        local distance = (endPos - startPos).Magnitude
        
        -- For small gaps, just check the end position
        if distance < 3 then
            return not IsVoidArea(endPos)
        end
        
        -- For medium gaps, check for ground on the other side
        if distance < CONFIG.SAFE_GAP_DISTANCE then
            local ray = Ray.new(endPos, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
            local hit, _ = Workspace:FindPartOnRay(ray, Character)
            return hit ~= nil
        end
        
        -- For larger gaps, check multiple points along the path
        local direction = (endPos - startPos).Unit
        local checkCount = math.ceil(distance / 2) -- Check every 2 studs
        
        for i = 1, checkCount do
            local checkPoint = startPos + direction * (i * 2)
            local ray = Ray.new(checkPoint, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
            local hit, _ = Workspace:FindPartOnRay(ray, Character)
            
            if not hit then
                return false
            end
        end
        
        return true
    end
    
    -- Check if a passage is narrow and requires special handling
    local function IsNarrowPassage(position, direction)
        local leftRay = Ray.new(position, direction:Cross(Vector3.new(0, 1, 0)).Unit * CONFIG.NARROW_PASSAGE_WIDTH)
        local rightRay = Ray.new(position, direction:Cross(Vector3.new(0, 1, 0)).Unit * -CONFIG.NARROW_PASSAGE_WIDTH)
        
        local leftHit, _ = Workspace:FindPartOnRay(leftRay, Character)
        local rightHit, _ = Workspace:FindPartOnRay(rightRay, Character)
        
        return leftHit and rightHit
    end
    
    -- Check if there's a bridge or platform that can be used to reach the target
    local function FindBridgePath(startPos, endPos)
        local direction = (endPos - startPos).Unit
        local distance = (endPos - startPos).Magnitude
        
        -- Check for bridges at different distances
        for dist = 5, math.min(CONFIG.BRIDGE_CHECK_DISTANCE, distance), 5 do
            local checkPoint = startPos + direction * dist
            
            -- Check below for bridge
            for y = 0, -20, -2 do
                local bridgeCheckPoint = checkPoint + Vector3.new(0, y, 0)
                local ray = Ray.new(bridgeCheckPoint, Vector3.new(0, -5, 0))
                local hit, hitPos = Workspace:FindPartOnRay(ray, Character)
                
                if hit then
                    -- Found potential bridge, check if it leads to target
                    local bridgePath = hitPos + Vector3.new(0, 3, 0) -- Position above the bridge
                    
                    -- Check if we can reach the bridge and if it's safe
                    if IsSafeGap(startPos, bridgePath) then
                        return bridgePath
                    end
                end
            end
        end
        
        return nil
    end
    
    -- Check if path to target is safe (no voids)
    local function IsSafePath(targetPosition)
        -- Performance optimization: Check cache first using hash-based lookup
        if CONFIG.PERFORMANCE_MODE then
            local currentTime = tick()
            -- Create a hash key for faster lookup (rounded to nearest unit)
            local hashKey = math.floor(targetPosition.X) .. "," .. 
                           math.floor(targetPosition.Y) .. "," .. 
                           math.floor(targetPosition.Z)
            
            local data = persistentData.PathCache[hashKey]
            if data and currentTime - data.time < CONFIG.PATH_CACHE_TIME then
                debugPrint("PATH", "Using cached path result: " .. (data.safe and "SAFE" or "UNSAFE"))
                return data.safe, data.bridgePath, data.alternativePath
            end
        end
        
        -- Start performance tracking
        local startTime = tick()
        
        -- Check if this path has failed recently using a more efficient approach
        local failedPathsCount = #persistentData.FailedPaths
        if failedPathsCount > 0 then
            -- Check most recent failed paths first (more likely to be relevant)
            for i = failedPathsCount, math.max(1, failedPathsCount - 3), -1 do
                local failedPath = persistentData.FailedPaths[i]
                if failedPath and (targetPosition - failedPath.position).Magnitude < 5 and 
                   tick() - failedPath.time < 10 then
                    return false
                end
            end
        end
        
        local startPos = HumanoidRootPart.Position
        local direction = (targetPosition - startPos).Unit
        local distance = (targetPosition - startPos).Magnitude
        
        -- Check if we're in a narrow passage
        local isNarrow = IsNarrowPassage(startPos, direction)
        
        -- If in narrow passage, use more careful pathfinding
        if isNarrow then
            -- Use smaller increments for narrow passages
            local narrowIncrement = math.min(2, distance / 8)
            
            for i = narrowIncrement, distance, narrowIncrement do
                local checkPos = startPos + direction * i
                
                -- Check for walls on both sides
                if not IsNarrowPassage(checkPos, direction) then
                    -- We've exited the narrow passage, check if it's safe
                    if IsVoidArea(checkPos) then
                        if #persistentData.FailedPaths >= 10 then
                            table.remove(persistentData.FailedPaths, 1)
                        end
                        table.insert(persistentData.FailedPaths, {
                            position = targetPosition,
                            time = tick()
                        })
                        
                        -- Cache the result with hash key
                        if CONFIG.PERFORMANCE_MODE then
                            local hashKey = math.floor(targetPosition.X) .. "," .. 
                                           math.floor(targetPosition.Y) .. "," .. 
                                           math.floor(targetPosition.Z)
                            
                            persistentData.PathCache[hashKey] = {
                                safe = false,
                                time = tick(),
                                bridgePath = nil
                            }
                            
                            -- Limit cache size more efficiently
                            persistentData.PathCacheCount = (persistentData.PathCacheCount or 0) + 1
                            if persistentData.PathCacheCount > 20 then
                                -- Clear oldest 25% of cache when limit reached
                                local cacheEntries = {}
                                for k, v in pairs(persistentData.PathCache) do
                                    table.insert(cacheEntries, {key = k, time = v.time})
                                end
                                
                                -- Sort by time (oldest first)
                                table.sort(cacheEntries, function(a, b) return a.time < b.time end)
                                
                                -- Remove oldest 25%
                                local removeCount = math.floor(persistentData.PathCacheCount * 0.25)
                                for i = 1, removeCount do
                                    if cacheEntries[i] then
                                        persistentData.PathCache[cacheEntries[i].key] = nil
                                    end
                                end
                                persistentData.PathCacheCount = persistentData.PathCacheCount - removeCount
                            end
                        end
                        
                        return false
                    end
                    
                    -- We've found a safe exit from the narrow passage
                    break
                end
            end
        else
            -- Standard path checking for open areas
            -- Adjust increment based on distance
            local increment = math.min(5, distance / 5)
            
            for i = increment, distance, increment do
                local checkPos = startPos + direction * i
                if IsVoidArea(checkPos) then
                    -- Try to find a bridge path if direct path is unsafe
                    local bridgePath = FindBridgePath(startPos, targetPosition)
                    if bridgePath then
                        -- We found a bridge path, use it instead
                        
                        -- Cache the result
                        if CONFIG.PERFORMANCE_MODE then
                            persistentData.PathCache[targetPosition] = {
                                safe = true,
                                time = tick(),
                                bridgePath = bridgePath
                            }
                            persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                        end
                        
                        return true, bridgePath
                    end
                    
                    -- Try alternative paths if direct path is unsafe (optimized)
                    -- Pre-calculate common values outside the loop
                    local halfDistance = distance * 0.5
                    local piDivided = math.pi / CONFIG.ALTERNATIVE_PATH_COUNT
                    local upVector = Vector3.new(0, 1, 0)
                    
                    for altIndex = 1, CONFIG.ALTERNATIVE_PATH_COUNT do
                        -- Try different angles (optimized calculation)
                        local angle = altIndex * piDivided
                        local altDirection = CFrame.fromAxisAngle(upVector, angle) * direction
                        local altTargetPos = startPos + altDirection * halfDistance
                        
                        -- Check if this alternative path is safe
                        local altSafe = true
                        for j = increment, distance * 0.5, increment do
                            local altCheckPos = startPos + altDirection * j
                            if IsVoidArea(altCheckPos) then
                                altSafe = false
                                break
                            end
                        end
                        
                        if altSafe then
                            -- Store this alternative path
                            persistentData.AlternativePaths[targetPosition] = altTargetPos
                            
                            -- Cache the result
                            if CONFIG.PERFORMANCE_MODE then
                                persistentData.PathCache[targetPosition] = {
                                    safe = false,
                                    time = tick(),
                                    bridgePath = nil,
                                    alternativePath = altTargetPos
                                }
                                persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                            end
                            
                            return false, nil, altTargetPos
                        end
                    end
                    
                    -- Remember this failed path
                    if #persistentData.FailedPaths >= 10 then
                        table.remove(persistentData.FailedPaths, 1)
                    end
                    table.insert(persistentData.FailedPaths, {
                        position = targetPosition,
                        time = tick()
                    })
                    
                    -- Cache the result
                    if CONFIG.PERFORMANCE_MODE then
                        persistentData.PathCache[targetPosition] = {
                            safe = false,
                            time = tick(),
                            bridgePath = nil
                        }
                        persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                    end
                    
                    return false
                end
            end
        end
        
        -- Final check at target position
        if IsVoidArea(targetPosition) then
            -- Remember this failed path
            if #persistentData.FailedPaths >= 10 then
                table.remove(persistentData.FailedPaths, 1)
            end
            table.insert(persistentData.FailedPaths, {
                position = targetPosition,
                time = tick()
            })
            
            -- Cache the result
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PathCache[targetPosition] = {
                    safe = false,
                    time = tick(),
                    bridgePath = nil
                }
                persistentData.PerformanceStats.PathfindingTime = tick() - startTime
            end
            
            return false
        end
        
        -- Cache the result
        if CONFIG.PERFORMANCE_MODE then
            persistentData.PathCache[targetPosition] = {
                safe = true,
                time = tick(),
                bridgePath = nil
            }
            persistentData.PerformanceStats.PathfindingTime = tick() - startTime
        end
        
        return true
    end
    
    -- Check if we're stuck on a player
    local function CheckIfStuck()
        if not persistentData.LastStuckPosition then
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = tick()
            return false
        end
        
        local currentTime = tick()
        local timeDiff = currentTime - persistentData.LastStuckTime
        
        if timeDiff > CONFIG.STUCK_CHECK_TIME then
            local distance = (HumanoidRootPart.Position - persistentData.LastStuckPosition).Magnitude
            
            if distance < CONFIG.STUCK_CHECK_DISTANCE then
                -- We haven't moved much in the check time
                persistentData.IsStuck = true
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Stuck detected") end
                return true
            end
            
            -- Update position and time for next check
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = currentTime
        end
        
        return false
    end
    
    -- Handle being stuck on a player
    local function HandleStuckOnPlayer()
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Unstucking from player") end
        
        -- Find a safe direction to move
        local directions = {
            Vector3.new(1, 0, 0),
            Vector3.new(-1, 0, 0),
            Vector3.new(0, 0, 1),
            Vector3.new(0, 0, -1),
            Vector3.new(1, 0, 1).Unit,
            Vector3.new(-1, 0, 1).Unit,
            Vector3.new(1, 0, -1).Unit,
            Vector3.new(-1, 0, -1).Unit
        }
        
        for _, direction in ipairs(directions) do
            local targetPosition = HumanoidRootPart.Position + direction * 5
            
            if IsSafePath(targetPosition) then
                Humanoid:MoveTo(targetPosition)
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Moving to unstuck") end
                return true
            end
        end
        
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("No safe path to unstuck") end
        return false
    end
    
    -- Handle fleeing from players with ForceField
    local function HandleFleeFromForceField()
        -- FIXED: Don't flee from ForceField players
        if CONFIG.FORCEFIELD_FLEE_DISTANCE <= 0 then
            return false
        end
        
        local nearestFFPlayer = nil
        local nearestDistance = math.huge
        
        for _, ffPlayer in pairs(persistentData.PlayersWithForceField) do
            if ffPlayer and ffPlayer.Character and ffPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (ffPlayer.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                
                if distance < nearestDistance then
                    nearestFFPlayer = ffPlayer
                    nearestDistance = distance
                end
            end
        end
        
        if nearestFFPlayer and nearestDistance < CONFIG.FORCEFIELD_FLEE_DISTANCE then
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateStatus("Fleeing from " .. nearestFFPlayer.Name .. " (ForceField)")
                persistentData.StatusGUI.UpdateDebug("ForceField detected at " .. string.format("%.1f", nearestDistance) .. " studs")
            end
            
            -- Calculate flee direction (away from ForceField player)
            local fleeDirection = (HumanoidRootPart.Position - nearestFFPlayer.Character.HumanoidRootPart.Position).Unit
            local fleeTarget = HumanoidRootPart.Position + fleeDirection * CONFIG.FORCEFIELD_FLEE_DISTANCE
            
            -- Check if flee path is safe
            if IsSafePath(fleeTarget) then
                Humanoid:MoveTo(fleeTarget)
                return true
            else
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Warning: No safe path to flee") end
                
                -- Try alternative directions
                local alternativeDirections = {
                    (fleeDirection + Vector3.new(0.3, 0, 0.3)).Unit,
                    (fleeDirection + Vector3.new(-0.3, 0, 0.3)).Unit,
                    (fleeDirection + Vector3.new(0.3, 0, -0.3)).Unit,
                    (fleeDirection + Vector3.new(-0.3, 0, -0.3)).Unit
                }
                
                for _, altDir in ipairs(alternativeDirections) do
                    local altTarget = HumanoidRootPart.Position + altDir * CONFIG.FORCEFIELD_FLEE_DISTANCE
                    if IsSafePath(altTarget) then
                        Humanoid:MoveTo(altTarget)
                        return true
                    end
                end
                
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Warning: All flee paths unsafe") end
            end
        end
        
        return false
    end
    
    -- Smooth movement function with improved bridge and narrow passage handling
    local function MoveTo(targetPosition, bridgePath, alternativePath)
        -- Performance tracking
        local startTime = tick()
        
        -- If we have a bridge path, use that instead
        if bridgePath then
            targetPosition = bridgePath
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Using bridge path")
            end
        end
        
        -- If we have an alternative path, use it instead
        if alternativePath then
            targetPosition = alternativePath
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Using alternative path")
            end
        end
        
        -- Calculate direction to target
        local currentDirection = (targetPosition - HumanoidRootPart.Position).Unit
        local currentTime = tick()
        
        -- Apply path smoothing if we have previous movement data
        local smoothedDirection = currentDirection
        if persistentData.LastMovementDirection and 
           currentTime - persistentData.LastMovementTime < CONFIG.MOVEMENT_MEMORY_TIME then
            -- Blend previous and current directions
            smoothedDirection = (persistentData.LastMovementDirection * CONFIG.PATH_SMOOTHING_FACTOR + 
                               currentDirection * (1 - CONFIG.PATH_SMOOTHING_FACTOR)).Unit
        end
        
        -- Calculate smoothed target position
        local smoothedTarget = HumanoidRootPart.Position + smoothedDirection * 
                              math.min(5, (targetPosition - HumanoidRootPart.Position).Magnitude)
        
        -- Check if we're in a narrow passage
        local isNarrow = IsNarrowPassage(HumanoidRootPart.Position, smoothedDirection)
        
        -- If in narrow passage, use more careful movement
        if isNarrow then
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Navigating narrow passage")
            end
            
            -- Use the exact direction in narrow passages (no smoothing)
            smoothedDirection = currentDirection
            smoothedTarget = HumanoidRootPart.Position + smoothedDirection * 
                           math.min(2, (targetPosition - HumanoidRootPart.Position).Magnitude)
        end
        
        -- Check if the smoothed path is safe
        if IsSafeGap(HumanoidRootPart.Position, smoothedTarget) then
            -- Update movement history
            persistentData.LastMovementDirection = smoothedDirection
            persistentData.LastMovementTime = currentTime
            
            -- Execute movement
            Humanoid:MoveTo(smoothedTarget)
            
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Moving: " .. 
                    string.format("(%.1f, %.1f, %.1f)", 
                    smoothedDirection.X, smoothedDirection.Y, smoothedDirection.Z))
            end
            
            -- Track performance
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PerformanceStats.MovementTime = tick() - startTime
            end
            
            return true
        else
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Unsafe path detected")
            end
            return false
        end
    end
    
    -- Execute attack with improved combat behaviors
    local function ExecuteAttack()
        if not persistentData.LinkedSword then
            forcePrint("LinkedSwordAI: Cannot attack - No sword equipped")
            return
        end
        
        if persistentData.AttackSequenceActive then
            return
        end
        
        persistentData.AttackSequenceActive = true
        persistentData.LastAttackTime = tick()
        
        -- Select combat behavior if needed
        if not persistentData.CurrentCombatBehavior or 
           tick() - persistentData.LastBehaviorChangeTime > CONFIG.COMBAT_BEHAVIOR_CHANGE_TIME then
            
            -- Randomly select a combat behavior
            local rand = math.random()
            if rand < CONFIG.COMBAT_DEFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "defensive"
            elseif rand < CONFIG.COMBAT_DEFENSIVE_CHANCE + CONFIG.COMBAT_OFFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "offensive"
            else
                persistentData.CurrentCombatBehavior = "offensive-defensive"
            end
            
            persistentData.LastBehaviorChangeTime = tick()
            
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateStatus("Combat: " .. persistentData.CurrentCombatBehavior)
            end
        end
        
        -- Face target more accurately before attacking
        if persistentData.CurrentTarget and 
           persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
            local lookVector = (targetPos - HumanoidRootPart.Position).Unit
            
            -- Set character to face target
            HumanoidRootPart.CFrame = CFrame.new(
                HumanoidRootPart.Position,
                Vector3.new(targetPos.X, HumanoidRootPart.Position.Y, targetPos.Z)
            )
        end
        
        if persistentData.StatusGUI then
            persistentData.StatusGUI.UpdateDebug("Executing " .. persistentData.CurrentCombatBehavior .. " attack")
        end
        
        -- Execute attack based on selected behavior
        spawn(function()
            if persistentData.CurrentCombatBehavior == "defensive" then
                -- Defensive behavior - wait for player to approach, attack from distance
                forcePrint("LinkedSwordAI: Defensive attack")
                
                -- First activation
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.2)
                
                -- Second activation
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.5)
                
                -- Third activation with slight backstep
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (HumanoidRootPart.Position - targetPos).Unit
                    local backPos = HumanoidRootPart.Position + moveDir * 2
                    
                    -- Move slightly back while attacking
                    MoveTo(backPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            elseif persistentData.CurrentCombatBehavior == "offensive" then
                -- Offensive behavior - aggressive approach and quick attacks
                forcePrint("LinkedSwordAI: Offensive attack")
                
                -- Quick first activation
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.6)
                
                -- Move toward target while attacking
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local forwardPos = HumanoidRootPart.Position + moveDir * 3
                    
                    -- Move toward target
                    MoveTo(forwardPos)
                end
                
                -- Quick second activation
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.7)
                
                -- Third activation with follow-through
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            else -- offensive-defensive
                -- Offensive-defensive behavior - strafe and attack
                forcePrint("LinkedSwordAI: Offensive-defensive attack")
                
                -- First activation
                pcall(function() persistentData.LinkedSword:Activate() end)
                
                -- Strafe to the side
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local strafeDir = moveDir:Cross(Vector3.new(0, 1, 0)).Unit
                    
                    -- Randomly choose left or right strafe
                    if math.random() > 0.5 then
                        strafeDir = -strafeDir
                    end
                    
                    local strafePos = HumanoidRootPart.Position + strafeDir * CONFIG.STRAFE_DISTANCE
                    
                    -- Strafe while attacking
                    MoveTo(strafePos)
                end
                
                wait(CONFIG.LUNGE_DELAY)
                
                -- Second activation
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY)
                
                -- Third activation with approach
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local approachPos = HumanoidRootPart.Position + moveDir * 2
                    
                    -- Approach target for final attack
                    MoveTo(approachPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
            end
            
            -- Shorter cooldown before allowing next attack sequence
            wait(0.2)
            persistentData.AttackSequenceActive = false
        end)
    end
    
    -- GC: Enhanced main update function with garbage collection
    local function Update()
        -- Update memory usage tracking
        persistentData.PerformanceStats.MemoryUsage = GetMemoryUsage()
        
        -- Run light cleanup every few updates
        RunLightCleanup()
        
        -- Run full garbage collection periodically
        local currentTime = tick()
        if currentTime - persistentData.GarbageCollector.LastCollectionTime > GC_CONFIG.COLLECTION_INTERVAL then
            local aggressive = persistentData.PerformanceStats.MemoryUsage > GC_CONFIG.AGGRESSIVE_THRESHOLD
            RunGarbageCollection(aggressive)
        end
        
        -- Performance optimization: Periodically clean up memory (original code)
        if CONFIG.PERFORMANCE_MODE and currentTime - persistentData.PerformanceStats.LastOptimizationTime > 30 then
            -- Clean up path cache
            local oldestTime = math.huge
            local oldestKey = nil
            local cacheCount = 0
            
            for k, v in pairs(persistentData.PathCache) do
                cacheCount = cacheCount + 1
                if v.time < oldestTime then
                    oldestTime = v.time
                    oldestKey = k
                end
            end
            
            -- If cache is too large, remove oldest entries
            if cacheCount > 20 then
                persistentData.PathCache[oldestKey] = nil
            end
            
            -- Clean up failed paths older than 20 seconds
            for i = #persistentData.FailedPaths, 1, -1 do
                if currentTime - persistentData.FailedPaths[i].time > 20 then
                    table.remove(persistentData.FailedPaths, i)
                end
            end
            
            persistentData.PerformanceStats.LastOptimizationTime = currentTime
            debugPrint("PERF", "Memory optimization complete")
        end
        
        -- Check for sword periodically
        CheckForSword()
        
        -- Check if we need to find a new target or check for closer targets
        local needNewTarget = not persistentData.CurrentTarget or 
                             not persistentData.CurrentTarget.Character or 
                             not persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        
        local checkForCloserTarget = currentTime - persistentData.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME
        
        if needNewTarget or checkForCloserTarget then
            local playersInRange = FindPlayersInRange()
            
            -- FIXED: Don't flee from ForceField players, but still track them
            -- We'll keep the tracking code but disable the fleeing behavior
            
            if #playersInRange > 0 then
                -- Target any player regardless of ForceField status
                local validTargets = playersInRange
                
                if #validTargets > 0 then
                    -- Select the closest target
                    local newTarget = validTargets[1].player
                    
                    -- Update target if it's different
                    if newTarget ~= persistentData.CurrentTarget then
                        persistentData.CurrentTarget = newTarget
                        if persistentData.StatusGUI then 
                            persistentData.StatusGUI.UpdateTarget(newTarget.Name)
                            persistentData.StatusGUI.UpdateStatus("Targeting " .. newTarget.Name)
                        end
                        debugPrint("TARGET", "New target - " .. newTarget.Name)
                    end
                else
                    if persistentData.StatusGUI then 
                        persistentData.StatusGUI.UpdateTarget("None")
                        persistentData.StatusGUI.UpdateStatus("No valid targets")
                    end
                    persistentData.CurrentTarget = nil
                end
            else
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("No targets in range")
                    persistentData.StatusGUI.UpdateTarget("None")
                end
                persistentData.CurrentTarget = nil
            end
            
            persistentData.LastRetargetTime = currentTime
        end
        
        -- If we have a target, execute AI behavior
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetHRP = persistentData.CurrentTarget.Character.HumanoidRootPart
            local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
            
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateDistance(distance)
            end
            
            -- Check if we're stuck on a player
            if CheckIfStuck() then
                HandleStuckOnPlayer()
                return
            else
                persistentData.IsStuck = false
            end
            
            -- Check if the path to the target is safe
            local isSafe, bridgePath, alternativePath = IsSafePath(targetHRP.Position)
            
            -- Track performance
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PerformanceStats.PathfindingTime = tick() - currentTime
            end
            
            if isSafe then
                -- Move toward target using smooth movement with bridge path if available
                MoveTo(targetHRP.Position, bridgePath)
                
                -- Face the target
                HumanoidRootPart.CFrame = CFrame.lookAt(
                    HumanoidRootPart.Position, 
                    Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
                )
                
                -- Attack if in range and cooldown is ready
                if distance <= CONFIG.ATTACK_RANGE and 
                   persistentData.LinkedSword and 
                   currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    ExecuteAttack()
                -- IMPROVED: Continue attacking even when very close to target
                elseif distance <= CONFIG.MIN_ATTACK_DISTANCE and 
                       persistentData.LinkedSword and 
                       currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    debugPrint("COMBAT", "Close range attack")
                    persistentData.CurrentCombatBehavior = "offensive"  -- Force offensive behavior at close range
                    ExecuteAttack()
                end
            elseif alternativePath then
                -- Use alternative path if direct path is unsafe
                debugPrint("PATH", "Using alternative path")
                MoveTo(alternativePath)
                
                -- Face the target
                HumanoidRootPart.CFrame = CFrame.lookAt(
                    HumanoidRootPart.Position, 
                    Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
                )
                
                -- Attack if in range and cooldown is ready
                if distance <= CONFIG.ATTACK_RANGE and 
                   persistentData.LinkedSword and 
                   currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    ExecuteAttack()
                end
            else
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Finding safe path")
                    persistentData.StatusGUI.UpdateDebug("Checking bridge paths")
                end
                
                -- First try to find a bridge path
                local bridgePath = FindBridgePath(HumanoidRootPart.Position, targetHRP.Position)
                if bridgePath then
                    if persistentData.StatusGUI then 
                        persistentData.StatusGUI.UpdateDebug("Using bridge path")
                    end
                    MoveTo(bridgePath)
                    return
                end
                
                -- Try to find an alternative path
                local alternativeDirections = {
                    Vector3.new(1, 0, 0),
                    Vector3.new(-1, 0, 0),
                    Vector3.new(0, 0, 1),
                    Vector3.new(0, 0, -1),
                    Vector3.new(1, 0, 1).Unit,
                    Vector3.new(-1, 0, 1).Unit,
                    Vector3.new(1, 0, -1).Unit,
                    Vector3.new(-1, 0, -1).Unit
                }
                
                local foundSafePath = false
                for _, dir in ipairs(alternativeDirections) do
                    local alternativeTarget = HumanoidRootPart.Position + dir * 10
                    local altSafe, altBridgePath = IsSafePath(alternativeTarget)
                    
                    if altSafe then
                        if persistentData.StatusGUI then 
                            persistentData.StatusGUI.UpdateDebug("Found alternative path")
                        end
                        MoveTo(alternativeTarget, altBridgePath)
                        foundSafePath = true
                        break
                    end
                end
                
                if not foundSafePath and persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateDebug("No safe path found")
                end
            end
        else
            -- No target, just idle
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateStatus("Idle")
            end
        end
    end
    
    -- Handle proper sword equipping on respawn
    spawn(function()
        -- Wait for character to fully load
        wait(CONFIG.RESPAWN_EQUIP_DELAY)
        
        persistentData.LinkedSword = FindLinkedSword()
        if persistentData.LinkedSword then
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateStatus("Sword found: " .. persistentData.LinkedSword.Name)
            end
            
            -- Equip the sword
            if persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword.Parent = Character
                wait(0.5)
                
                -- Verify equipment was successful
                if persistentData.LinkedSword.Parent == Character then
                    persistentData.EquipmentReady = true
                    if persistentData.StatusGUI then
                        persistentData.StatusGUI.UpdateStatus("Sword equipped successfully")
                    end
                else
                    -- Retry equipping
                    wait(0.5)
                    if persistentData.LinkedSword then
                        persistentData.LinkedSword.Parent = Character
                        wait(0.5)
                        persistentData.EquipmentReady = true
                        if persistentData.StatusGUI then
                            persistentData.StatusGUI.UpdateStatus("Sword equipped on retry")
                        end
                    end
                end
            else
                persistentData.EquipmentReady = true
                if persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateStatus("Sword already equipped")
                end
            end
        else
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateStatus("No sword found to equip")
            end
        end
    end)
    
    -- Initialize
    persistentData.LinkedSword = FindLinkedSword()
    persistentData.LastSwordCheckTime = tick()
    
    -- Connect update function
    local updateConnection
    updateConnection = RunService.Heartbeat:Connect(function()
        local success, error = pcall(Update)
        if not success then
            forcePrint("LinkedSwordAI: Error in update - " .. tostring(error))
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Error: " .. tostring(error)) end
        end
    end)
    
    -- Handle character respawn
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        forcePrint("LinkedSwordAI: Character respawned, reinitializing...")
        wait(1) -- Wait for character to fully load
        InitializeAI()
    end)
    
    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("AI Running") end
    forcePrint("LinkedSwordAI: Script initialized successfully")
    
    return true
end

-- Start the AI
local success, errorMsg = pcall(InitializeAI)

if not success then
    forcePrint("LinkedSwordAI: Critical error - " .. tostring(errorMsg))
end
[file content end]
