--[[
LinkedSwordAI_Fixed.lua
Version: 2.0
Author: Fixed by AI Assistant
Description: Enhanced AI for sword combat with improved pathfinding, combat tactics, and movement
--]]

-- Debug functions
local function DebugPrint(message)
    if _G.LinkedSwordAIDebug then
        print("[LinkedSwordAI] " .. message)
    end
end

local function DebugWarn(message)
    if _G.LinkedSwordAIDebug then
        warn("[LinkedSwordAI] " .. message)
    end
end

-- Initialize persistent data if it doesn't exist
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        PathCache = {},
        FailedPaths = {},
        KnownVoidAreas = {},
        TransparentPlatforms = {},
        JumpCalculations = {
            Successful = {},
            Failed = {},
            Attempts = 0,
            SuccessRate = 0
        },
        DeceptiveTechniques = {
            SuccessfulFeints = 0,
            FailedFeints = 0,
            SuccessfulBaits = {},
            TargetReactions = {},
            FavoredTechniques = {}
        },
        TargetMovementHistory = {},
        CombatMetrics = {
            DamageDealt = 0,
            DamageTaken = 0,
            KillCount = 0,
            DeathCount = 0
        }
    }
end

-- Configuration
local CONFIG = {
    -- Core settings
    DEBUG_MODE = false,
    PERFORMANCE_OPTIMIZATION = true,
    
    -- Pathfinding settings
    PATH_CACHE_ENABLED = true,
    PATH_CACHE_LIFETIME = 30,
    PATHFINDING_PATHS = 16,
    PATHFINDING_TIMEOUT = 2,
    
    -- Movement settings
    MOVEMENT_SPEED_MULTIPLIER = 1.2,
    MOVEMENT_SMOOTHING = true,
    VOID_AVOIDANCE_ENABLED = true,
    VOID_AVOIDANCE_CONTINUOUS = true,
    TRANSPARENT_PLATFORM_CHECK = true,
    JUMP_CALCULATION_ENABLED = true,
    
    -- Combat settings
    COMBAT_STYLE = "OFFENSIVE_DEFENSIVE",
    DECEPTIVE_TECHNIQUES_ENABLED = true,
    ADVANCED_STRAFING = true,
    OPTIMIZED_LUNGES = true,
    LUNGE_SPEED_MULTIPLIER = 1.5,
    COMBO_STRIKES_ENABLED = true,
    
    -- Performance settings
    GARBAGE_COLLECTION_INTERVAL = 60,
    CACHE_CLEANUP_INTERVAL = 30,
    MAX_PATH_CACHE_SIZE = 100,
    MAX_FAILED_PATHS_SIZE = 50
}

-- Get services
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")

-- Variables
local persistentData = _G.LinkedSwordAIPersistentData
local character = script.Parent
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local sword = nil
local target = nil
local currentPath = nil
local lastPathfindingTime = 0
local isStuck = false
local stuckTime = 0
local lastPosition = rootPart.Position
local lastMoveDirection = Vector3.new(0, 0, 0)
local combatState = "IDLE"
local lastAttackTime = 0
local deceptiveTechniqueInProgress = false
local jumpCooldown = 0

-- Find the sword
local function FindSword()
    for _, item in pairs(character:GetChildren()) do
        if item:IsA("Tool") and item.Name:find("Sword") then
            return item
        end
    end
    
    return nil
end

-- Find the closest player
local function FindClosestPlayer()
    local closestPlayer = nil
    local closestDistance = math.huge
    
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character ~= character then
            local playerRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if playerRootPart then
                local distance = (playerRootPart.Position - rootPart.Position).Magnitude
                if distance < closestDistance and distance < 100 then
                    closestPlayer = player.Character
                    closestDistance = distance
                end
            end
        end
    end
    
    return closestPlayer
end

-- Check if a position is in a void area
local function IsInVoidArea(position)
    for _, voidArea in pairs(persistentData.KnownVoidAreas) do
        if (position - voidArea.Position).Magnitude < voidArea.Radius then
            return true
        end
    end
    
    return false
end

-- Check if a platform is transparent (previously fallen through)
local function IsTransparentPlatform(position)
    for _, platform in pairs(persistentData.TransparentPlatforms) do
        if (position.X - platform.X)^2 + (position.Z - platform.Z)^2 < 4 and math.abs(position.Y - platform.Y) < 2 then
            return true
        end
    end
    
    return false
end

-- Check if there's a safe gap ahead
local function IsSafeGap(position, direction, distance)
    local rayStart = position + Vector3.new(0, -2, 0)
    local rayEnd = rayStart + direction * distance
    
    local ray = Ray.new(rayStart, rayEnd - rayStart)
    local hitPart, hitPosition = workspace:FindPartOnRay(ray, character)
    
    if not hitPart then
        -- Check if it's a known void area
        if IsInVoidArea(position + direction * distance) then
            return false
        end
        
        -- Cast another ray from higher up to check for platforms
        local highRay = Ray.new(position + Vector3.new(0, 2, 0), direction * distance)
        local highHitPart = workspace:FindPartOnRay(highRay, character)
        
        if not highHitPart then
            return false
        end
    end
    
    return true
end

-- Check if an obstacle is jumpable
local function IsJumpableObstacle(position, direction)
    -- Cast rays at different heights to detect obstacles
    for height = 0, 5, 1 do
        local rayStart = position + Vector3.new(0, height, 0)
        local rayEnd = rayStart + direction * 4
        
        local ray = Ray.new(rayStart, rayEnd - rayStart)
        local hitPart = workspace:FindPartOnRay(ray, character)
        
        if hitPart then
            -- If obstacle is between 0-5 studs high, it's jumpable
            if height > 0 and height <= 5 then
                return true, height
            end
        end
    end
    
    return false, 0
end

-- Record jump calculation
local function RecordJumpCalculation(success, height)
    persistentData.JumpCalculations.Attempts = persistentData.JumpCalculations.Attempts + 1
    
    if success then
        persistentData.JumpCalculations.Successful[height] = (persistentData.JumpCalculations.Successful[height] or 0) + 1
    else
        persistentData.JumpCalculations.Failed[height] = (persistentData.JumpCalculations.Failed[height] or 0) + 1
    end
    
    -- Calculate success rate
    local totalSuccessful = 0
    for _, count in pairs(persistentData.JumpCalculations.Successful) do
        totalSuccessful = totalSuccessful + count
    end
    
    persistentData.JumpCalculations.SuccessRate = totalSuccessful / persistentData.JumpCalculations.Attempts
end

-- Handle movement to a position
local function MoveTo(position)
    if not position then return end
    
    -- Check if the position is in a known void area
    if CONFIG.VOID_AVOIDANCE_ENABLED and IsInVoidArea(position) then
        DebugPrint("Avoiding known void area")
        
        -- Find an alternative position
        local direction = (position - rootPart.Position).Unit
        local alternativePosition = rootPart.Position + direction * 5
        
        -- If continuous movement is enabled, find a position around the void
        if CONFIG.VOID_AVOIDANCE_CONTINUOUS then
            local angles = {45, -45, 90, -90, 135, -135, 180}
            
            for _, angle in pairs(angles) do
                local rotatedDirection = CFrame.Angles(0, math.rad(angle), 0) * direction
                local testPosition = rootPart.Position + rotatedDirection * 10
                
                if not IsInVoidArea(testPosition) then
                    alternativePosition = testPosition
                    break
                end
            end
        end
        
        position = alternativePosition
    end
    
    -- Check for transparent platforms
    if CONFIG.TRANSPARENT_PLATFORM_CHECK then
        local rayStart = position + Vector3.new(0, 2, 0)
        local rayDirection = Vector3.new(0, -10, 0)
        local ray = Ray.new(rayStart, rayDirection)
        local hitPart, hitPosition = workspace:FindPartOnRay(ray, character)
        
        if hitPart and IsTransparentPlatform(hitPosition) then
            DebugPrint("Avoiding transparent platform")
            
            -- Find an alternative position
            local direction = (position - rootPart.Position).Unit
            local angles = {45, -45, 90, -90, 135, -135, 180}
            
            for _, angle in pairs(angles) do
                local rotatedDirection = CFrame.Angles(0, math.rad(angle), 0) * direction
                local testPosition = rootPart.Position + rotatedDirection * 5
                
                local testRay = Ray.new(testPosition + Vector3.new(0, 2, 0), Vector3.new(0, -10, 0))
                local testHitPart, testHitPosition = workspace:FindPartOnRay(testRay, character)
                
                if testHitPart and not IsTransparentPlatform(testHitPosition) then
                    position = testPosition
                    break
                end
            end
        end
    end
    
    -- Check if the path is safe
    local direction = (position - rootPart.Position).Unit
    local distance = (position - rootPart.Position).Magnitude
    
    if distance > 2 and not IsSafeGap(rootPart.Position, direction, math.min(distance, 4)) then
        DebugPrint("Unsafe gap detected, finding alternative path")
        
        -- Try to find a safe path
        local angles = {30, -30, 60, -60, 90, -90}
        local safePath = false
        
        for _, angle in pairs(angles) do
            local rotatedDirection = CFrame.Angles(0, math.rad(angle), 0) * direction
            if IsSafeGap(rootPart.Position, rotatedDirection, 4) then
                humanoid:MoveTo(rootPart.Position + rotatedDirection * 4)
                safePath = true
                break
            end
        end
        
        if not safePath then
            DebugPrint("No safe path found, staying in place")
            return
        end
    else
        -- Check for jumpable obstacles when enabled
        if CONFIG.JUMP_CALCULATION_ENABLED and jumpCooldown <= 0 then
            local isJumpable, height = IsJumpableObstacle(rootPart.Position, direction)
            
            if isJumpable then
                DebugPrint("Jumpable obstacle detected, height: " .. height)
                
                -- Record the jump calculation
                RecordJumpCalculation(true, height)
                
                -- Jump over the obstacle
                humanoid.Jump = true
                jumpCooldown = 1
            end
        end
        
        -- Apply movement smoothing if enabled
        if CONFIG.MOVEMENT_SMOOTHING and lastMoveDirection.Magnitude > 0 then
            local smoothDirection = (direction + lastMoveDirection).Unit
            direction = smoothDirection
        end
        
        -- Move to the position with adjusted speed
        humanoid.WalkSpeed = 16 * CONFIG.MOVEMENT_SPEED_MULTIPLIER
        humanoid:MoveTo(position)
        
        -- Update last move direction
        lastMoveDirection = direction
    end
end

-- Handle pathfinding to a position
local function PathfindTo(position)
    if not position then return end
    
    -- Check if we have a cached path
    local cacheKey = tostring(math.floor(rootPart.Position.X)) .. "," .. 
                    tostring(math.floor(rootPart.Position.Z)) .. "," ..
                    tostring(math.floor(position.X)) .. "," ..
                    tostring(math.floor(position.Z))
    
    if CONFIG.PATH_CACHE_ENABLED and persistentData.PathCache[cacheKey] and 
       persistentData.PathCache[cacheKey].Time > os.time() - CONFIG.PATH_CACHE_LIFETIME then
        DebugPrint("Using cached path")
        currentPath = persistentData.PathCache[cacheKey].Path
        return
    end
    
    -- Check if this is a known failed path
    if persistentData.FailedPaths[cacheKey] and 
       persistentData.FailedPaths[cacheKey] > os.time() - 10 then
        DebugPrint("Skipping known failed path")
        return
    end
    
    -- Don't pathfind too frequently
    if os.time() - lastPathfindingTime < 1 then
        return
    end
    
    lastPathfindingTime = os.time()
    
    -- Create a new path
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        WaypointSpacing = 4
    })
    
    -- Compute the path
    local success, errorMessage = pcall(function()
        path:ComputeAsync(rootPart.Position, position)
    end)
    
    if success and path.Status == Enum.PathStatus.Success then
        DebugPrint("Path computed successfully")
        currentPath = path
        
        -- Cache the path
        if CONFIG.PATH_CACHE_ENABLED then
            persistentData.PathCache[cacheKey] = {
                Path = path,
                Time = os.time()
            }
        end
    else
        DebugPrint("Failed to compute path: " .. tostring(errorMessage))
        currentPath = nil
        
        -- Record the failed path
        persistentData.FailedPaths[cacheKey] = os.time()
    end
end

-- Follow the current path
local function FollowPath()
    if not currentPath then return end
    
    local waypoints = currentPath:GetWaypoints()
    if #waypoints == 0 then return end
    
    local nextWaypointIndex = 1
    
    -- Find the next waypoint
    for i, waypoint in ipairs(waypoints) do
        if (waypoint.Position - rootPart.Position).Magnitude > 4 then
            nextWaypointIndex = i
            break
        end
    end
    
    if nextWaypointIndex > #waypoints then
        currentPath = nil
        return
    end
    
    -- Move to the next waypoint
    MoveTo(waypoints[nextWaypointIndex].Position)
end

-- Handle being stuck
local function HandleStuck()
    if (rootPart.Position - lastPosition).Magnitude < 0.5 then
        stuckTime = stuckTime + 1
        
        if stuckTime > 5 then
            isStuck = true
            DebugPrint("Stuck detected")
            
            -- Try to jump
            humanoid.Jump = true
            
            -- Try to move in a random direction
            local randomAngle = math.random() * math.pi * 2
            local randomDirection = Vector3.new(math.cos(randomAngle), 0, math.sin(randomAngle))
            MoveTo(rootPart.Position + randomDirection * 10)
            
            -- Record the position as a potential void area
            table.insert(persistentData.KnownVoidAreas, {
                Position = rootPart.Position,
                Radius = 3,
                Time = os.time()
            })
            
            -- Record as a transparent platform if we're falling
            if humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                table.insert(persistentData.TransparentPlatforms, {
                    X = rootPart.Position.X,
                    Y = rootPart.Position.Y,
                    Z = rootPart.Position.Z,
                    Time = os.time()
                })
            end
            
            stuckTime = 0
        end
    else
        stuckTime = 0
        isStuck = false
    end
    
    lastPosition = rootPart.Position
end

-- Handle being stuck on a player
local function HandleStuckOnPlayer()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character ~= character then
            local playerRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if playerRootPart and (playerRootPart.Position - rootPart.Position).Magnitude < 3 then
                DebugPrint("Stuck on player, moving away")
                
                local awayDirection = (rootPart.Position - playerRootPart.Position).Unit
                MoveTo(rootPart.Position + awayDirection * 10)
                return true
            end
        end
    end
    
    return false
end

-- Handle fleeing from force fields
local function HandleFleeFromForceField()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character ~= character then
            local forceField = player.Character:FindFirstChild("ForceField")
            if forceField then
                local playerRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if playerRootPart and (playerRootPart.Position - rootPart.Position).Magnitude < 20 then
                    DebugPrint("Force field detected, fleeing")
                    
                    local awayDirection = (rootPart.Position - playerRootPart.Position).Unit
                    MoveTo(rootPart.Position + awayDirection * 30)
                    return true
                end
            end
        end
    end
    
    return false
end

-- Handle movement
local function HandleMovement()
    if not target then return end
    
    local targetRootPart = target:FindFirstChild("HumanoidRootPart")
    if not targetRootPart then return end
    
    -- Handle being stuck
    if isStuck then
        if HandleStuckOnPlayer() then
            return
        end
    end
    
    -- Handle fleeing from force fields
    if HandleFleeFromForceField() then
        return
    end
    
    -- Determine target position based on combat state
    local targetPosition = targetRootPart.Position
    
    if combatState == "OFFENSIVE" then
        -- Get closer to the target
        targetPosition = targetRootPart.Position
    elseif combatState == "DEFENSIVE" then
        -- Keep some distance
        local awayDirection = (rootPart.Position - targetRootPart.Position).Unit
        targetPosition = targetRootPart.Position + awayDirection * 10
    elseif combatState == "OFFENSIVE_DEFENSIVE" then
        -- Dynamic positioning based on situation
        local distanceToTarget = (targetRootPart.Position - rootPart.Position).Magnitude
        
        if distanceToTarget > 15 then
            -- Get closer if too far
            targetPosition = targetRootPart.Position
        elseif distanceToTarget < 5 then
            -- Back up if too close
            local awayDirection = (rootPart.Position - targetRootPart.Position).Unit
            targetPosition = rootPart.Position + awayDirection * 5
        else
            -- Strafe around the target
            local rightVector = rootPart.CFrame.RightVector
            local strafeDirection = math.random() > 0.5 and rightVector or -rightVector
            
            -- Check if the strafe direction is safe
            if CONFIG.ADVANCED_STRAFING then
                local leftSafe = IsSafeGap(rootPart.Position, -rightVector, 5)
                local rightSafe = IsSafeGap(rootPart.Position, rightVector, 5)
                
                if leftSafe and not rightSafe then
                    strafeDirection = -rightVector
                elseif rightSafe and not leftSafe then
                    strafeDirection = rightVector
                end
            end
            
            targetPosition = rootPart.Position + strafeDirection * 8
        end
    end
    
    -- Use pathfinding for longer distances
    if (targetPosition - rootPart.Position).Magnitude > 20 then
        PathfindTo(targetPosition)
        FollowPath()
    else
        MoveTo(targetPosition)
    end
end

-- Handle sword equipping
local function HandleSwordEquip()
    if not sword then
        sword = FindSword()
        if sword then
            DebugPrint("Found sword: " .. sword.Name)
        end
    end
    
    if sword and sword.Parent ~= character then
        DebugPrint("Equipping sword")
        sword.Parent = character
    end
end

-- Handle sword activation
local function ActivateSword()
    if not sword then return end
    
    local activateFunction = sword:FindFirstChild("Activate")
    if activateFunction and activateFunction:IsA("RemoteEvent") then
        DebugPrint("Activating sword")
        activateFunction:FireServer()
        return true
    end
    
    return false
end

-- Record target movement
local function RecordTargetMovement(targetRootPart)
    if not targetRootPart then return end
    
    local targetId = tostring(targetRootPart)
    if not persistentData.TargetMovementHistory[targetId] then
        persistentData.TargetMovementHistory[targetId] = {
            Positions = {},
            Velocities = {},
            PredictabilityScore = 0
        }
    end
    
    local history = persistentData.TargetMovementHistory[targetId]
    
    -- Add current position and velocity
    table.insert(history.Positions, targetRootPart.Position)
    table.insert(history.Velocities, targetRootPart.Velocity)
    
    -- Keep only the last 10 entries
    if #history.Positions > 10 then
        table.remove(history.Positions, 1)
        table.remove(history.Velocities, 1)
    end
    
    -- Calculate predictability score
    if #history.Velocities >= 3 then
        local consistencyScore = 0
        
        for i = 2, #history.Velocities do
            local prevVel = history.Velocities[i-1]
            local currVel = history.Velocities[i]
            
            local dotProduct = prevVel.Unit:Dot(currVel.Unit)
            consistencyScore = consistencyScore + dotProduct
        end
        
        history.PredictabilityScore = consistencyScore / (#history.Velocities - 1)
    end
    
    return history.PredictabilityScore
end

-- Perform a deceptive technique
local function PerformDeceptiveTechnique()
    if not target or deceptiveTechniqueInProgress then return end
    
    local targetRootPart = target:FindFirstChild("HumanoidRootPart")
    if not targetRootPart then return end
    
    DebugPrint("Performing deceptive technique")
    deceptiveTechniqueInProgress = true
    
    -- Get target predictability
    local predictabilityScore = RecordTargetMovement(targetRootPart)
    local techniqueChance = 0.3
    
    -- Adjust chance based on predictability
    if predictabilityScore then
        techniqueChance = techniqueChance + (predictabilityScore * 0.4)
    end
    
    -- Only perform if chance is met
    if math.random() > techniqueChance then
        deceptiveTechniqueInProgress = false
        return
    end
    
    -- Step 1: Quick feint with sidestep
    local rightVector = rootPart.CFrame.RightVector
    local sideDirection = math.random() > 0.5 and rightVector or -rightVector
    MoveTo(rootPart.Position + sideDirection * 5)
    
    -- Activate sword during feint
    ActivateSword()
    
    -- Step 2: Aggressive counter-attack
    delay(0.3, function()
        if not target then 
            deceptiveTechniqueInProgress = false
            return 
        end
        
        local targetRootPart = target:FindFirstChild("HumanoidRootPart")
        if not targetRootPart then 
            deceptiveTechniqueInProgress = false
            return 
        end
        
        -- Move quickly towards target at an angle
        local toTarget = (targetRootPart.Position - rootPart.Position).Unit
        local attackAngle = CFrame.Angles(0, math.rad(math.random(-30, 30)), 0)
        local attackDirection = attackAngle * toTarget
        
        -- Increase speed for lunge
        humanoid.WalkSpeed = 16 * CONFIG.LUNGE_SPEED_MULTIPLIER
        MoveTo(targetRootPart.Position + attackDirection * 3)
        
        -- Double strike combo
        ActivateSword()
        
        delay(0.2, function()
            ActivateSword()
            
            -- Record the technique result
            local success = (targetRootPart.Position - rootPart.Position).Magnitude < 10
            if success then
                persistentData.DeceptiveTechniques.SuccessfulFeints = persistentData.DeceptiveTechniques.SuccessfulFeints + 1
                
                -- Record successful bait type
                local baitType = "sidestep_double_strike"
                persistentData.DeceptiveTechniques.SuccessfulBaits[baitType] = (persistentData.DeceptiveTechniques.SuccessfulBaits[baitType] or 0) + 1
                
                -- Record target reaction
                local targetVelocity = targetRootPart.Velocity
                local reactionType = targetVelocity.Magnitude < 5 and "stationary" or "evasive"
                persistentData.DeceptiveTechniques.TargetReactions[reactionType] = (persistentData.DeceptiveTechniques.TargetReactions[reactionType] or 0) + 1
            else
                persistentData.DeceptiveTechniques.FailedFeints = persistentData.DeceptiveTechniques.FailedFeints + 1
            end
            
            -- Reset speed
            humanoid.WalkSpeed = 16 * CONFIG.MOVEMENT_SPEED_MULTIPLIER
            deceptiveTechniqueInProgress = false
        end)
    end)
end

-- Handle combat
local function HandleCombat()
    if not target then return end
    
    local targetRootPart = target:FindFirstChild("HumanoidRootPart")
    if not targetRootPart then return end
    
    local distanceToTarget = (targetRootPart.Position - rootPart.Position).Magnitude
    
    -- Face the target
    rootPart.CFrame = CFrame.lookAt(rootPart.Position, Vector3.new(targetRootPart.Position.X, rootPart.Position.Y, targetRootPart.Position.Z))
    
    -- Determine combat state based on distance and situation
    if distanceToTarget < 8 then
        -- Close range: offensive or offensive-defensive
        if CONFIG.COMBAT_STYLE == "OFFENSIVE_DEFENSIVE" then
            combatState = "OFFENSIVE_DEFENSIVE"
        else
            combatState = "OFFENSIVE"
        end
    elseif distanceToTarget < 20 then
        -- Medium range: offensive-defensive
        combatState = "OFFENSIVE_DEFENSIVE"
    else
        -- Long range: offensive (to close the gap)
        combatState = "OFFENSIVE"
    end
    
    -- Handle attacks based on combat state
    if combatState == "OFFENSIVE" then
        -- Simple offensive approach
        if distanceToTarget < 10 and os.time() - lastAttackTime > 1 then
            ActivateSword()
            lastAttackTime = os.time()
        end
    elseif combatState == "DEFENSIVE" then
        -- Defensive approach - attack only when necessary
        if distanceToTarget < 8 and os.time() - lastAttackTime > 2 then
            ActivateSword()
            lastAttackTime = os.time()
            
            -- Back up after attacking
            local awayDirection = (rootPart.Position - targetRootPart.Position).Unit
            MoveTo(rootPart.Position + awayDirection * 8)
        end
    elseif combatState == "OFFENSIVE_DEFENSIVE" then
        -- Advanced offensive-defensive approach
        if distanceToTarget < 12 then
            if CONFIG.DECEPTIVE_TECHNIQUES_ENABLED and math.random() < 0.3 and os.time() - lastAttackTime > 3 then
                -- Use deceptive technique
                PerformDeceptiveTechnique()
                lastAttackTime = os.time()
            elseif os.time() - lastAttackTime > 1.5 then
                -- Standard attack with optimized lunges
                if CONFIG.OPTIMIZED_LUNGES then
                    -- Increase speed for lunge
                    humanoid.WalkSpeed = 16 * CONFIG.LUNGE_SPEED_MULTIPLIER
                    
                    -- Move towards target
                    local toTarget = (targetRootPart.Position - rootPart.Position).Unit
                    MoveTo(targetRootPart.Position - toTarget * 3)
                    
                    -- Activate sword
                    ActivateSword()
                    
                    -- Multi-activation combo if enabled
                    if CONFIG.COMBO_STRIKES_ENABLED and distanceToTarget < 8 then
                        delay(0.2, function()
                            ActivateSword()
                        end)
                    end
                    
                    -- Reset speed after delay
                    delay(0.5, function()
                        humanoid.WalkSpeed = 16 * CONFIG.MOVEMENT_SPEED_MULTIPLIER
                    end)
                else
                    -- Standard attack
                    ActivateSword()
                end
                
                lastAttackTime = os.time()
            end
        end
    end
end

-- Clean up caches
local function CleanupCaches()
    -- Clean up path cache
    if CONFIG.PATH_CACHE_ENABLED then
        local currentTime = os.time()
        local count = 0
        
        for key, data in pairs(persistentData.PathCache) do
            count = count + 1
            if currentTime - data.Time > CONFIG.PATH_CACHE_LIFETIME then
                persistentData.PathCache[key] = nil
                count = count - 1
            end
        end
        
        -- If cache is too large, remove oldest entries
        if count > CONFIG.MAX_PATH_CACHE_SIZE then
            local entries = {}
            for key, data in pairs(persistentData.PathCache) do
                table.insert(entries, {Key = key, Time = data.Time})
            end
            
            table.sort(entries, function(a, b)
                return a.Time < b.Time
            end)
            
            for i = 1, count - CONFIG.MAX_PATH_CACHE_SIZE do
                if entries[i] then
                    persistentData.PathCache[entries[i].Key] = nil
                end
            end
        end
    end
    
    -- Clean up failed paths
    local currentTime = os.time()
    local count = 0
    
    for key, time in pairs(persistentData.FailedPaths) do
        count = count + 1
        if currentTime - time > 60 then
            persistentData.FailedPaths[key] = nil
            count = count - 1
        end
    end
    
    -- If failed paths is too large, remove oldest entries
    if count > CONFIG.MAX_FAILED_PATHS_SIZE then
        local entries = {}
        for key, time in pairs(persistentData.FailedPaths) do
            table.insert(entries, {Key = key, Time = time})
        end
        
        table.sort(entries, function(a, b)
            return a.Time < b.Time
        end)
        
        for i = 1, count - CONFIG.MAX_FAILED_PATHS_SIZE do
            if entries[i] then
                persistentData.FailedPaths[entries[i].Key] = nil
            end
        end
    end
    
    -- Clean up void areas older than 1 hour
    for i = #persistentData.KnownVoidAreas, 1, -1 do
        if currentTime - persistentData.KnownVoidAreas[i].Time > 3600 then
            table.remove(persistentData.KnownVoidAreas, i)
        end
    end
    
    -- Clean up transparent platforms older than 1 hour
    for i = #persistentData.TransparentPlatforms, 1, -1 do
        if currentTime - persistentData.TransparentPlatforms[i].Time > 3600 then
            table.remove(persistentData.TransparentPlatforms, i)
        end
    end
end

-- Main update function
local function Update()
    -- Garbage collection
    if CONFIG.PERFORMANCE_OPTIMIZATION and os.time() % CONFIG.GARBAGE_COLLECTION_INTERVAL == 0 then
        collectgarbage("collect")
    end
    
    -- Cache cleanup
    if os.time() % CONFIG.CACHE_CLEANUP_INTERVAL == 0 then
        CleanupCaches()
    end
    
    -- Find sword if needed
    HandleSwordEquip()
    
    -- Find target if needed
    if not target or not target:FindFirstChild("Humanoid") or target:FindFirstChild("Humanoid").Health <= 0 then
        target = FindClosestPlayer()
    end
    
    -- Handle movement and combat
    HandleStuck()
    HandleMovement()
    HandleCombat()
    
    -- Update jump cooldown
    if jumpCooldown > 0 then
        jumpCooldown = jumpCooldown - 0.1
    end
end

-- Connect to RunService
RunService.Heartbeat:Connect(Update)

-- Initialization message
DebugPrint("LinkedSwordAI initialized")
