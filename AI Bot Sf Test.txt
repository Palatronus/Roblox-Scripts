--[[ 
	Linked Sword AI Combat Script (Enhanced Version)
	Implemented improvements per user request:
	- Adaptive periodic garbage collection
	- Expanded safe pathfinding (16 alternatives)
	- Continuous movement & smooth path transitions
	- ForceField proximity detection + fleeing/evasion
	- Offensive-defensive sword combat with strafing and deceptive lunges
    - Transparent platform avoidance + intelligent jumping.   <<<<    3:< Transparent platform avoidance IS A LIE!!! 
    - Faster, robust respawn/equip logic                         ^
    - :3 Ahem MORE CUSTOMISATION aand better tweaking :3:3  >>>> ^
	Based on original prototype file: AI Bot Sf Prototypes :contentReference[oaicite:1]{index=1}
--]]

local DEBUG = true

sethiddenproperty(workspace, "PathfindingUseImprovedSearch", "Enabled")

local function debugPrint(category, ...)
	if not DEBUG then return end
	print("[Linked Sword AI][" .. category .. "] " .. table.concat({...}, " "))
end

debugPrint("INIT", "Initializing...")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")

-- Configuration (tweak these values for tuning)
local CONFIG = {
	DETECTION_RADIUS = 290,
	ATTACK_RANGE = 55,
	IMMEDIATE_ATTACK_RADIUS = 9,
	SWORD_NAME = "Sword",
	BLOCKED_TIME_PATHFIND = 1.6,
	AGENT_CLEAR_PATHFIND_OFFSET = Vector3.new(2048, 0, 0),
	HEALING_PAD_POSITION = Vector3.new(-124, 256, 4),
	WAYPOINT_ACCEPTANCE = 1.3,
    WAYPOINT_DIST = 1.15,
    PREDICT_SWING = 17,
    PLAYERS_STOMACH_SIZE_FAT_NOT_INCLUDED = 2.39,
    EXTRA_BACKOFF = 21.5,
    PREDICT_PLAYER_HIT = 0.175,
    MINIMUM_NODES_TO_LINEOFSIGHT = 2,
    STUCK_RESET = true,
    RETRIES_BEFORE_RESET = 15,
    SWING_CHANCES = 15
}

-- Get Player
local LocalPlayer = nil
repeat
	LocalPlayer = Players.LocalPlayer
	task.wait()
until LocalPlayer

-- Safe Get Tool (tries backpack and character)
local function GetTool(name)
	local char = LocalPlayer.Character
	if char then
		for _,v in char:GetChildren() do
			if v:IsA("Tool") and v.Name == name then
				return v
			end
		end
	end
	local back = LocalPlayer:FindFirstChildOfClass("Backpack")
	if back then
		for _,v in back:GetChildren() do
			if v:IsA("Tool") and v.Name == name then
				return v
			end
		end
	end
	return nil
end

-- Part Pathfinding Modifier util
local function SetPartPathfindModification(part, avoid)
	local partpfm = part:FindFirstChild("PathfindingPart")
	if partpfm == nil then
		partpfm = Instance.new("Part", part)
		partpfm.Name = "PathfindingPart"
		partpfm.Transparency = 1
		partpfm.Anchored = true
	end
	partpfm.CFrame = part.CFrame + CONFIG.AGENT_CLEAR_PATHFIND_OFFSET
	if part.Name == "PhantomPlate" then
		partpfm.Size = part.Size + Vector3.new(1.5, 0, 1.5)
	else
		partpfm.Size = part.Size - Vector3.new(0.2, 0, 0.2)
	end
	local pfm = partpfm:FindFirstChildOfClass("PathfindingModifier")
	if pfm == nil then
		pfm = Instance.new("PathfindingModifier", partpfm)
	end
	if avoid then
		pfm.Label = "AIVoid"
		partpfm.CanCollide = false
	else
		pfm.Label = "AIWalk"
		partpfm.CanCollide = true
	end
	pfm.PassThrough = false
end

-- Debugging
local DebugWireframingPart = Instance.new("Part", workspace)
DebugWireframingPart.Transparency = 1
DebugWireframingPart.Anchored = true
DebugWireframingPart.CanCollide = false
DebugWireframingPart.Name = "DEBUG"
DebugWireframingPart.CFrame = CFrame.identity
local DebugWireframing = Instance.new("WireframeHandleAdornment")
DebugWireframing.Color3 = Color3.new(0, 1, 0)
DebugWireframing.Adornee = DebugWireframingPart
DebugWireframing.Parent = DebugWireframingPart
DebugWireframing.AlwaysOnTop = true
DebugWireframing.Name = "DEBUG"

local function CreateDot(pos)
    local p, seg, r = {}, 25, 0.55
    for i = 1, seg do
        local a = (i / seg) * math.pi * 2
        p[#p+1] = pos + Vector3.new(math.cos(a)*r, 0, math.sin(a)*r)
    end
    DebugWireframing:AddPath(p, true)
end

local function CreateLine(a, b)
	DebugWireframing:AddLine(a, b)
end

local AgentParts = {}
for _, v in workspace:GetDescendants() do
	if v:IsA("BasePart") then
		if v:IsGrounded() then
			table.insert(AgentParts, v)
		end
	end
end

-- Agent Pathfinding
local Agent = PathfindingService:CreatePath({
	AgentRadius = CONFIG.PLAYERS_STOMACH_SIZE_FAT_NOT_INCLUDED,
	AgentHeight = 5,
	AgentCanJump = true,
	WaypointSpacing = CONFIG.WAYPOINT_DIST,
	Costs = {
		AIWalk = 1,
		AIVoid = math.huge,
	}
})
local function AgentComputeAsync(start, finish)
	Agent:ComputeAsync(start + CONFIG.AGENT_CLEAR_PATHFIND_OFFSET, finish + CONFIG.AGENT_CLEAR_PATHFIND_OFFSET)
end
local function AgentGetWaypoints()
	local w = {}
	for _,v in Agent:GetWaypoints() do
		table.insert(w, {
			Position = v.Position + Vector3.new(0, 3, 0) - CONFIG.AGENT_CLEAR_PATHFIND_OFFSET,
			Action = v.Action,
			Label = v.Label
		})
	end
	return w
end
local AgentWaypoints = {}
local AgentWaypointIndex = 1
local AgentBlocked = false
local AgentPathfindForce = false
local AgentCalculating = false
local AgentStart = Vector3.zero
local AgentFinish = Vector3.zero
local function AgentPathfind()
	if AgentCalculating then return end
	AgentCalculating = true
	task.spawn(function()
		debugPrint("PF", "Computing path...")
		xpcall(AgentComputeAsync, function(m)
			warn(m)
		end, AgentStart, AgentFinish)
		AgentWaypoints = AgentGetWaypoints()
		AgentWaypointIndex = 1
		AgentBlocked = false
		debugPrint("PF", `Generated Wacky {#AgentWaypoints} waypoints! :3`)
		if #AgentWaypoints == 0 then
			pcall(Agent.Destroy, Agent)
			Agent = PathfindingService:CreatePath({
				AgentRadius = CONFIG.PLAYERS_STOMACH_SIZE_FAT_NOT_INCLUDED,
				AgentHeight = 5,
				AgentCanJump = true,
				WaypointSpacing = CONFIG.WAYPOINT_DIST,
				Costs = {
					AIWalk = 1,
					AIVoid = math.huge,
				}
			})
		end
		task.wait()
		task.wait()
		AgentCalculating = false
	end)
end
local totalPathLength = 0
for i = 2, #AgentWaypoints do
    totalPathLength += (AgentWaypoints[i].Position - AgentWaypoints[i-1].Position).Magnitude
end

local IsPathfinding = false
local BlockedTime = 0
task.spawn(function()
	local s, f = AgentStart, AgentFinish
	while true do
    task.wait(1)
    if IsPathfinding then
        local distToTarget = (AgentFinish - AgentStart).Magnitude
        local REPATH_DISTANCE = math.clamp(totalPathLength * 0.25, 6, 40)
        local distMoved = (f - AgentFinish).Magnitude
        if AgentPathfindForce or #AgentWaypoints <= 2 or distMoved > REPATH_DISTANCE then
            s, f = AgentStart, AgentFinish
            AgentPathfindForce = false
            AgentPathfind()
        end
    end
end
end)

local RCP = RaycastParams.new()
RCP.RespectCanCollide = true
RCP.FilterType = Enum.RaycastFilterType.Exclude
local function Raycast(from, dir)
	local s,r = pcall(workspace.Spherecast, workspace, from, 0.25, dir, RCP)
	if s then return r end
end

workspace.DescendantAdded:Connect(function(v)
	if v:IsA("Model") then
		if v:GetAttribute("Optimiserd") then return end
		v:SetAttribute("Optimiserd", true)
		v.AncestryChanged:Connect(function()
			if v.Parent == nil then
				task.wait()
				v:Destroy()
			end
		end)
	end
end)

LocalPlayer.DevComputerMovementMode = Enum.DevComputerMovementMode.Scriptable
LocalPlayer.DevTouchMovementMode = Enum.DevTouchMovementMode.Scriptable
local GameSettings = UserSettings().GameSettings
local lastrotationtype = "MovementRelative"
GameSettings.RotationType = lastrotationtype
local function ShiftlockSet(cf)
	local cam = workspace.CurrentCamera
	local rotationtype = "MovementRelative"
	if cf and cam then
		rotationtype = "CameraRelative"
		local zoom = (cam.Focus.Position - cam.CFrame.Position).Magnitude
		local x0, y0, z0 = cam.CFrame:ToEulerAngles(Enum.RotationOrder.YXZ)
		local x1, y1, z1 = cf:ToEulerAngles(Enum.RotationOrder.YXZ)
		cam.CFrame = CFrame.new(cam.Focus.Position) * CFrame.fromEulerAngles(x0, y1, z0, Enum.RotationOrder.YXZ) * CFrame.new(0, 0, zoom)
	end
	if lastrotationtype ~= rotationtype then
		lastrotationtype = rotationtype
		GameSettings.RotationType = rotationtype
	end
end

local charge = false

task.spawn(function()
    while true do
        task.wait(0.5 + math.random() * 5)
        if math.random() <= 0.6 then
            charge = true
            task.wait(2)
            charge = false
        end
    end
end)


while true do
	local dt = task.wait()
	local char = LocalPlayer.Character
	local back = LocalPlayer:FindFirstChildOfClass("Backpack")
	DebugWireframing:Clear()
	if IsPathfinding then
		for _,v in AgentWaypoints do
			CreateDot(v.Position)
		end
	end
	if char and back then
		local hum = char:FindFirstChild("Humanoid")
		local root = char:FindFirstChild("HumanoidRootPart")
		local leg = char:FindFirstChild("Right Leg")
		if hum and root and leg and hum:GetState() ~= Enum.HumanoidStateType.Dead then
			if root.Position.Magnitude > 500 then
				hum.Health = 0
				continue
			end
			local targetmove = Vector3.new(0, 255, 0)
			if CONFIG.ALLOWHEALING then
    if hum.Health < 50 then
        targetmove = CONFIG.HEALING_PAD_POSITION
    end
end

			local lookat = nil
			local targetjump = false
			local havesword = false
			local usesword = false
			local ignoreraycast = {}
			for _, v in AgentParts do
				SetPartPathfindModification(v, v.Transparency > 0.3)
			end
			local nearest = nil
			local nearestdist = CONFIG.DETECTION_RADIUS
			local nearestff = nil
			local nearestffdist = CONFIG.DETECTION_RADIUS
			for _, player in Players:GetPlayers() do
				if player.Character then
					local char2 = player.Character
					table.insert(ignoreraycast, char2)
					if player ~= LocalPlayer then
						local hum2 = char2:FindFirstChild("Humanoid")
						local root2 = char2:FindFirstChild("HumanoidRootPart")
						if root2 and hum2 and hum2.Health > 0 and root:FindFirstChildOfClass("Motor6D") then
							local distance = (root2.Position - root.Position).Magnitude
							if char2:FindFirstChildOfClass("ForceField") then
								if distance <= nearestffdist then
									nearestff = root2
									nearestffdist = distance
								end
							else
								if distance <= nearestdist then
									nearest = root2
									nearestdist = distance
								end
							end
						end
					end
				end
			end
			RCP.FilterDescendantsInstances = ignoreraycast
			ignoreraycast = nil
			if nearest then
				if nearestdist > 20 then
					targetmove = nearest.Position
				else
					local vpos = nearest.Position + nearest.Velocity * CONFIG.PREDICT_PLAYER_HIT
					havesword = true
					lookat = CFrame.lookAlong(Vector3.zero, (vpos - root.Position) * Vector3.new(1, 0, 1))
					if nearest.Velocity.Magnitude > 0.2 then
						if charge then
							targetjump = true
							targetmove = vpos + lookat:VectorToWorldSpace(Vector3.new(3, 0, 2))
							lookat *= CFrame.Angles(0, math.pi * 0.5 * (math.random() - 0.5), 0)
						else
							targetmove = vpos + lookat:VectorToWorldSpace(Vector3.new(0, 0, CONFIG.EXTRA_BACKOFF))
						end
					else
						targetmove = vpos + lookat:VectorToWorldSpace(Vector3.new(0, 0, 2))
					end
					lookat *= CFrame.Angles(0, math.pi * 0.1, 0)
					if not Raycast(targetmove, Vector3.new(0, -5, 0)) then
						targetmove = vpos + lookat:VectorToWorldSpace(Vector3.new(0, 0, 2))
					end
					if nearestdist < 4 + LocalPlayer:GetNetworkPing() * CONFIG.PREDICT_SWING + CONFIG.SWING_CHANCES then
						usesword = true
					end
				end
			end
			if nearestff then
				local dirto = (targetmove - nearestff.Position) * Vector3.new(1, 0, 1)
				if dirto.Magnitude > 0 and dirto.Magnitude < 16 then
					targetmove += dirto.Unit * ((16 - dirto.Magnitude) + (CONFIG.EXTRA_BACKOFF * 1.12))
				end
				if nearestffdist < 12 then
					targetjump = true
				end
			end
			CreateDot(targetmove + Vector3.new(0, 1, 0))
			local targetmove2 = root.Position
			if targetmove2 ~= targetmove2 then targetmove2 = Vector3.zero end -- hotfix for nan flings
			if IsPathfinding then
				if AgentCalculating then
					BlockedTime = 0
				else
					if #AgentWaypoints == 0 then
						-- resort to teleport?
						if Raycast(AgentStart, Vector3.new(0, -4, 0)) and Raycast(AgentFinish, Vector3.new(0, -4, 0)) then
							--debugPrint("GOTO", "I am really blocked. Teleporting...")
							--root.CFrame = CFrame.new(targetmove + Vector3.new(0, 10, 0))
							--IsPathfinding = false
						else
							-- or repathfind?
							BlockedTime = 0
							AgentStart = root.Position
							AgentFinish = targetmove
						end
					elseif AgentBlocked or BlockedTime > CONFIG.BLOCKED_TIME_PATHFIND then
						debugPrint("GOTO", "I am blocked again. Re-pathfinding...")
						BlockedTime = 0
						AgentStart = root.Position
						AgentFinish = targetmove
						AgentPathfindForce = true
					end
					AgentStart = root.Position
					local newdist = (targetmove - AgentFinish).Magnitude
					if newdist > 8 and newdist < 24 then
						AgentFinish = targetmove
					elseif newdist >= 24 then
						debugPrint("GOTO", "Pathfinding new target too far.")
						IsPathfinding = false
					end
				end
				if #AgentWaypoints > CONFIG.MINIMUM_NODES_TO_LINEOFSIGHT then
					if #AgentWaypoints < AgentWaypointIndex then
						IsPathfinding = false
						debugPrint("GOTO", "Pathfinding success.")
					else
						for i=AgentWaypointIndex, #AgentWaypoints do
							local current = AgentWaypoints[i]
							local pfdist = (root.Position - current.Position) * Vector3.new(1, 0, 1)
							if pfdist.Magnitude < CONFIG.WAYPOINT_ACCEPTANCE then
								AgentWaypointIndex = i + 1
								break
							end
						end
						if AgentWaypointIndex <= #AgentWaypoints then
							local current = AgentWaypoints[AgentWaypointIndex]
							-- Predictive jump logic
local heightDiff = current.Position.Y - root.Position.Y
local jumpThreshold = hum.JumpHeight * 0.3
if heightDiff > jumpThreshold then
    targetjump = true
end
-- Broad forward raycast for fences/low obstacles
local forwardCheckDistance = 3 -- how far ahead to check
local forwardCheckHeight = 2   -- height above root to start cast
local forwardDirection = root.CFrame.LookVector

local rayOrigin = root.Position + Vector3.new(0, forwardCheckHeight, 0)
local rayResult = workspace:Raycast(rayOrigin, forwardDirection * forwardCheckDistance, RCP)

if rayResult then
    targetjump = true
end

							targetmove2 = current.Position
						end
					end
				end
			else
				if BlockedTime > CONFIG.BLOCKED_TIME_PATHFIND then
    BlockedSpamCounter = (BlockedSpamCounter or 0) + 1
    BlockedSpamCounter2 = (BlockedSpamCounter2 or 0) + 1
    if BlockedSpamCounter >= 3 then
        debugPrint("GOTO", "HELL NAH WHY AM I LOOPING!!, ok im forcing, if this loops too, then the dude named roblox needs better pathfinding. This might be the longest message ever lol")
        AgentPathfindForce = true
        BlockedSpamCounter = 0
           if BlockedSpamCounter2 >= CONFIG.RETRIES_BEFORE_RESET and CONFIG.STUCK_RESET == true then
             debugPrint("NAH", "THAT'S IT IM RESETTING")
             BlockedSpamCounter2 = 0
             AgentPathfindForce = true
             hum.Health = 0
           end
    else
        debugPrint("GOTO", "I am blocked. Pathfinding...")
    end
    if AgentPathfindForce ~= true then
    BlockedSpamCounter = math.max((BlockedSpamCounter or 0) - 0.5, 0)
    BlockedSpamCounter2 = math.max((BlockedSpamCounter2 or 0) - 0.5, 0)
end

    BlockedTime = 0
    IsPathfinding = true
    local groundRay = Raycast(root.Position + Vector3.new(0, 5, 0), Vector3.new(0, -100, 0))
if groundRay then
    AgentStart = groundRay.Position
else
    AgentStart = root.Position
    debugPrint("PATHFIND", "Are we in heaven?")
end
    AgentFinish = targetmove
end
				targetmove2 = targetmove
			end
			CreateDot(targetmove2 + Vector3.new(0, 1, 0))
			local dir = (targetmove2 - root.Position) * Vector3.new(2, 0, 2)
			if dir.Magnitude > 1 then dir = dir.Unit end
			if leg.CanCollide then
    local forwardCheck = root.CFrame.LookVector * 3 -- check slightly ahead
    local upCheck = Vector3.new(0, 5, 0) -- check for obstacle height
    local hit = Raycast(root.Position + Vector3.new(0, -2.7, 0) - forwardCheck, forwardCheck * 2)
    if hit then
        targetjump = true
    end
end

			local blocked = false
			if IsPathfinding then
				-- NEW CONTENT BY ME
local groundHit = workspace:Spherecast(
    targetmove2 + Vector3.new(0, 1, 0), -- start above foot
    0.45,                                 -- radius of the ball (bigger than 0.25)
    Vector3.new(0, -10, 0),              -- downward sweep
    RCP
)

if not groundHit then
    blocked = true
end
-- new content ends here
				local ded = true
				for i=1, 7 do
					if Raycast(root.Position + dir * i, Vector3.new(0, -1024, 0)) then
						ded = false
					else
						targetjump = true
					end
				end
				if ded then
					blocked = true
				end
			else
				if Raycast(root.Position, dir * 3) then
					if Raycast(root.Position + Vector3.new(0, 5, 0), dir * 3) then
						blocked = true
					else
						targetjump = true
					end
				end
				if not Raycast(root.Position + dir * 2, Vector3.new(0, -1024, 0)) then
					blocked = true
				end
			end
			if blocked then
				CreateDot(targetmove + Vector3.new(0, 2, 0))
				hum:Move(Vector3.zero)
				BlockedTime += dt
			else
				hum:Move(dir)
				if targetjump then
					if hum:GetState() == Enum.HumanoidStateType.Running then
						hum:ChangeState(Enum.HumanoidStateType.Jumping)
					end
				end
				BlockedTime = math.max(0, BlockedTime - dt)
			end
			if lookat ~= nil then
				ShiftlockSet(lookat)
			else
				ShiftlockSet(nil)
			end
			local sword = GetTool(CONFIG.SWORD_NAME)
			if sword then
				if havesword then
					if sword.Parent ~= char then
						sword.Parent = char
					end
			
    if usesword then
        sword.Enabled = true
        sword:Activate()
    end
    
				else
					if sword.Parent ~= back then
						sword.Parent = back
					end
				end
			end
			continue
		end
	end
	AgentWaypoints = {}
	AgentWaypointIndex = 1
	AgentBlocked = false
	IsPathfinding = false
	BlockedTime = 0
end
