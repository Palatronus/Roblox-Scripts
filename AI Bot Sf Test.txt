--[[
    LinkedSword AI - Performance Optimized Version
    
    This version includes advanced performance optimizations:
    - Multi-level spatial caching system
    - Raycast batching and throttling
    - Adaptive path calculation
    - Memory-efficient data structures
    - LRU cache management
]]

-- Configuration
local CONFIG = {
    -- Core settings
    DETECTION_RADIUS = 100,
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.8,
    
    -- Performance settings
    PERFORMANCE_MODE = true,
    PATH_CACHE_TIME = 10,
    PATH_CALCULATION_THROTTLE = 0.7,
    RAYCAST_THROTTLE_FACTOR = 0.2,
    RAYCAST_BATCH_SIZE = 5,
    MAX_RAYCAST_CACHE_SIZE = 500,
    RAYCAST_CACHE_TIME = 5,
    MAX_PATH_CACHE_SIZE = 200,
    CACHE_CLEANUP_RATIO = 0.25,
    TERRAIN_UPDATE_INTERVAL = 5,
    
    -- Advanced caching
    SPATIAL_GRID_SIZE = 5,
    SPATIAL_CACHE_TIME = 15,
    SPATIAL_CACHE_MAX_SIZE = 100,
    LRU_PRUNE_THRESHOLD = 0.25,
    
    -- Terrain connectivity
    TERRAIN_CONNECTIVITY_RADIUS = 30,
    TERRAIN_GRID_SIZE = 8,
    
    -- Adaptive pathfinding
    ALTERNATIVE_PATH_COUNT = 12,
    ADAPTIVE_INCREMENT_MIN = 2,
    ADAPTIVE_INCREMENT_MAX = 10,
    
    -- Debug settings
    DEBUG_MODE = false,
    DEBUG_CATEGORIES = {
        PATH = true,
        CACHE = true,
        PERFORMANCE = true
    }
}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Initialize persistent data if not already done
_G.LinkedSwordAIPersistentData = _G.LinkedSwordAIPersistentData or {
    -- Core state
    StatusGUI = nil,
    LinkedSword = nil,
    CurrentTarget = nil,
    LastAttackTime = 0,
    
    -- Performance tracking
    PathfindingStats = {
        totalTime = 0,
        callCount = 0,
        maxTime = 0,
        avgTime = 0,
        safeAreaHits = 0,
        voidAreaHits = 0,
        successfulPaths = 0,
        failedPaths = 0
    },
    
    -- Caching systems
    PathCache = {},
    PathCacheCount = 0,
    SpatialPathCache = {},
    SpatialCacheCount = 0,
    ExactCacheHits = 0,
    SpatialCacheHits = 0,
    CacheMisses = 0,
    
    -- Terrain data
    KnownVoidAreas = {},
    VoidAreaHashes = {},
    SafeAreaHashes = {},
    TerrainConnectivityMap = {},
    LastTerrainMapUpdate = 0,
    LastTerrainUpdate = 0,
    
    -- Path calculation
    FailedPaths = {},
    LastPathResult = nil,
    LastPathCalculation = 0,
    
    -- Raycast optimization
    RaycastBatch = {},
    RaycastResults = {},
    LastRaycastBatch = 0,
    
    -- Last cleanup time
    LastCacheCleanup = 0,
    LastStatsReport = 0
}

local persistentData = _G.LinkedSwordAIPersistentData

-- Debug print function
local function debugPrint(category, message)
    if CONFIG.DEBUG_MODE and CONFIG.DEBUG_CATEGORIES[category] then
        print("[" .. category .. "] " .. message)
    end
end

-- Check if an area is void (no ground)
local function IsVoidArea(position, useCache)
    -- Use cache by default if not specified
    if useCache == nil then useCache = true end
    
    -- Check cache first if enabled
    if useCache then
        local hashKey = math.floor(position.X/5) .. "," .. math.floor(position.Z/5)
        if persistentData.VoidAreaHashes[hashKey] then
            return true
        end
        if persistentData.SafeAreaHashes[hashKey] then
            return false
        end
    end
    
    -- Perform raycast to check for ground
    local rayResult = workspace:Raycast(
        position + Vector3.new(0, 3, 0),
        Vector3.new(0, -10, 0)
    )
    
    local isVoid = not rayResult or not rayResult.Instance
    
    -- Cache the result
    if useCache then
        local hashKey = math.floor(position.X/5) .. "," .. math.floor(position.Z/5)
        if isVoid then
            persistentData.VoidAreaHashes[hashKey] = true
            -- Track performance metrics
            persistentData.PathfindingStats.voidAreaHits = (persistentData.PathfindingStats.voidAreaHits or 0) + 1
        else
            persistentData.SafeAreaHashes[hashKey] = true
        end
    end
    
    return isVoid
end

-- Optimized raycast batching system
local function BatchRaycast(raycasts)
    local results = {}
    local currentTime = tick()
    
    -- Process each raycast in the batch
    for i, raycast in ipairs(raycasts) do
        local origin = raycast.origin or raycast[1]
        local direction = raycast.direction or raycast[2]
        local distance = raycast.distance or 1
        
        -- Handle both object and array formats for compatibility
        if not origin or not direction then
            debugPrint("PATH", "Invalid raycast format in BatchRaycast")
            results[i] = nil
            continue
        end
        
        -- Create a unique key for caching
        local raycastKey = tostring(origin.X) .. "," .. tostring(origin.Y) .. "," .. 
                          tostring(origin.Z) .. "," .. tostring(direction.X) .. "," .. 
                          tostring(direction.Y) .. "," .. tostring(direction.Z) .. "," .. 
                          tostring(distance)
        
        -- Check if we have a recent result for this exact raycast
        if persistentData.RaycastResults[raycastKey] and 
           currentTime - persistentData.RaycastResults[raycastKey].time < 1 then
            results[i] = persistentData.RaycastResults[raycastKey].result
        else
            -- Perform actual raycast with proper parameters
            local result = workspace:Raycast(origin, direction.Unit * distance, nil)
            
            -- Store result
            persistentData.RaycastResults[raycastKey] = {
                result = result,
                time = currentTime
            }
            results[i] = result
        end
    end
    
    return results
end

-- Check if an area is a narrow passage
local function IsNarrowPassage(position, direction)
    -- Check for walls on both sides
    local sideOffset1 = direction:Cross(Vector3.new(0, 1, 0)).Unit * 2
    local sideOffset2 = sideOffset1 * -1
    
    local sidePos1 = position + sideOffset1
    local sidePos2 = position + sideOffset2
    
    -- Use BatchRaycast to check both sides efficiently
    local results = BatchRaycast({
        {origin = sidePos1, direction = Vector3.new(0, -5, 0)},
        {origin = sidePos2, direction = Vector3.new(0, -5, 0)}
    })
    
    -- If both sides have obstacles within 3 studs, it's a narrow passage
    local hasWall1 = false
    local hasWall2 = false
    
    if results[1] and results[1].Instance then
        hasWall1 = true
    end
    
    if results[2] and results[2].Instance then
        hasWall2 = true
    end
    
    return hasWall1 and hasWall2
end

-- Map terrain connectivity for more efficient pathfinding
local function UpdateTerrainConnectivityMap(position)
    -- Only update occasionally to save performance
    if not persistentData.LastTerrainMapUpdate or 
       tick() - persistentData.LastTerrainMapUpdate > 5 then
        
        -- Create grid position key
        local gridX = math.floor(position.X / CONFIG.TERRAIN_GRID_SIZE)
        local gridZ = math.floor(position.Z / CONFIG.TERRAIN_GRID_SIZE)
        local gridKey = gridX .. "," .. gridZ
        
        -- Skip if we already mapped this area recently
        if persistentData.TerrainConnectivityMap[gridKey] and 
           tick() - persistentData.TerrainConnectivityMap[gridKey].timestamp < 30 then
            return
        end
        
        -- Map connected terrain in a radius
        local connectedPoints = {}
        local radius = CONFIG.TERRAIN_CONNECTIVITY_RADIUS
        local step = CONFIG.TERRAIN_GRID_SIZE
        
        -- Scan grid points in the area
        for x = -radius, radius, step do
            for z = -radius, radius, step do
                -- Skip points too far away (circular radius)
                if x*x + z*z > radius*radius then
                    continue
                end
                
                -- Check if this point is safe terrain
                local checkPos = Vector3.new(
                    position.X + x,
                    position.Y,
                    position.Z + z
                )
                
                -- Apply throttling to reduce raycast count
                if math.random() <= CONFIG.RAYCAST_THROTTLE_FACTOR then
                    -- Use direct raycast instead of IsVoidArea to avoid circular reference
                    local rayResult = workspace:Raycast(
                        checkPos + Vector3.new(0, 3, 0),
                        Vector3.new(0, -10, 0)
                    )
                    local isVoid = not rayResult or not rayResult.Instance
                    
                    if not isVoid then
                        -- This is safe terrain, add to connected points
                        table.insert(connectedPoints, {
                            position = checkPos,
                            gridX = math.floor(checkPos.X / CONFIG.TERRAIN_GRID_SIZE),
                            gridZ = math.floor(checkPos.Z / CONFIG.TERRAIN_GRID_SIZE)
                        })
                    end
                end
            end
        end
        
        -- Store the connectivity map
        persistentData.TerrainConnectivityMap[gridKey] = {
            center = position,
            points = connectedPoints,
            timestamp = tick()
        }
        
        persistentData.LastTerrainMapUpdate = tick()
        debugPrint("TERRAIN", "Updated terrain connectivity map with " .. #connectedPoints .. " safe points")
    end
end

-- Find bridge path around void areas
local function FindBridgePath(voidPoint, direction)
    -- Try to find a path around the void area
    local perpendicular = direction:Cross(Vector3.new(0, 1, 0)).Unit
    local bridgePoints = {}
    
    -- Try different offsets perpendicular to the direction
    for offset = 5, 20, 5 do
        local leftPoint = voidPoint + perpendicular * offset
        local rightPoint = voidPoint - perpendicular * offset
        
        -- Check if either point is safe
        if not IsVoidArea(leftPoint) then
            table.insert(bridgePoints, leftPoint)
        end
        
        if not IsVoidArea(rightPoint) then
            table.insert(bridgePoints, rightPoint)
        end
    end
    
    -- Return the closest safe point if any
    if #bridgePoints > 0 then
        return bridgePoints[1]
    end
    
    return nil
end

-- Find alternative path when direct path fails
local function FindAlternativePath(startPos, targetPos)
    local direction = (targetPos - startPos).Unit
    local perpendicular = direction:Cross(Vector3.new(0, 1, 0)).Unit
    local alternatives = {}
    
    -- Try different angles
    for i = 1, CONFIG.ALTERNATIVE_PATH_COUNT do
        local angle = (i / CONFIG.ALTERNATIVE_PATH_COUNT) * math.pi * 2
        local rotatedDir = CFrame.fromAxisAngle(Vector3.new(0, 1, 0), angle) * direction
        
        local checkDistance = (targetPos - startPos).Magnitude * 0.5
        local checkPos = startPos + rotatedDir * checkDistance
        
        if not IsVoidArea(checkPos) then
            table.insert(alternatives, {
                position = checkPos,
                score = (checkPos - targetPos).Magnitude -- Lower is better
            })
        end
    end
    
    -- Sort by score (closest to target)
    table.sort(alternatives, function(a, b) return a.score < b.score end)
    
    if #alternatives > 0 then
        return alternatives[1].position
    end
    
    return nil
end

-- Check if path to target is safe (no voids)
local function IsSafePath(targetPosition, character)
    if not character then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not humanoidRootPart then return false end
    
    -- Start performance tracking
    local startTime = tick()
    persistentData.CacheMisses = (persistentData.CacheMisses or 0)
    
    -- Apply adaptive path calculation throttling based on performance metrics
    local throttleFactor = CONFIG.PATH_CALCULATION_THROTTLE
    if persistentData.PathfindingStats and persistentData.PathfindingStats.callCount > 10 then
        -- Adjust throttle based on average calculation time
        local avgTime = persistentData.PathfindingStats.totalTime / persistentData.PathfindingStats.callCount
        if avgTime > 0.01 then -- If calculations are taking more than 10ms
            throttleFactor = math.min(0.5, throttleFactor) -- More aggressive throttling
        end
    end
    
    if throttleFactor < 1 and math.random() > throttleFactor then
        -- Use last known result or default to safe for throttled calculations
        local lastResult = persistentData.LastPathResult or {safe = true, bridgePath = nil, alternativePath = nil}
        return lastResult.safe, lastResult.bridgePath, lastResult.alternativePath
    end
    
    -- Advanced caching: Check proximity cache first for ultra-fast lookups
    -- This uses a spatial grid system for constant-time lookups
    local currentTime = tick()
    local gridSize = CONFIG.SPATIAL_GRID_SIZE
    local gridX = math.floor(targetPosition.X / gridSize)
    local gridY = math.floor(targetPosition.Y / gridSize)
    local gridZ = math.floor(targetPosition.Z / gridSize)
    local spatialKey = gridX .. ":" .. gridY .. ":" .. gridZ
    
    -- Check spatial grid cache first (fastest lookup)
    if persistentData.SpatialPathCache and persistentData.SpatialPathCache[spatialKey] then
        local spatialData = persistentData.SpatialPathCache[spatialKey]
        if currentTime - spatialData.time < CONFIG.SPATIAL_CACHE_TIME then
            -- Update access time for LRU tracking
            spatialData.lastAccess = currentTime
            persistentData.SpatialCacheHits = (persistentData.SpatialCacheHits or 0) + 1
            persistentData.LastPathResult = spatialData
            
            -- Track performance
            local elapsedTime = tick() - startTime
            persistentData.PathfindingStats.totalTime = persistentData.PathfindingStats.totalTime + elapsedTime
            
            return spatialData.safe, spatialData.bridgePath, spatialData.alternativePath
        end
    end
    
    -- Performance optimization: Check exact cache using hash-based lookup
    if CONFIG.PERFORMANCE_MODE then
        -- Create a hash key for faster lookup (rounded to nearest unit)
        local hashKey = math.floor(targetPosition.X) .. "," .. 
                       math.floor(targetPosition.Y) .. "," .. 
                       math.floor(targetPosition.Z)
        
        local data = persistentData.PathCache[hashKey]
        if data and currentTime - data.time < CONFIG.PATH_CACHE_TIME then
            -- Update access time for LRU tracking
            data.lastAccess = currentTime
            persistentData.ExactCacheHits = (persistentData.ExactCacheHits or 0) + 1
            debugPrint("PATH", "Using cached path result: " .. (data.safe and "SAFE" or "UNSAFE"))
            persistentData.LastPathResult = data
            
            -- Also update spatial cache for future proximity lookups
            if not persistentData.SpatialPathCache then
                persistentData.SpatialPathCache = {}
            end
            persistentData.SpatialPathCache[spatialKey] = {
                safe = data.safe,
                time = currentTime,
                lastAccess = currentTime,
                bridgePath = data.bridgePath,
                alternativePath = data.alternativePath
            }
            
            -- Track performance
            local elapsedTime = tick() - startTime
            persistentData.PathfindingStats.totalTime = persistentData.PathfindingStats.totalTime + elapsedTime
            
            return data.safe, data.bridgePath, data.alternativePath
        end
    end
    
    -- Cache miss tracking
    persistentData.CacheMisses = persistentData.CacheMisses + 1
    
    -- Performance metrics: Track calculation frequency
    persistentData.PathfindingStats.callCount = persistentData.PathfindingStats.callCount + 1
    
    -- Check if target is in a known safe terrain area from connectivity map
    local gridX = math.floor(targetPosition.X / CONFIG.TERRAIN_GRID_SIZE)
    local gridZ = math.floor(targetPosition.Z / CONFIG.TERRAIN_GRID_SIZE)
    local gridKey = gridX .. "," .. gridZ
    
    if persistentData.TerrainConnectivityMap[gridKey] then
        local mapData = persistentData.TerrainConnectivityMap[gridKey]
        -- If map is recent and has connected points, check if target is in a safe area
        if tick() - mapData.timestamp < 30 and #mapData.points > 0 then
            -- Find closest point in connectivity map
            local minDist = math.huge
            local isSafe = false
            
            for _, point in ipairs(mapData.points) do
                local dist = (point.position - targetPosition).Magnitude
                if dist < minDist then
                    minDist = dist
                    -- If point is very close, consider it safe
                    if dist < CONFIG.TERRAIN_GRID_SIZE * 1.5 then
                        isSafe = true
                        break
                    end
                end
            end
            
            if isSafe then
                debugPrint("PATH", "Target in known safe terrain area")
                -- Cache this result
                if CONFIG.PERFORMANCE_MODE then
                    local hashKey = math.floor(targetPosition.X) .. "," .. 
                                   math.floor(targetPosition.Y) .. "," .. 
                                   math.floor(targetPosition.Z)
                    
                    persistentData.PathCache[hashKey] = {
                        safe = true,
                        time = tick(),
                        lastAccess = tick(),
                        bridgePath = nil,
                        alternativePath = nil
                    }
                    persistentData.LastPathResult = persistentData.PathCache[hashKey]
                    
                    -- Update spatial cache too for future proximity lookups
                    if not persistentData.SpatialPathCache then
                        persistentData.SpatialPathCache = {}
                    end
                    persistentData.SpatialPathCache[spatialKey] = persistentData.PathCache[hashKey]
                    
                    -- Track performance metrics
                    persistentData.PathfindingStats.safeAreaHits = (persistentData.PathfindingStats.safeAreaHits or 0) + 1
                    persistentData.PathfindingStats.successfulPaths = (persistentData.PathfindingStats.successfulPaths or 0) + 1
                end
                return true, nil, nil
            end
        end
    end
    
    -- Check if this path has failed recently using a more efficient approach
    local failedPathsCount = #persistentData.FailedPaths
    if failedPathsCount > 0 then
        -- Check most recent failed paths first (more likely to be relevant)
        for i = failedPathsCount, math.max(1, failedPathsCount - 3), -1 do
            local failedPath = persistentData.FailedPaths[i]
            if failedPath and (targetPosition - failedPath.position).Magnitude < 5 and 
               tick() - failedPath.time < 10 then
                -- Store this result for throttled calculations
                persistentData.LastPathResult = {safe = false, bridgePath = nil, alternativePath = nil}
                persistentData.PathfindingStats.failedPaths = (persistentData.PathfindingStats.failedPaths or 0) + 1
                return false
            end
        end
    end
    
    local startPos = humanoidRootPart.Position
    local direction = (targetPosition - startPos).Unit
    local distance = (targetPosition - startPos).Magnitude
    
    -- Update terrain connectivity map for current position
    -- This helps build a map of safe terrain for future pathfinding
    UpdateTerrainConnectivityMap(startPos)
    
    -- Check if we're in a narrow passage
    local isNarrow = IsNarrowPassage(startPos, direction)
    
    -- If in narrow passage, use more careful pathfinding
    if isNarrow then
        -- Use smaller increments for narrow passages
        local narrowIncrement = math.min(2, distance / 8)
        
        for i = narrowIncrement, distance, narrowIncrement do
            local checkPos = startPos + direction * i
            
            -- Check for walls on both sides
            if not IsNarrowPassage(checkPos, direction) then
                -- We've exited the narrow passage, check if it's safe
                if IsVoidArea(checkPos) then
                    if #persistentData.FailedPaths >= 10 then
                        table.remove(persistentData.FailedPaths, 1)
                    end
                    table.insert(persistentData.FailedPaths, {
                        position = targetPosition,
                        time = tick()
                    })
                    
                    -- Cache the result with hash key
                    if CONFIG.PERFORMANCE_MODE then
                        local hashKey = math.floor(targetPosition.X) .. "," .. 
                                       math.floor(targetPosition.Y) .. "," .. 
                                       math.floor(targetPosition.Z)
                        
                        persistentData.PathCache[hashKey] = {
                            safe = false,
                            time = tick(),
                            lastAccess = tick(),
                            bridgePath = nil,
                            alternativePath = nil
                        }
                        persistentData.LastPathResult = persistentData.PathCache[hashKey]
                        persistentData.PathfindingStats.failedPaths = (persistentData.PathfindingStats.failedPaths or 0) + 1
                    end
                    
                    return false
                end
            end
        end
    end
    
    -- Use adaptive path increments based on distance
    local increment = math.max(
        CONFIG.ADAPTIVE_INCREMENT_MIN,
        math.min(CONFIG.ADAPTIVE_INCREMENT_MAX, distance / 10)
    )
    
    -- Batch process raycast checks for better performance
    local checkPoints = {}
    for i = increment, distance, increment do
        local checkPos = startPos + direction * i
        table.insert(checkPoints, {
            position = checkPos,
            index = i
        })
    end
    
    -- Check in batches of 5 for better performance
    local batchSize = 5
    for i = 1, #checkPoints, batchSize do
        local batch = {}
        for j = i, math.min(i + batchSize - 1, #checkPoints) do
            local checkPos = checkPoints[j].position
            if IsVoidArea(checkPos) then
                -- Found a void, path is not safe
                if #persistentData.FailedPaths >= 10 then
                    table.remove(persistentData.FailedPaths, 1)
                end
                table.insert(persistentData.FailedPaths, {
                    position = targetPosition,
                    time = tick()
                })
                
                -- Cache the result
                if CONFIG.PERFORMANCE_MODE then
                    local hashKey = math.floor(targetPosition.X) .. "," .. 
                                   math.floor(targetPosition.Y) .. "," .. 
                                   math.floor(targetPosition.Z)
                    
                    persistentData.PathCache[hashKey] = {
                        safe = false,
                        time = tick(),
                        lastAccess = tick(),
                        bridgePath = nil,
                        alternativePath = nil
                    }
                    persistentData.LastPathResult = persistentData.PathCache[hashKey]
                    persistentData.PathfindingStats.failedPaths = (persistentData.PathfindingStats.failedPaths or 0) + 1
                end
                
                -- Try to find bridge path
                local bridgePath = FindBridgePath(checkPos, direction)
                if bridgePath then
                    return false, bridgePath, nil
                end
                
                -- Try to find alternative path
                local alternativePath = FindAlternativePath(startPos, targetPosition)
                if alternativePath then
                    return false, nil, alternativePath
                end
                
                return false
            end
        end
    end
    
    -- Path is safe, cache the result
    if CONFIG.PERFORMANCE_MODE then
        local hashKey = math.floor(targetPosition.X) .. "," .. 
                       math.floor(targetPosition.Y) .. "," .. 
                       math.floor(targetPosition.Z)
        
        persistentData.PathCache[hashKey] = {
            safe = true,
            time = tick(),
            lastAccess = tick(),
            bridgePath = nil,
            alternativePath = nil
        }
        persistentData.LastPathResult = persistentData.PathCache[hashKey]
        
        -- Update spatial cache too for future proximity lookups
        if not persistentData.SpatialPathCache then
            persistentData.SpatialPathCache = {}
        end
        persistentData.SpatialPathCache[spatialKey] = persistentData.PathCache[hashKey]
        
        -- Update terrain connectivity map with this safe path
        local gridX = math.floor(targetPosition.X / CONFIG.TERRAIN_GRID_SIZE)
        local gridZ = math.floor(targetPosition.Z / CONFIG.TERRAIN_GRID_SIZE)
        local gridKey = gridX .. "," .. gridZ
        
        if not persistentData.TerrainConnectivityMap[gridKey] then
            persistentData.TerrainConnectivityMap[gridKey] = {
                center = targetPosition,
                points = {{
                    position = targetPosition,
                    gridX = gridX,
                    gridZ = gridZ
                }},
                timestamp = tick()
            }
        end
        
        -- Track performance metrics
        persistentData.PathfindingStats.successfulPaths = (persistentData.PathfindingStats.successfulPaths or 0) + 1
    end
    
    -- Track performance
    local endTime = tick()
    local elapsedTime = endTime - startTime
    persistentData.PathfindingStats.totalTime = persistentData.PathfindingStats.totalTime + elapsedTime
    if elapsedTime > persistentData.PathfindingStats.maxTime then
        persistentData.PathfindingStats.maxTime = elapsedTime
    end
    persistentData.PathfindingStats.avgTime = persistentData.PathfindingStats.totalTime / persistentData.PathfindingStats.callCount
    
    return true, nil, nil
end

-- Find valid target
local function FindTarget(character)
    if not character then 
        debugPrint("PATH", "FindTarget: No character provided")
        return nil 
    end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not humanoid then
        debugPrint("PATH", "FindTarget: No Humanoid found in character")
        return nil
    end
    
    if not humanoidRootPart then
        debugPrint("PATH", "FindTarget: No HumanoidRootPart found in character")
        return nil
    end
    
    local nearestDistance = CONFIG.DETECTION_RADIUS
    local nearestPlayer = nil
    
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character ~= character then
            local playerHumanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local playerRoot = player.Character:FindFirstChild("HumanoidRootPart")
            
            if playerHumanoid and playerRoot and playerHumanoid.Health > 0 then
                -- Use pcall to handle potential errors with Position property
                local success, distance = pcall(function()
                    return (playerRoot.Position - humanoidRootPart.Position).Magnitude
                end)
                
                if not success then
                    debugPrint("PATH", "Error calculating distance: " .. tostring(distance))
                    continue
                end
                
                if distance < nearestDistance then
                    -- Check if path to player is safe
                    local isSafe, _, _ = IsSafePath(playerRoot.Position, character)
                    
                    if isSafe then
                        nearestDistance = distance
                        nearestPlayer = player
                    end
                end
            end
        end
    end
    
    return nearestPlayer
end

-- Attack target
local function AttackTarget(target, character)
    if not target or not target.Character or not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not humanoidRootPart then return end
    
    local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return end
    
    -- Use pcall to handle potential errors with Position property
    local success, distance = pcall(function()
        return (targetRoot.Position - humanoidRootPart.Position).Magnitude
    end)
    
    if not success then
        debugPrint("PATH", "Error calculating attack distance: " .. tostring(distance))
        return
    end
    
    if distance <= CONFIG.ATTACK_RANGE then
        -- Only attack if cooldown has passed
        if tick() - persistentData.LastAttackTime >= CONFIG.ATTACK_COOLDOWN then
            -- Perform attack
            if persistentData.LinkedSword and persistentData.LinkedSword.Attack then
                persistentData.LinkedSword:Attack()
                persistentData.LastAttackTime = tick()
            end
        end
    else
        -- Move towards target
        humanoid:MoveTo(targetRoot.Position)
    end
end

-- Report performance metrics
local function ReportPerformanceMetrics()
    debugPrint("PERF", "--- Performance Metrics ---")
    debugPrint("PERF", "Pathfinding Calls: " .. persistentData.PathfindingStats.callCount)
    debugPrint("PERF", "Successful Paths: " .. persistentData.PathfindingStats.successfulPaths)
    debugPrint("PERF", "Failed Paths: " .. persistentData.PathfindingStats.failedPaths)
    debugPrint("PERF", "Safe Area Hits: " .. persistentData.PathfindingStats.safeAreaHits)
    debugPrint("PERF", "Total Pathfinding Time: " .. string.format("%.4f", persistentData.PathfindingStats.totalTime) .. "s")
    debugPrint("PERF", "Average Pathfinding Time: " .. string.format("%.4f", persistentData.PathfindingStats.avgTime) .. "s")
    debugPrint("PERF", "Max Pathfinding Time: " .. string.format("%.4f", persistentData.PathfindingStats.maxTime) .. "s")
    debugPrint("PERF", "Cache Misses: " .. persistentData.CacheMisses)
    debugPrint("PERF", "Spatial Cache Hits: " .. (persistentData.SpatialCacheHits or 0))
    debugPrint("PERF", "Exact Cache Hits: " .. (persistentData.ExactCacheHits or 0))
    debugPrint("PERF", "Raycast Cache Hits: " .. (persistentData.RaycastCacheHits or 0))
    debugPrint("PERF", "Raycast Cache Misses: " .. (persistentData.RaycastCacheMisses or 0))
    debugPrint("PERF", "Terrain Map Updates: " .. (persistentData.TerrainMapUpdates or 0))
    debugPrint("PERF", "-------------------------")
    
    -- Reset stats periodically if needed
    if CONFIG.RESET_STATS_PERIODICALLY then
        persistentData.PathfindingStats.callCount = 0
        persistentData.PathfindingStats.successfulPaths = 0
        persistentData.PathfindingStats.failedPaths = 0
        persistentData.PathfindingStats.safeAreaHits = 0
        persistentData.PathfindingStats.totalTime = 0
        persistentData.PathfindingStats.avgTime = 0
        persistentData.PathfindingStats.maxTime = 0
        persistentData.CacheMisses = 0
        persistentData.SpatialCacheHits = 0
        persistentData.ExactCacheHits = 0
        persistentData.RaycastCacheHits = 0
        persistentData.RaycastCacheMisses = 0
        persistentData.TerrainMapUpdates = 0
    end
end

-- Cleanup caches (LRU based)
local function CleanupCaches()
    local currentTime = tick()
    
    -- Clean up PathCache
    local pathCacheEntries = {}
    for hashKey, data in pairs(persistentData.PathCache) do
        table.insert(pathCacheEntries, {key = hashKey, data = data})
    end
    
    table.sort(pathCacheEntries, function(a, b)
        return a.data.lastAccess < b.data.lastAccess
    end)
    
    for i = 1, math.max(0, #pathCacheEntries - CONFIG.MAX_PATH_CACHE_SIZE) do
        persistentData.PathCache[pathCacheEntries[i].key] = nil
    end
    
    -- Clean up SpatialPathCache
    local spatialCacheEntries = {}
    for spatialKey, data in pairs(persistentData.SpatialPathCache) do
        table.insert(spatialCacheEntries, {key = spatialKey, data = data})
    end
    
    table.sort(spatialCacheEntries, function(a, b)
        return a.data.lastAccess < b.data.lastAccess
    end)
    
    for i = 1, math.max(0, #spatialCacheEntries - CONFIG.MAX_SPATIAL_CACHE_SIZE) do
        persistentData.SpatialPathCache[spatialCacheEntries[i].key] = nil
    end
    
    -- Clean up RaycastCache
    local raycastCacheEntries = {}
    for key, data in pairs(persistentData.RaycastCache) do
        table.insert(raycastCacheEntries, {key = key, data = data})
    end
    
    table.sort(raycastCacheEntries, function(a, b)
        return a.data.lastAccess < b.data.lastAccess
    end)
    
    for i = 1, math.max(0, #raycastCacheEntries - CONFIG.MAX_RAYCAST_CACHE_SIZE) do
        persistentData.RaycastCache[raycastCacheEntries[i].key] = nil
    end
    
    -- Clean up TerrainConnectivityMap (older entries)
    for key, data in pairs(persistentData.TerrainConnectivityMap) do
        if currentTime - data.timestamp > CONFIG.TERRAIN_MAP_EXPIRATION_TIME then
            persistentData.TerrainConnectivityMap[key] = nil
        end
    end
end

-- Main update loop for AI
local function Update(character)
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not humanoidRootPart then return end
    
    -- Periodic cache cleanup
    if tick() - persistentData.LastCacheCleanupTime > CONFIG.CACHE_CLEANUP_INTERVAL then
        CleanupCaches()
        persistentData.LastCacheCleanupTime = tick()
    end
    
    -- Periodically update terrain connectivity map for current position
    if tick() - persistentData.LastTerrainMapUpdateTime > CONFIG.TERRAIN_MAP_UPDATE_INTERVAL then
        UpdateTerrainConnectivityMap(humanoidRootPart.Position)
        persistentData.LastTerrainMapUpdateTime = tick()
    end
    
    -- Find target
    local targetPlayer = FindTarget(character)
    
    if targetPlayer then
        local targetRoot = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if targetRoot then
            -- Check if path is safe before moving or attacking
            local isSafe, bridgePath, alternativePath = IsSafePath(targetRoot.Position, character)
            
            if isSafe then
                AttackTarget(targetPlayer, character)
            else
                -- Path is not safe, try to use bridge or alternative path
                if bridgePath then
                    humanoid:MoveTo(bridgePath)
                    debugPrint("PATH", "Moving to bridge path")
                elseif alternativePath then
                    humanoid:MoveTo(alternativePath)
                    debugPrint("PATH", "Moving to alternative path")
                else
                    -- If no alternative, try to find a new path or wait
                    debugPrint("PATH", "No safe path or alternative found, waiting...")
                    humanoid:MoveTo(humanoidRootPart.Position) -- Stop movement
                end
            end
        end
    else
        -- No target, wander or stand still
        humanoid:MoveTo(humanoidRootPart.Position) -- Stand still
    end
    
    -- Report performance metrics periodically
    if tick() - persistentData.LastPerformanceReportTime > CONFIG.PERFORMANCE_REPORT_INTERVAL then
        ReportPerformanceMetrics()
        persistentData.LastPerformanceReportTime = tick()
    end
end

-- Initialization function
local function Initialize(character)
    debugPrint("INIT", "Initializing LinkedSwordAI...")
    
    -- Get the LinkedSword instance
    persistentData.LinkedSword = character:FindFirstChild("LinkedSword") -- Assuming the sword is a child of the character
    if not persistentData.LinkedSword then
        warn("LinkedSwordAI: LinkedSword not found in character!")
        return
    end
    
    -- Connect to RunService.Stepped for AI updates
    game:GetService("RunService").Stepped:Connect(function()
        Update(character)
    end)
    
    debugPrint("INIT", "LinkedSwordAI Initialized.")
end

return {
    Initialize = Initialize,
    Update = Update,
    ReportPerformanceMetrics = ReportPerformanceMetrics,
    CleanupCaches = CleanupCaches,
    IsSafePath = IsSafePath,
    FindTarget = FindTarget,
    AttackTarget = AttackTarget,
    IsVoidArea = IsVoidArea,
    IsNarrowPassage = IsNarrowPassage,
    UpdateTerrainConnectivityMap = UpdateTerrainConnectivityMap,
    BatchRaycast = BatchRaycast
}
