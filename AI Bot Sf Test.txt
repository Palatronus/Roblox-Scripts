--[[
    Linked Sword AI Combat Script with Garbage Collection
    Brand new implementation with all original functions + memory optimization
]]

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- Configuration
local CONFIG = {
    DETECTION_RADIUS = 200,
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.7,
    LUNGE_DELAY = 0.1,
    STUCK_CHECK_DISTANCE = 1.5,
    STUCK_CHECK_TIME = 1.0,
    MAX_TARGET_DISTANCE = 250,
    MIN_HEALTH_CHECK = 0,
    RETARGET_CHECK_TIME = 1.5,
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -100,
    FORCEFIELD_FLEE_DISTANCE = 0,
    SWORD_CHECK_INTERVAL = 7,
    RESPAWN_EQUIP_DELAY = 1.5,
    MOVEMENT_MEMORY_TIME = 0.7,
    SAFE_GAP_DISTANCE = 10,
    PATH_SMOOTHING_FACTOR = 0.7,
    MOVEMENT_RETRY_DELAY = 1.0,
    NARROW_PASSAGE_WIDTH = 3.5,
    PATHFINDING_STEPS = 10,
    COMBAT_BEHAVIOR_CHANGE_TIME = 4.0,
    COMBAT_DEFENSIVE_CHANCE = 0.25,
    COMBAT_OFFENSIVE_CHANCE = 0.45,
    STRAFE_DISTANCE = 4,
    BRIDGE_CHECK_DISTANCE = 25,
    PERFORMANCE_MODE = true,
    PATH_CACHE_TIME = 3.0,
    ALTERNATIVE_PATH_COUNT = 4,
    MIN_ATTACK_DISTANCE = 3
}

-- Garbage Collection Configuration
local GC_CONFIG = {
    ENABLED = true,
    COLLECTION_INTERVAL = 30,
    AGGRESSIVE_THRESHOLD_MB = 100,
    MAX_CACHE_ENTRIES = 20,
    MAX_HISTORY_ENTRIES = 30,
}

-- Global persistent data
if not _G.LinkedSwordAIData then
    _G.LinkedSwordAIData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {},
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        MovementHistory = {},
        FailedPaths = {},
        LastEquipAttempt = 0,
        EquipmentReady = false,
        KnownVoidAreas = {},
        PathCache = {},
        LastPathfindingTime = 0,
        PerformanceStats = {
            PathfindingTime = 0,
            CombatTime = 0,
            MovementTime = 0,
            LastOptimizationTime = 0,
            MemoryUsage = 0,
            GarbageCollections = 0,
            LastGCTime = 0,
        },
        AlternativePaths = {},
        CurrentCombatBehavior = nil,
        LastBehaviorChangeTime = 0,
        GarbageCollector = {
            LastCollectionTime = 0,
            IsRunning = false
        }
    }
end

local data = _G.LinkedSwordAIData

-- Initialize missing tables
if not data.FailedPaths then data.FailedPaths = {} end
if not data.KnownVoidAreas then data.KnownVoidAreas = {} end
if not data.MovementHistory then data.MovementHistory = {} end
if not data.PathCache then data.PathCache = {} end
if not data.AlternativePaths then data.AlternativePaths = {} end
if not data.PlayersWithForceField then data.PlayersWithForceField = {} end
if not data.GarbageCollector then data.GarbageCollector = {LastCollectionTime = 0, IsRunning = false} end

-- Debug functions
local function debugPrint(category, message)
    print("[LinkedSwordAI][" .. category .. "] " .. message)
end

local function forcePrint(...)
    local args = {...}
    local message = table.concat(args, " ")
    print("[LinkedSwordAI] " .. message)
end

-- Garbage Collection System
local function GetMemoryUsage()
    return collectgarbage("count") / 1024
end

local function RunGarbageCollection()
    if not GC_CONFIG.ENABLED or data.GarbageCollector.IsRunning then
        return
    end
    
    data.GarbageCollector.IsRunning = true
    local startTime = tick()
    local cleaned = 0
    
    debugPrint("GC", "Starting garbage collection...")
    
    -- Clean PathCache
    local currentTime = tick()
    for key, cacheData in pairs(data.PathCache) do
        if currentTime - (cacheData.time or 0) > CONFIG.PATH_CACHE_TIME then
            data.PathCache[key] = nil
            cleaned = cleaned + 1
        end
    end
    
    -- Clean FailedPaths
    while #data.FailedPaths > GC_CONFIG.MAX_CACHE_ENTRIES do
        table.remove(data.FailedPaths, 1)
        cleaned = cleaned + 1
    end
    
    -- Clean KnownVoidAreas
    while #data.KnownVoidAreas > GC_CONFIG.MAX_CACHE_ENTRIES do
        table.remove(data.KnownVoidAreas, 1)
        cleaned = cleaned + 1
    end
    
    -- Clean MovementHistory
    while #data.MovementHistory > GC_CONFIG.MAX_HISTORY_ENTRIES do
        table.remove(data.MovementHistory, 1)
        cleaned = cleaned + 1
    end
    
    -- Clean AlternativePaths
    for key, pathData in pairs(data.AlternativePaths) do
        if currentTime - (pathData.lastUsed or 0) > 60 then
            data.AlternativePaths[key] = nil
            cleaned = cleaned + 1
        end
    end
    
    -- Clean player cache
    local validPlayers = {}
    for playerName, player in pairs(data.PlayersWithForceField) do
        if player and player.Parent then
            validPlayers[playerName] = player
        else
            cleaned = cleaned + 1
        end
    end
    data.PlayersWithForceField = validPlayers
    
    -- Aggressive cleanup if memory is high
    if data.PerformanceStats.MemoryUsage > GC_CONFIG.AGGRESSIVE_THRESHOLD_MB then
        debugPrint("GC", "High memory detected, running aggressive cleanup")
        data.PathCache = {}
        data.AlternativePaths = {}
        collectgarbage("collect")
        cleaned = cleaned + 50
    end
    
    data.GarbageCollector.LastCollectionTime = tick()
    data.GarbageCollector.IsRunning = false
    data.PerformanceStats.GarbageCollections = (data.PerformanceStats.GarbageCollections or 0) + 1
    data.PerformanceStats.LastGCTime = tick()
    
    debugPrint("GC", string.format("Cleaned %d objects in %.2fs", cleaned, tick() - startTime))
end

local function CheckGarbageCollection()
    local currentTime = tick()
    if currentTime - data.GarbageCollector.LastCollectionTime > GC_CONFIG.COLLECTION_INTERVAL then
        RunGarbageCollection()
    end
end

-- Status GUI
local function CreateStatusGUI()
    local gui = {}
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "LinkedSwordAI_Status"
    screenGui.Parent = game:GetService("CoreGui")
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 120)
    frame.Position = UDim2.new(0.8, 0, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.5
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    frame.Parent = screenGui
    
    local status = Instance.new("TextLabel")
    status.Size = UDim2.new(1, -10, 0, 20)
    status.Position = UDim2.new(0, 5, 0, 5)
    status.BackgroundTransparency = 1
    status.TextColor3 = Color3.fromRGB(255, 255, 255)
    status.Text = "Status: Initializing..."
    status.Font = Enum.Font.SourceSans
    status.TextSize = 14
    status.TextXAlignment = Enum.TextXAlignment.Left
    status.Parent = frame
    
    local target = Instance.new("TextLabel")
    target.Size = UDim2.new(1, -10, 0, 20)
    target.Position = UDim2.new(0, 5, 0, 30)
    target.BackgroundTransparency = 1
    target.TextColor3 = Color3.fromRGB(255, 150, 150)
    target.Text = "Target: None"
    target.Font = Enum.Font.SourceSans
    target.TextSize = 14
    target.TextXAlignment = Enum.TextXAlignment.Left
    target.Parent = frame
    
    local distance = Instance.new("TextLabel")
    distance.Size = UDim2.new(1, -10, 0, 20)
    distance.Position = UDim2.new(0, 5, 0, 55)
    distance.BackgroundTransparency = 1
    distance.TextColor3 = Color3.fromRGB(150, 255, 150)
    distance.Text = "Distance: N/A"
    distance.Font = Enum.Font.SourceSans
    distance.TextSize = 14
    distance.TextXAlignment = Enum.TextXAlignment.Left
    distance.Parent = frame
    
    local debug = Instance.new("TextLabel")
    debug.Size = UDim2.new(1, -10, 0, 20)
    debug.Position = UDim2.new(0, 5, 0, 80)
    debug.BackgroundTransparency = 1
    debug.TextColor3 = Color3.fromRGB(255, 255, 0)
    debug.Text = "Debug: Starting..."
    debug.Font = Enum.Font.SourceSans
    debug.TextSize = 14
    debug.TextXAlignment = Enum.TextXAlignment.Left
    debug.Parent = frame
    
    function gui.UpdateStatus(text)
        status.Text = "Status: " .. text
    end
    
    function gui.UpdateTarget(text)
        target.Text = "Target: " .. text
    end
    
    function gui.UpdateDistance(dist)
        distance.Text = "Distance: " .. (dist and string.format("%.1f", dist) or "N/A")
    end
    
    function gui.UpdateDebug(text)
        debug.Text = "Debug: " .. text
    end
    
    function gui.Destroy()
        screenGui:Destroy()
    end
    
    return gui
end

-- Main AI Functions
local function FindLinkedSword(character, localPlayer)
    if data.SwordToolName then
        local storedSword = character:FindFirstChild(data.SwordToolName)
        if storedSword and storedSword:IsA("Tool") then
            return storedSword
        end
        
        local backpack = localPlayer:FindFirstChild("Backpack")
        if backpack then
            storedSword = backpack:FindFirstChild(data.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                return storedSword
            end
        end
    end
    
    for _, tool in pairs(character:GetChildren()) do
        if tool:IsA("Tool") and string.lower(tool.Name):find("sword") then
            data.SwordToolName = tool.Name
            return tool
        end
    end
    
    local backpack = localPlayer:FindFirstChild("Backpack")
    if backpack then
        for _, tool in pairs(backpack:GetChildren()) do
            if tool:IsA("Tool") and string.lower(tool.Name):find("sword") then
                data.SwordToolName = tool.Name
                return tool
            end
        end
    end
    
    return nil
end

local function CheckForSword(character, localPlayer)
    local currentTime = tick()
    if currentTime - data.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
        if not data.LinkedSword or data.LinkedSword.Parent ~= character then
            data.LinkedSword = FindLinkedSword(character, localPlayer)
        end
        data.LastSwordCheckTime = currentTime
    end
end

local function FindPlayersInRange(humanoidRootPart)
    local playersInRange = {}
    local localPlayer = Players.LocalPlayer
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character then
            local character = player.Character
            local humanoid = character:FindFirstChild("Humanoid")
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            
            if humanoid and rootPart and humanoid.Health > CONFIG.MIN_HEALTH_CHECK then
                local distance = (rootPart.Position - humanoidRootPart.Position).Magnitude
                
                if distance <= CONFIG.DETECTION_RADIUS then
                    local hasForceField = false
                    for _, child in pairs(character:GetChildren()) do
                        if child:IsA("ForceField") then
                            hasForceField = true
                            data.PlayersWithForceField[player.Name] = player
                            break
                        end
                    end
                    
                    if not hasForceField and data.PlayersWithForceField[player.Name] then
                        data.PlayersWithForceField[player.Name] = nil
                    end
                    
                    table.insert(playersInRange, {
                        player = player,
                        distance = distance,
                        hasForceField = hasForceField
                    })
                end
            end
        end
    end
    
    table.sort(playersInRange, function(a, b)
        return a.distance < b.distance
    end)
    
    return playersInRange
end

local function IsVoidArea(position, character)
    for _, voidPos in ipairs(data.KnownVoidAreas) do
        if (position - voidPos).Magnitude < 5 then
            return true
        end
    end
    
    if position.Y < CONFIG.VOID_Y_THRESHOLD then
        if #data.KnownVoidAreas < 50 then
            table.insert(data.KnownVoidAreas, position)
        else
            table.remove(data.KnownVoidAreas, 1)
            table.insert(data.KnownVoidAreas, position)
        end
        return true
    end
    
    local ray = Ray.new(position, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
    local hit = Workspace:FindPartOnRay(ray, character)
    
    if not hit then
        if #data.KnownVoidAreas < 50 then
            table.insert(data.KnownVoidAreas, position)
        else
            table.remove(data.KnownVoidAreas, 1)
            table.insert(data.KnownVoidAreas, position)
        end
        return true
    end
    
    return false
end

local function IsSafeGap(startPos, endPos, character)
    local distance = (endPos - startPos).Magnitude
    
    if distance < 3 then
        return not IsVoidArea(endPos, character)
    end
    
    if distance < CONFIG.SAFE_GAP_DISTANCE then
        local ray = Ray.new(endPos, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
        local hit = Workspace:FindPartOnRay(ray, character)
        return hit ~= nil
    end
    
    local direction = (endPos - startPos).Unit
    local checkCount = math.ceil(distance / 2)
    
    for i = 1, checkCount do
        local checkPoint = startPos + direction * (i * 2)
        local ray = Ray.new(checkPoint, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
        local hit = Workspace:FindPartOnRay(ray, character)
        
        if not hit then
            return false
        end
    end
    
    return true
end

local function IsNarrowPassage(position, direction, character)
    local leftRay = Ray.new(position, direction:Cross(Vector3.new(0, 1, 0)).Unit * CONFIG.NARROW_PASSAGE_WIDTH)
    local rightRay = Ray.new(position, direction:Cross(Vector3.new(0, 1, 0)).Unit * -CONFIG.NARROW_PASSAGE_WIDTH)
    
    local leftHit = Workspace:FindPartOnRay(leftRay, character)
    local rightHit = Workspace:FindPartOnRay(rightRay, character)
    
    return leftHit and rightHit
end

local function FindBridgePath(startPos, endPos, character)
    local direction = (endPos - startPos).Unit
    local distance = (endPos - startPos).Magnitude
    
    for dist = 5, math.min(CONFIG.BRIDGE_CHECK_DISTANCE, distance), 5 do
        local checkPoint = startPos + direction * dist
        
        for y = 0, -20, -2 do
            local bridgeCheckPoint = checkPoint + Vector3.new(0, y, 0)
            local ray = Ray.new(bridgeCheckPoint, Vector3.new(0, -5, 0))
            local hit, hitPos = Workspace:FindPartOnRay(ray, character)
            
            if hit then
                local bridgePath = hitPos + Vector3.new(0, 3, 0)
                if IsSafeGap(startPos, bridgePath, character) then
                    return bridgePath
                end
            end
        end
    end
    
    return nil
end

local function IsSafePath(targetPosition, humanoidRootPart, character)
    if CONFIG.PERFORMANCE_MODE then
        local currentTime = tick()
        local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
        
        local cacheData = data.PathCache[hashKey]
        if cacheData and currentTime - cacheData.time < CONFIG.PATH_CACHE_TIME then
            return cacheData.safe, cacheData.bridgePath, cacheData.alternativePath
        end
    end
    
    local startPos = humanoidRootPart.Position
    local direction = (targetPosition - startPos).Unit
    local distance = (targetPosition - startPos).Magnitude
    
    local isNarrow = IsNarrowPassage(startPos, direction, character)
    
    if isNarrow then
        local narrowIncrement = math.min(2, distance / 8)
        
        for i = narrowIncrement, distance, narrowIncrement do
            local checkPos = startPos + direction * i
            
            if not IsNarrowPassage(checkPos, direction, character) then
                if IsVoidArea(checkPos, character) then
                    if #data.FailedPaths >= 10 then
                        table.remove(data.FailedPaths, 1)
                    end
                    table.insert(data.FailedPaths, {position = targetPosition, time = tick()})
                    
                    if CONFIG.PERFORMANCE_MODE then
                        data.PathCache[targetPosition] = {safe = false, time = tick()}
                    end
                    
                    return false
                end
                break
            end
        end
    else
        local increment = math.min(5, distance / 5)
        
        for i = increment, distance, increment do
            local checkPos = startPos + direction * i
            if IsVoidArea(checkPos, character) then
                local bridgePath = FindBridgePath(startPos, targetPosition, character)
                if bridgePath then
                    if CONFIG.PERFORMANCE_MODE then
                        data.PathCache[targetPosition] = {safe = true, time = tick(), bridgePath = bridgePath}
                    end
                    return true, bridgePath
                end
                
                for altIndex = 1, CONFIG.ALTERNATIVE_PATH_COUNT do
                    local angle = altIndex * (math.pi / CONFIG.ALTERNATIVE_PATH_COUNT)
                    local altDirection = CFrame.fromAxisAngle(Vector3.new(0, 1, 0), angle) * direction
                    local altTargetPos = startPos + altDirection * (distance * 0.5)
                    
                    local altSafe = true
                    for j = increment, distance * 0.5, increment do
                        local altCheckPos = startPos + altDirection * j
                        if IsVoidArea(altCheckPos, character) then
                            altSafe = false
                            break
                        end
                    end
                    
                    if altSafe then
                        data.AlternativePaths[targetPosition] = {position = altTargetPos, lastUsed = tick()}
                        return false, nil, altTargetPos
                    end
                end
                
                if #data.FailedPaths >= 10 then
                    table.remove(data.FailedPaths, 1)
                end
                table.insert(data.FailedPaths, {position = targetPosition, time = tick()})
                return false
            end
        end
    end
    
    if IsVoidArea(targetPosition, character) then
        if #data.FailedPaths >= 10 then
            table.remove(data.FailedPaths, 1)
        end
        table.insert(data.FailedPaths, {position = targetPosition, time = tick()})
        return false
    end
    
    if CONFIG.PERFORMANCE_MODE then
        data.PathCache[targetPosition] = {safe = true, time = tick()}
    end
    
    return true
end

local function CheckIfStuck(humanoidRootPart)
    if not data.LastStuckPosition then
        data.LastStuckPosition = humanoidRootPart.Position
        data.LastStuckTime = tick()
        return false
    end
    
    local currentTime = tick()
    if currentTime - data.LastStuckTime > CONFIG.STUCK_CHECK_TIME then
        local distance = (humanoidRootPart.Position - data.LastStuckPosition).Magnitude
        
        if distance < CONFIG.STUCK_CHECK_DISTANCE then
            data.IsStuck = true
            return true
        end
        
        data.LastStuckPosition = humanoidRootPart.Position
        data.LastStuckTime = currentTime
    end
    
    return false
end

local function HandleStuckOnPlayer(humanoidRootPart, humanoid, character)
    local directions = {
        Vector3.new(1, 0, 0), Vector3.new(-1, 0, 0), Vector3.new(0, 0, 1), Vector3.new(0, 0, -1),
        Vector3.new(1, 0, 1).Unit, Vector3.new(-1, 0, 1).Unit, Vector3.new(1, 0, -1).Unit, Vector3.new(-1, 0, -1).Unit
    }
    
    for _, direction in ipairs(directions) do
        local targetPosition = humanoidRootPart.Position + direction * 5
        if IsSafePath(targetPosition, humanoidRootPart, character) then
            humanoid:MoveTo(targetPosition)
            return true
        end
    end
    
    return false
end

local function MoveTo(targetPosition, humanoidRootPart, humanoid, character, bridgePath, alternativePath)
    if bridgePath then
        targetPosition = bridgePath
    end
    
    if alternativePath then
        targetPosition = alternativePath
    end
    
    local currentDirection = (targetPosition - humanoidRootPart.Position).Unit
    local currentTime = tick()
    
    local smoothedDirection = currentDirection
    if data.LastMovementDirection and currentTime - data.LastMovementTime < CONFIG.MOVEMENT_MEMORY_TIME then
        smoothedDirection = (data.LastMovementDirection * CONFIG.PATH_SMOOTHING_FACTOR + currentDirection * (1 - CONFIG.PATH_SMOOTHING_FACTOR)).Unit
    end
    
    local smoothedTarget = humanoidRootPart.Position + smoothedDirection * math.min(5, (targetPosition - humanoidRootPart.Position).Magnitude)
    
    if IsNarrowPassage(humanoidRootPart.Position, smoothedDirection, character) then
        smoothedDirection = currentDirection
        smoothedTarget = humanoidRootPart.Position + smoothedDirection * math.min(2, (targetPosition - humanoidRootPart.Position).Magnitude)
    end
    
    if IsSafeGap(humanoidRootPart.Position, smoothedTarget, character) then
        data.LastMovementDirection = smoothedDirection
        data.LastMovementTime = currentTime
        humanoid:MoveTo(smoothedTarget)
        return true
    end
    
    return false
end

local function ExecuteAttack(humanoidRootPart)
    if not data.LinkedSword or data.AttackSequenceActive then
        return
    end
    
    data.AttackSequenceActive = true
    data.LastAttackTime = tick()
    
    if not data.CurrentCombatBehavior or tick() - data.LastBehaviorChangeTime > CONFIG.COMBAT_BEHAVIOR_CHANGE_TIME then
        local rand = math.random()
        if rand < CONFIG.COMBAT_DEFENSIVE_CHANCE then
            data.CurrentCombatBehavior = "defensive"
        elseif rand < CONFIG.COMBAT_DEFENSIVE_CHANCE + CONFIG.COMBAT_OFFENSIVE_CHANCE then
            data.CurrentCombatBehavior = "offensive"
        else
            data.CurrentCombatBehavior = "offensive-defensive"
        end
        data.LastBehaviorChangeTime = tick()
    end
    
    if data.CurrentTarget and data.CurrentTarget.Character then
        local targetHRP = data.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        if targetHRP then
            humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, Vector3.new(targetHRP.Position.X, humanoidRootPart.Position.Y, targetHRP.Position.Z))
        end
    end
    
    spawn(function()
        if data.CurrentCombatBehavior == "defensive" then
            data.LinkedSword:Activate()
            wait(CONFIG.LUNGE_DELAY * 1.2)
            data.LinkedSword:Activate()
            wait(CONFIG.LUNGE_DELAY * 1.5)
            data.LinkedSword:Activate()
            
        elseif data.CurrentCombatBehavior == "offensive" then
            data.LinkedSword:Activate()
            wait(CONFIG.LUNGE_DELAY * 0.6)
            data.LinkedSword:Activate()
            wait(CONFIG.LUNGE_DELAY * 0.7)
            data.LinkedSword:Activate()
            
        else
            data.LinkedSword:Activate()
            wait(CONFIG.LUNGE_DELAY)
            data.LinkedSword:Activate()
            wait(CONFIG.LUNGE_DELAY)
            data.LinkedSword:Activate()
        end
        
        wait(0.2)
        data.AttackSequenceActive = false
    end)
end

-- Main AI Loop
local function InitializeAI()
    local localPlayer = Players.LocalPlayer
    if not localPlayer then return false end
    
    -- Wait for character
    if not localPlayer.Character then
        localPlayer.CharacterAdded:Wait()
    end
    
    local character = localPlayer.Character
    local humanoid = character:WaitForChild("Humanoid")
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    -- Create GUI
    if not data.StatusGUI then
        data.StatusGUI = CreateStatusGUI()
    end
    
    -- Find sword
    data.LinkedSword = FindLinkedSword(character, localPlayer)
    data.LastSwordCheckTime = tick()
    
    -- Equip sword
    spawn(function()
        wait(CONFIG.RESPAWN_EQUIP_DELAY)
        if data.LinkedSword and data.LinkedSword.Parent ~= character then
            data.LinkedSword.Parent = character
        end
    end)
    
    -- Main update function
    local updateConnection
    updateConnection = RunService.Heartbeat:Connect(function()
        -- Update memory usage
        data.PerformanceStats.MemoryUsage = GetMemoryUsage()
        
        -- Check garbage collection
        CheckGarbageCollection()
        
        -- Check for sword
        CheckForSword(character, localPlayer)
        
        -- Find targets
        local currentTime = tick()
        local needNewTarget = not data.CurrentTarget or not data.CurrentTarget.Character
        local checkForCloser = currentTime - data.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME
        
        if needNewTarget or checkForCloser then
            local playersInRange = FindPlayersInRange(humanoidRootPart)
            
            if #playersInRange > 0 then
                local newTarget = playersInRange[1].player
                if newTarget ~= data.CurrentTarget then
                    data.CurrentTarget = newTarget
                    if data.StatusGUI then
                        data.StatusGUI.UpdateTarget(newTarget.Name)
                        data.StatusGUI.UpdateStatus("Targeting " .. newTarget.Name)
                    end
                end
            else
                data.CurrentTarget = nil
                if data.StatusGUI then
                    data.StatusGUI.UpdateTarget("None")
                    data.StatusGUI.UpdateStatus("No targets")
                end
            end
            
            data.LastRetargetTime = currentTime
        end
        
        -- Process target
        if data.CurrentTarget and data.CurrentTarget.Character then
            local targetCharacter = data.CurrentTarget.Character
            local targetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")
            local targetHumanoid = targetCharacter:FindFirstChild("Humanoid")
            
            if targetHRP and targetHumanoid and targetHumanoid.Health > 0 then
                local distance = (targetHRP.Position - humanoidRootPart.Position).Magnitude
                
                if data.StatusGUI then
                    data.StatusGUI.UpdateDistance(distance)
                end
                
                -- Check if stuck
                if CheckIfStuck(humanoidRootPart) then
                    HandleStuckOnPlayer(humanoidRootPart, humanoid, character)
                    return
                else
                    data.IsStuck = false
                end
                
                -- Check path safety
                local isSafe, bridgePath, alternativePath = IsSafePath(targetHRP.Position, humanoidRootPart, character)
                
                if isSafe then
                    MoveTo(targetHRP.Position, humanoidRootPart, humanoid, character, bridgePath)
                    humanoidRootPart.CFrame = CFrame.lookAt(humanoidRootPart.Position, Vector3.new(targetHRP.Position.X, humanoidRootPart.Position.Y, targetHRP.Position.Z))
                    
                    if distance <= CONFIG.ATTACK_RANGE and data.LinkedSword and currentTime - data.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        ExecuteAttack(humanoidRootPart)
                    elseif distance <= CONFIG.MIN_ATTACK_DISTANCE and data.LinkedSword and currentTime - data.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        data.CurrentCombatBehavior = "offensive"
                        ExecuteAttack(humanoidRootPart)
                    end
                    
                elseif alternativePath then
                    MoveTo(alternativePath, humanoidRootPart, humanoid, character)
                    humanoidRootPart.CFrame = CFrame.lookAt(humanoidRootPart.Position, Vector3.new(targetHRP.Position.X, humanoidRootPart.Position.Y, targetHRP.Position.Z))
                    
                    if distance <= CONFIG.ATTACK_RANGE and data.LinkedSword and currentTime - data.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        ExecuteAttack(humanoidRootPart)
                    end
                else
                    local bridgePath = FindBridgePath(humanoidRootPart.Position, targetHRP.Position, character)
                    if bridgePath then
                        MoveTo(bridgePath, humanoidRootPart, humanoid, character)
                    end
                end
            end
        else
            if data.StatusGUI then
                data.StatusGUI.UpdateStatus("Idle")
            end
        end
    end)
    
    -- Handle respawn
    localPlayer.CharacterAdded:Connect(function(newCharacter)
        if updateConnection then
            updateConnection:Disconnect()
        end
        
        if data.StatusGUI then
            data.StatusGUI.Destroy()
            data.StatusGUI = nil
        end
        
        wait(1)
        InitializeAI()
    end)
    
    if data.StatusGUI then
        data.StatusGUI.UpdateStatus("AI Running")
    end
    
    forcePrint("LinkedSwordAI initialized successfully")
    return true
end

-- Start the AI
local success, error = pcall(InitializeAI)
if not success then
    forcePrint("Error initializing AI: " .. tostring(error))
end
