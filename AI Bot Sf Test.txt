[file name]: AI Bot Sf Prototypes_PerformanceOptimized.txt
[file content begin]
--[[
    Linked Sword AI Combat Script (Performance Optimized Version)
    
    Major performance optimizations to eliminate FPS drops during extended gameplay.
    Focused on reducing console spam, optimizing memory usage, and improving frame timing.
]]--

-- Optimized logging with severe throttling
local LOG_THROTTLE = {
    lastPrintTime = 0,
    printInterval = 5, -- Only allow prints every 5 seconds
    messageQueue = {},
    enabled = false -- Disable most logging during normal operation
}

local function throttledPrint(...)
    if not LOG_THROTTLE.enabled then return end
    
    local currentTime = tick()
    if currentTime - LOG_THROTTLE.lastPrintTime > LOG_THROTTLE.printInterval then
        local message = table.concat({...}, " ")
        print("[LinkedSwordAI] " .. message)
        LOG_THROTTLE.lastPrintTime = currentTime
    end
end

-- Critical errors only (not throttled)
local function criticalError(...)
    local message = table.concat({...}, " ")
    print("[LinkedSwordAI-CRITICAL] " .. message)
end

-- Global persistent data with aggressive memory optimization
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {}, -- Using table for O(1) lookups
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        MovementHistory = {}, -- Limited to 5 entries
        FailedPaths = {}, -- Limited size with expiration
        LastEquipAttempt = 0,
        EquipmentReady = false,
        KnownVoidAreas = {}, -- Very limited size
        PathCache = {}, -- Simple cache with manual cleanup
        LastPathfindingTime = 0,
        PerformanceStats = {
            PathfindingTime = 0,
            CombatTime = 0,
            MovementTime = 0,
            LastOptimizationTime = 0,
            FrameTimes = {}, -- Track frame performance
            SkipFrames = 0
        },
        AlternativePaths = {}, -- Minimal storage
        UpdateConnection = nil,
        LastGUIRefresh = 0,
        FrameCounter = 0,
        LastPlayerCheck = 0,
        CachedPlayersInRange = {}
    }
end

local persistentData = _G.LinkedSwordAIPersistentData

-- Performance-focused configuration
local CONFIG = {
    -- Core gameplay (unchanged)
    DETECTION_RADIUS = 200,
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.7,
    LUNGE_DELAY = 0.1,
    MAX_TARGET_DISTANCE = 250,
    
    -- Performance optimizations
    PERFORMANCE_MODE = true,
    ENABLE_LOGGING = false, -- DISABLED: Critical for FPS improvement
    MAX_FAILED_PATHS = 5, -- Reduced from 10
    MAX_VOID_AREAS = 20, -- Reduced from 50
    PATH_CACHE_MAX_SIZE = 10, -- Reduced cache size
    MEMORY_CLEANUP_INTERVAL = 10, -- More frequent cleanup
    FRAME_TIME_THRESHOLD = 0.033, -- Target 30fps (more conservative)
    
    -- Throttled intervals
    GUI_UPDATE_INTERVAL = 0.5, -- Reduced GUI updates
    PLAYER_CHECK_INTERVAL = 0.3, -- Check players less frequently
    PATHFINDING_INTERVAL = 0.2, -- Pathfinding throttle
    SWORD_CHECK_INTERVAL = 10, -- Reduced sword checks
    RETARGET_CHECK_TIME = 2.0, -- Less frequent retargeting
    
    -- Aggressive frame skipping
    MAX_CONSECUTIVE_SKIPS = 3,
    FRAME_SKIP_THRESHOLD = 0.025, -- Skip if frame time > 25ms
    
    -- Simplified algorithms
    USE_SIMPLE_PATHFINDING = true,
    DISABLE_COMPLEX_RAYCASTS = true,
    MINIMUM_OPERATIONS = true
}

-- Enable logging only for initial setup
LOG_THROTTLE.enabled = CONFIG.ENABLE_LOGGING

-- Optimized table management
local TablePool = {
    playerArrays = {},
    vectorArrays = {}
}

local function getPlayerArray()
    if #TablePool.playerArrays > 0 then
        return table.remove(TablePool.playerArrays)
    end
    return {}
end

local function returnPlayerArray(tbl)
    for k in pairs(tbl) do
        tbl[k] = nil
    end
    if #TablePool.playerArrays < 5 then
        TablePool.playerArrays[#TablePool.playerArrays + 1] = tbl
    end
end

-- Memory optimization with aggressive cleanup
local function aggressiveMemoryCleanup()
    if not CONFIG.PERFORMANCE_MODE then return end
    
    local startTime = tick()
    
    -- Clean up failed paths (aggressive)
    local currentTime = tick()
    local i = 1
    while i <= #persistentData.FailedPaths do
        if currentTime - persistentData.FailedPaths[i].time > 10 then -- Reduced from 20
            table.remove(persistentData.FailedPaths, i)
        else
            i = i + 1
        end
    end
    
    -- Limit table sizes aggressively
    if #persistentData.FailedPaths > CONFIG.MAX_FAILED_PATHS then
        local removeCount = #persistentData.FailedPaths - CONFIG.MAX_FAILED_PATHS
        for i = 1, removeCount do
            table.remove(persistentData.FailedPaths, 1)
        end
    end
    
    if #persistentData.KnownVoidAreas > CONFIG.MAX_VOID_AREAS then
        local removeCount = #persistentData.KnownVoidAreas - CONFIG.MAX_VOID_AREAS
        for i = 1, removeCount do
            table.remove(persistentData.KnownVoidAreas, 1)
        end
    end
    
    if #persistentData.MovementHistory > 5 then
        local removeCount = #persistentData.MovementHistory - 5
        for i = 1, removeCount do
            table.remove(persistentData.MovementHistory, 1)
        end
    end
    
    -- Clean path cache
    local cacheKeys = {}
    for k in pairs(persistentData.PathCache) do
        cacheKeys[#cacheKeys + 1] = k
    end
    if #cacheKeys > CONFIG.PATH_CACHE_MAX_SIZE then
        table.sort(cacheKeys, function(a, b)
            return (persistentData.PathCache[a].time or 0) < (persistentData.PathCache[b].time or 0)
        end)
        for i = 1, #cacheKeys - CONFIG.PATH_CACHE_MAX_SIZE do
            persistentData.PathCache[cacheKeys[i]] = nil
        end
    end
    
    -- Force garbage collection less frequently to avoid hitches
    if tick() - persistentData.PerformanceStats.LastOptimizationTime > 30 then
        collectgarbage("step", 200) -- Incremental GC instead of full collection
        persistentData.PerformanceStats.MemoryUsage = collectgarbage("count")
    end
    
    persistentData.PerformanceStats.LastOptimizationTime = tick()
end

-- Performance monitoring without console spam
local performanceMonitor = {
    frameCount = 0,
    lastReportTime = tick(),
    averageFrameTime = 0,
    maxFrameTime = 0,
    skipCounter = 0
}

local function updatePerformanceMonitor(frameTime)
    performanceMonitor.frameCount = performanceMonitor.frameCount + 1
    
    if performanceMonitor.frameCount >= 60 then
        performanceMonitor.averageFrameTime = (tick() - performanceMonitor.lastReportTime) / performanceMonitor.frameCount
        performanceMonitor.maxFrameTime = math.max(performanceMonitor.maxFrameTime, performanceMonitor.averageFrameTime)
        
        performanceMonitor.frameCount = 0
        performanceMonitor.lastReportTime = tick()
    end
end

-- Frame skipping logic
local function shouldSkipFrame()
    if not CONFIG.PERFORMANCE_MODE then return false end
    
    local currentTime = tick()
    local frameTime = currentTime - performanceMonitor.lastReportTime
    
    -- Skip if we're consistently running slow
    if performanceMonitor.averageFrameTime > CONFIG.FRAME_TIME_THRESHOLD then
        performanceMonitor.skipCounter = performanceMonitor.skipCounter + 1
        if performanceMonitor.skipCounter <= CONFIG.MAX_CONSECUTIVE_SKIPS then
            persistentData.PerformanceStats.SkipFrames = persistentData.PerformanceStats.SkipFrames + 1
            return true
        end
    else
        performanceMonitor.skipCounter = 0
    end
    
    return false
end

-- Minimal status GUI (only if absolutely necessary)
local function CreateMinimalStatusGUI()
    if not CONFIG.PERFORMANCE_MODE then return nil end
    
    local success, result = pcall(function()
        local parent = game:GetService("CoreGui")
        if not parent then return nil end
        
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "LinkedSwordAI_Status"
        screenGui.Parent = parent
        screenGui.ResetOnSpawn = false
        screenGui.Enabled = false -- Start disabled to save resources
        
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(0, 150, 0, 60) -- Smaller GUI
        frame.Position = UDim2.new(0.85, 0, 0.05, 0)
        frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        frame.BackgroundTransparency = 0.7
        frame.BorderSizePixel = 0 -- No border to save rendering
        frame.Parent = screenGui
        
        local statusLabel = Instance.new("TextLabel")
        statusLabel.Size = UDim2.new(1, -5, 1, -5)
        statusLabel.Position = UDim2.new(0, 5, 0, 5)
        statusLabel.BackgroundTransparency = 1
        statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        statusLabel.Text = "AI: Active"
        statusLabel.Font = Enum.Font.SourceSans
        statusLabel.TextSize = 12 -- Smaller text
        statusLabel.TextXAlignment = Enum.TextXAlignment.Left
        statusLabel.Parent = frame
        
        local gui = {
            screenGui = screenGui,
            statusLabel = statusLabel,
            lastUpdate = 0
        }
        
        function gui.UpdateStatus(text)
            if tick() - gui.lastUpdate > 2.0 then -- Update every 2 seconds max
                gui.statusLabel.Text = "AI: " .. (text or "Active")
                gui.lastUpdate = tick()
            end
        end
        
        function gui.SetEnabled(enabled)
            gui.screenGui.Enabled = enabled
        end
        
        return gui
    end)
    
    return success and result or nil
end

-- Main execution with performance safeguards
local function InitializeAI()
    -- Services
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    
    -- Get player and character with minimal checks
    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        criticalError("LocalPlayer not found")
        return false
    end
    
    throttledPrint("Initializing for player: " .. LocalPlayer.Name)
    
    local Character = LocalPlayer.Character
    if not Character then
        criticalError("Character not found")
        return false
    end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    
    if not Humanoid or not HumanoidRootPart then
        criticalError("Humanoid components not found")
        return false
    end
    
    -- Clean up previous connection
    if persistentData.UpdateConnection then
        persistentData.UpdateConnection:Disconnect()
        persistentData.UpdateConnection = nil
    end
    
    -- Create minimal GUI only if needed
    if not persistentData.StatusGUI and CONFIG.PERFORMANCE_MODE then
        persistentData.StatusGUI = CreateMinimalStatusGUI()
        if persistentData.StatusGUI then
            persistentData.StatusGUI.SetEnabled(false) -- Keep disabled by default
        end
    end
    
    -- Optimized sword finding
    local function FindLinkedSword()
        -- Quick check with cached name
        if persistentData.SwordToolName then
            local sword = Character:FindFirstChild(persistentData.SwordToolName)
            if sword and sword:IsA("Tool") then return sword end
            
            sword = LocalPlayer.Backpack:FindFirstChild(persistentData.SwordToolName)
            if sword and sword:IsA("Tool") then return sword end
        end
        
        -- Quick scan without verbose logging
        for _, tool in ipairs(Character:GetChildren()) do
            if tool:IsA("Tool") and string.find(tool.Name, "Sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        
        for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and string.find(tool.Name, "Sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        
        return nil
    end
    
    -- Optimized sword checking with longer intervals
    local function CheckForSword()
        local currentTime = tick()
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword = FindLinkedSword()
            end
            persistentData.LastSwordCheckTime = currentTime
        end
    end
    
    -- Highly optimized player detection
    local function FindPlayersInRange()
        local currentTime = tick()
        
        -- Use cached results if recent
        if currentTime - persistentData.LastPlayerCheck < CONFIG.PLAYER_CHECK_INTERVAL then
            return persistentData.CachedPlayersInRange
        end
        
        local playersInRange = getPlayerArray()
        local myPosition = HumanoidRootPart.Position
        
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                
                if humanoid and humanoidRootPart and humanoid.Health > 0 then
                    local distance = (humanoidRootPart.Position - myPosition).Magnitude
                    
                    if distance <= CONFIG.DETECTION_RADIUS then
                        playersInRange[#playersInRange + 1] = {
                            player = player,
                            distance = distance
                        }
                    end
                end
            end
        end
        
        -- Simple distance-based sorting (only if we have players)
        if #playersInRange > 1 then
            table.sort(playersInRange, function(a, b)
                return a.distance < b.distance
            end)
        end
        
        -- Update cache
        if #persistentData.CachedPlayersInRange > 0 then
            returnPlayerArray(persistentData.CachedPlayersInRange)
        end
        persistentData.CachedPlayersInRange = playersInRange
        persistentData.LastPlayerCheck = currentTime
        
        return playersInRange
    end
    
    -- Simplified void checking (major performance gain)
    local function IsVoidArea(position)
        -- Simple Y-check only (removed complex raycasts)
        if position.Y < -50 then -- Simplified threshold
            return true
        end
        
        -- Check against known void areas (limited)
        for i, voidPos in ipairs(persistentData.KnownVoidAreas) do
            if (position - voidPos).Magnitude < 10 then
                return true
            end
        end
        
        return false
    end
    
    -- Ultra-simplified path checking
    local function IsSafePath(targetPosition)
        if not CONFIG.PERFORMANCE_MODE then
            return true -- Fallback for non-performance mode
        end
        
        local currentTime = tick()
        
        -- Throttle pathfinding checks
        if currentTime - persistentData.LastPathfindingTime < CONFIG.PATHFINDING_INTERVAL then
            return true -- Assume safe to avoid computation
        end
        
        local startPos = HumanoidRootPart.Position
        local distance = (targetPosition - startPos).Magnitude
        
        -- Simple distance check
        if distance > CONFIG.DETECTION_RADIUS then
            return false
        end
        
        -- Check only start and end points (removed intermediate checks)
        if IsVoidArea(targetPosition) then
            -- Remember failed path (simplified)
            if #persistentData.FailedPaths >= CONFIG.MAX_FAILED_PATHS then
                table.remove(persistentData.FailedPaths, 1)
            end
            persistentData.FailedPaths[#persistentData.FailedPaths + 1] = {
                position = targetPosition,
                time = currentTime
            }
            return false
        end
        
        persistentData.LastPathfindingTime = currentTime
        return true
    end
    
    -- Simplified movement function
    local function SimpleMoveTo(targetPosition)
        if IsSafePath(targetPosition) then
            Humanoid:MoveTo(targetPosition)
            return true
        end
        return false
    end
    
    -- Simplified attack function
    local function ExecuteSimpleAttack()
        if not persistentData.LinkedSword or persistentData.AttackSequenceActive then
            return
        end
        
        persistentData.AttackSequenceActive = true
        persistentData.LastAttackTime = tick()
        
        -- Face target quickly
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character then
            local targetHRP = persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
            if targetHRP then
                HumanoidRootPart.CFrame = CFrame.lookAt(
                    HumanoidRootPart.Position, 
                    Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
                )
            end
        end
        
        -- Simple attack sequence
        spawn(function()
            pcall(function() 
                if persistentData.LinkedSword then
                    persistentData.LinkedSword:Activate() 
                end
            end)
            wait(0.1)
            persistentData.AttackSequenceActive = false
        end)
    end
    
    -- Highly optimized main update function
    local function OptimizedUpdate()
        persistentData.FrameCounter = persistentData.FrameCounter + 1
        
        -- Skip frame if performance requires it
        if shouldSkipFrame() then
            return
        end
        
        local updateStart = tick()
        
        -- Memory cleanup on interval
        if tick() - persistentData.PerformanceStats.LastOptimizationTime > CONFIG.MEMORY_CLEANUP_INTERVAL then
            aggressiveMemoryCleanup()
        end
        
        -- Throttled operations
        if persistentData.FrameCounter % 30 == 0 then -- Check sword every 30 frames
            CheckForSword()
        end
        
        -- Target acquisition (throttled)
        local currentTime = tick()
        local needRetarget = not persistentData.CurrentTarget or 
                           currentTime - persistentData.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME
        
        if needRetarget then
            local playersInRange = FindPlayersInRange()
            
            if #playersInRange > 0 then
                local newTarget = playersInRange[1].player
                if newTarget ~= persistentData.CurrentTarget then
                    persistentData.CurrentTarget = newTarget
                    if persistentData.StatusGUI then
                        persistentData.StatusGUI.UpdateStatus("Targeting")
                    end
                end
            else
                persistentData.CurrentTarget = nil
            end
            
            persistentData.LastRetargetTime = currentTime
        end
        
        -- Target processing (minimal operations)
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character then
            local targetHRP = persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
            if targetHRP then
                local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
                
                -- Simple movement and combat
                if distance <= CONFIG.MAX_TARGET_DISTANCE then
                    SimpleMoveTo(targetHRP.Position)
                    
                    if distance <= CONFIG.ATTACK_RANGE and persistentData.LinkedSword and 
                       currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        ExecuteSimpleAttack()
                    end
                end
            end
        end
        
        -- Update performance monitor
        updatePerformanceMonitor(tick() - updateStart)
    end
    
    -- Equipment handling
    spawn(function()
        wait(2.0) -- Longer delay for stability
        persistentData.LinkedSword = FindLinkedSword()
        if persistentData.LinkedSword and persistentData.LinkedSword.Parent ~= Character then
            persistentData.LinkedSword.Parent = Character
            persistentData.EquipmentReady = true
        end
    end)
    
    -- Initialize
    persistentData.LinkedSword = FindLinkedSword()
    persistentData.LastSwordCheckTime = tick()
    
    -- Optimized connection with error handling
    persistentData.UpdateConnection = RunService.Heartbeat:Connect(function()
        local success, error = pcall(OptimizedUpdate)
        if not success and CONFIG.ENABLE_LOGGING then
            criticalError("Update error: " .. tostring(error))
        end
    end)
    
    -- Character respawn handling
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        if persistentData.UpdateConnection then
            persistentData.UpdateConnection:Disconnect()
            persistentData.UpdateConnection = nil
        end
        
        wait(2.0) -- Longer delay for stability
        InitializeAI()
    end)
    
    throttledPrint("Performance-optimized AI initialized")
    return true
end

-- Startup with performance safeguards
local success, errorMsg = pcall(function()
    -- Disable logging after initial setup
    spawn(function()
        wait(10) -- Keep logging enabled for 10 seconds after startup
        LOG_THROTTLE.enabled = false
        if persistentData.StatusGUI then
            persistentData.StatusGUI.SetEnabled(false) -- Disable GUI to save resources
        end
    end)
    
    InitializeAI()
end)

if not success then
    criticalError("Initialization failed: " .. tostring(errorMsg))
end
[file content end]
