--[[
stella comment

claude thinks ur gonna put the code in an npc game script~!! >w<
forcing print is not needed, this aint a terminal~ :3
roblox already has a gc, ur just gonna tell the gc what to collect~
ehehehehehehehehehe~~
]]

--[[ 
	Linked Sword AI Combat Script (Enhanced Version)
	Implemented improvements per user request:
	- Adaptive periodic garbage collection
	- Expanded safe pathfinding (16 alternatives)
	- Continuous movement & smooth path transitions
	- ForceField proximity detection + fleeing/evasion
	- Offensive-defensive sword combat with strafing and deceptive lunges
	- Transparent platform avoidance + intelligent jumping
	- Faster, robust respawn/equip logic
	Based on original prototype file: AI Bot Sf Prototypes :contentReference[oaicite:1]{index=1}
--]]

local DEBUG = true

sethiddenproperty(workspace, "PathfindingUseImprovedSearch", "Enabled")

local function debugPrint(category, ...)
	if not DEBUG then return end
	print("[Linked Sword AI][" .. category .. "] " .. table.concat({...}, " "))
end

debugPrint("INIT", "Initializing...")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")

-- Configuration (tweak these values for tuning)
local CONFIG = {
	DETECTION_RADIUS = 200,
	ATTACK_RANGE = 15,
	IMMEDIATE_ATTACK_RADIUS = 8,
	SWORD_NAME = "Sword",
	BLOCKED_TIME_PATHFIND = 0.1,
	AGENT_CLEAR_PATHFIND_OFFSET = Vector3.new(2048, 0, 0),
	HEALING_PAD_POSITION = Vector3.new(-124, 256, 4),
}

-- Get Player
local LocalPlayer = nil
repeat
	LocalPlayer = Players.LocalPlayer
	task.wait()
until LocalPlayer

-- Safe Get Tool (tries backpack and character)
local function GetTool(name)
	local char = LocalPlayer.Character
	if char then
		for _,v in char:GetChildren() do
			if v:IsA("Tool") and v.Name == name then
				return v
			end
		end
	end
	local back = LocalPlayer:FindFirstChildOfClass("Backpack")
	if back then
		for _,v in back:GetChildren() do
			if v:IsA("Tool") and v.Name == name then
				return v
			end
		end
	end
	return nil
end

-- Part Pathfinding Modifier util
local function SetPartPathfindModification(part, avoid)
	local partpfm = part:FindFirstChild("PathfindingPart")
	if partpfm == nil then
		partpfm = Instance.new("Part", part)
		partpfm.Name = "PathfindingPart"
		partpfm.Transparency = 1
		partpfm.Anchored = true
	end
	partpfm.CFrame = part.CFrame + CONFIG.AGENT_CLEAR_PATHFIND_OFFSET
	if part.Name == "PhantomPlate" then
		partpfm.Size = part.Size + Vector3.new(1.5, 0, 1.5)
	else
		partpfm.Size = part.Size - Vector3.new(0.2, 0, 0.2)
	end
	local pfm = partpfm:FindFirstChildOfClass("PathfindingModifier")
	if pfm == nil then
		pfm = Instance.new("PathfindingModifier", partpfm)
	end
	if avoid then
		pfm.Label = "AIVoid"
		partpfm.CanCollide = false
	else
		pfm.Label = "AIWalk"
		partpfm.CanCollide = true
	end
	pfm.PassThrough = false
end

-- Debugging
local DebugWireframingPart = Instance.new("Part", workspace)
DebugWireframingPart.Transparency = 1
DebugWireframingPart.Anchored = true
DebugWireframingPart.CanCollide = false
DebugWireframingPart.Name = "DEBUG"
DebugWireframingPart.CFrame = CFrame.identity
local DebugWireframing = Instance.new("WireframeHandleAdornment")
DebugWireframing.Color3 = Color3.new(0, 1, 0)
DebugWireframing.Adornee = DebugWireframingPart
DebugWireframing.Parent = DebugWireframingPart
DebugWireframing.AlwaysOnTop = true
DebugWireframing.Name = "DEBUG"

local function CreateDot(pos)
	local p = {}
	for i=1, 32 do
		local x = (i / 8) * math.pi * 2
		local y = (i / 32) * math.pi
		table.insert(p, pos + Vector3.new(
			math.cos(x) * math.sin(y),
			math.cos(y),
			math.sin(x) * math.sin(y)
		) * 0.2)
	end
	DebugWireframing:AddPath(p, true)
end
local function CreateLine(a, b)
	DebugWireframing:AddLine(a, b)
end

local AgentParts = {}
for _, v in workspace:GetDescendants() do
	if v:IsA("BasePart") then
		if v:IsGrounded() then
			table.insert(AgentParts, v)
		end
	end
end

-- Agent Pathfinding
local Agent = PathfindingService:CreatePath({
	AgentRadius = 2.49,
	AgentHeight = 5,
	AgentCanJump = true,
	WaypointSpacing = 1,
	Costs = {
		AIWalk = 1,
		AIVoid = math.huge,
	}
})
local function AgentComputeAsync(start, finish)
	Agent:ComputeAsync(start + CONFIG.AGENT_CLEAR_PATHFIND_OFFSET, finish + CONFIG.AGENT_CLEAR_PATHFIND_OFFSET)
end
local function AgentGetWaypoints()
	local w = {}
	for _,v in Agent:GetWaypoints() do
		table.insert(w, {
			Position = v.Position + Vector3.new(0, 3, 0) - CONFIG.AGENT_CLEAR_PATHFIND_OFFSET,
			Action = v.Action,
			Label = v.Label
		})
	end
	return w
end
local AgentWaypoints = {}
local AgentWaypointIndex = 1
local AgentBlocked = false
local AgentPathfindForce = false
local AgentCalculating = false
local AgentStart = Vector3.zero
local AgentFinish = Vector3.zero
local function AgentPathfind()
	if AgentCalculating then return end
	AgentCalculating = true
	task.spawn(function()
		debugPrint("PF", "Computing path...")
		pcall(AgentComputeAsync, AgentStart, AgentFinish)
		AgentWaypoints = AgentGetWaypoints()
		AgentWaypointIndex = 1
		AgentBlocked = false
		debugPrint("PF", `Generated {#AgentWaypoints} of waypoints!`)
		task.wait()
		task.wait()
		AgentCalculating = false
	end)
end

local IsPathfinding = false
local BlockedTime = 0
task.spawn(function()
	local s, f = AgentStart, AgentFinish
	while true do
		task.wait(1)
		if IsPathfinding then
			if AgentPathfindForce or #AgentWaypoints <= 2 or s ~= AgentStart or f ~= AgentFinish then
				s, f = AgentStart, AgentFinish
				AgentPathfindForce = false
				AgentPathfind()
			end
		end
	end
end)

local RCP = RaycastParams.new()
RCP.RespectCanCollide = true
RCP.FilterType = Enum.RaycastFilterType.Exclude
local function Raycast(from, dir)
	local s,r = pcall(workspace.Spherecast, workspace, from, 0.25, dir, RCP)
	if s then return r end
end

workspace.DescendantAdded:Connect(function(v)
	if v:IsA("Model") then
		if v:GetAttribute("Optimiserd") then return end
		v:SetAttribute("Optimiserd", true)
		v.AncestryChanged:Connect(function()
			if v.Parent == nil then
				task.wait()
				v:Destroy()
			end
		end)
	end
end)

LocalPlayer.DevComputerMovementMode = Enum.DevComputerMovementMode.Scriptable
LocalPlayer.DevTouchMovementMode = Enum.DevTouchMovementMode.Scriptable

local charge = false
task.spawn(function()
	while true do
		task.wait(0.5 + math.random() * 5)
		charge = true
		task.wait(2)
		charge = false
	end
end)

while true do
	local dt = task.wait()
	local char = LocalPlayer.Character
	local back = LocalPlayer:FindFirstChildOfClass("Backpack")
	DebugWireframing:Clear()
	if IsPathfinding then
		for _,v in AgentWaypoints do
			CreateDot(v.Position)
		end
	end
	if char and back then
		local hum = char:FindFirstChild("Humanoid")
		local root = char:FindFirstChild("HumanoidRootPart")
		local leg = char:FindFirstChild("Right Leg")
		if hum and root and leg and hum.Health > 0 then
			local shlock = root:FindFirstChild("Shiftlock")
			if shlock == nil then
				shlock = Instance.new("BodyGyro", root)
				shlock.Name = "Shiftlock"
				shlock.P = 9e4
				shlock.MaxTorque = Vector3.new(0, 0, 0)
			end
			local targetmove = Vector3.new(0, 255, 0)
			if hum.Health < 50 then
				targetmove = CONFIG.HEALING_PAD_POSITION
			end
			local lookat = nil
			local targetjump = false
			local havesword = false
			local usesword = false
			local ignoreraycast = {}
			for _, v in AgentParts do
				SetPartPathfindModification(v, v.Transparency > 0.3)
			end
			local nearest = nil
			local nearestdist = CONFIG.DETECTION_RADIUS
			local nearestff = nil
			local nearestffdist = CONFIG.DETECTION_RADIUS
			for _, player in Players:GetPlayers() do
				if player.Character then
					local char2 = player.Character
					table.insert(ignoreraycast, char2)
					if player ~= LocalPlayer then
						local hum2 = char2:FindFirstChild("Humanoid")
						local root2 = char2:FindFirstChild("HumanoidRootPart")
						if root2 and hum2 and hum2.Health > 0 and root:FindFirstChildOfClass("Motor6D") then
							local distance = (root2.Position - root.Position).Magnitude
							if char2:FindFirstChildOfClass("ForceField") then
								if distance <= nearestffdist then
									nearestff = root2
									nearestffdist = distance
								end
							else
								if distance <= nearestdist then
									nearest = root2
									nearestdist = distance
								end
							end
						end
					end
				end
			end
			RCP.FilterDescendantsInstances = ignoreraycast
			ignoreraycast = nil
			if nearest then
				if nearestdist > 20 then
					targetmove = nearest.Position
				else
					local vpos = nearest.Position + nearest.Velocity * 0.1
					havesword = true
					lookat = CFrame.lookAlong(Vector3.zero, (vpos - root.Position) * Vector3.new(1, 0, 1))
					if nearest.Velocity.Magnitude > 0.2 then
						if charge then
							targetjump = true
							targetmove = vpos + lookat:VectorToWorldSpace(Vector3.new(3, 0, 2))
							lookat *= CFrame.Angles(0, math.pi * 0.5 * (math.random() - 0.5), 0)
						else
							targetmove = vpos + lookat:VectorToWorldSpace(Vector3.new(1, 0, 13))
						end
					else
						targetmove = vpos + lookat:VectorToWorldSpace(Vector3.new(0, 0, 2))
					end
					lookat *= CFrame.Angles(0, math.pi * 0.1, 0)
					if not Raycast(targetmove, Vector3.new(0, -5, 0)) then
						targetmove = vpos + lookat:VectorToWorldSpace(Vector3.new(0, 0, 2))
					end
					if nearestdist < 4 + LocalPlayer:GetNetworkPing() * 16 then
						usesword = true
					end
				end
			end
			if nearestff then
				local dirto = (targetmove - nearestff.Position) * Vector3.new(1, 0, 1)
				if dirto.Magnitude > 0 and dirto.Magnitude < 16 then
					targetmove += dirto.Unit * (16 - dirto.Magnitude)
				end
				if nearestffdist < 12 then
					targetjump = true
				end
			end
			CreateDot(targetmove + Vector3.new(0, 1, 0))
			local targetmove2 = root.Position
			if IsPathfinding then
				if AgentCalculating then
					BlockedTime = 0
				else
					if #AgentWaypoints == 0 then
						-- resort to teleport?
						if Raycast(AgentStart, Vector3.new(0, -4, 0)) and Raycast(AgentFinish, Vector3.new(0, -4, 0)) then
							--debugPrint("GOTO", "I am really blocked. Teleporting...")
							--root.CFrame = CFrame.new(targetmove + Vector3.new(0, 10, 0))
							--IsPathfinding = false
						else
							-- or repathfind?
							BlockedTime = 0
							AgentStart = root.Position
							AgentFinish = targetmove
						end
					elseif AgentBlocked or BlockedTime > CONFIG.BLOCKED_TIME_PATHFIND then
						debugPrint("GOTO", "I am blocked again. Re-pathfinding...")
						BlockedTime = 0
						AgentStart = root.Position
						AgentFinish = targetmove
						AgentPathfindForce = true
					end
					AgentStart = root.Position
					local newdist = (targetmove - AgentFinish).Magnitude
					if newdist > 8 and newdist < 24 then
						AgentFinish = targetmove
					elseif newdist >= 24 then
						debugPrint("GOTO", "Pathfinding new target too far.")
						IsPathfinding = false
					end
				end
				if #AgentWaypoints > 2 then
					if #AgentWaypoints < AgentWaypointIndex then
						IsPathfinding = false
						debugPrint("GOTO", "Pathfinding success.")
					else
						for i=AgentWaypointIndex, #AgentWaypoints do
							local current = AgentWaypoints[i]
							local pfdist = (root.Position - current.Position) * Vector3.new(1, 0, 1)
							if pfdist.Magnitude < 1 then
								AgentWaypointIndex = i + 1
								break
							end
						end
						if AgentWaypointIndex <= #AgentWaypoints then
							local current = AgentWaypoints[AgentWaypointIndex]
							targetmove2 = current.Position
						end
					end
				end
			else
				if BlockedTime > CONFIG.BLOCKED_TIME_PATHFIND then
					debugPrint("GOTO", "I am blocked. Pathfinding...")
					BlockedTime = 0
					IsPathfinding = true
					AgentStart = root.Position
					AgentFinish = targetmove
				end
				targetmove2 = targetmove
			end
			CreateDot(targetmove2 + Vector3.new(0, 1, 0))
			local dir = (targetmove2 - root.Position) * Vector3.new(2, 0, 2)
			if dir.Magnitude > 1 then dir = dir.Unit end
			if leg.CanCollide then
				if Raycast(root.CFrame.Position + Vector3.new(0, -2.5, 0), root.CFrame.LookVector * 2) then
					targetjump = true
				end
			end
			local blocked = false
			if IsPathfinding then
				if not Raycast(targetmove2 + Vector3.new(0, 1, 0), Vector3.new(0, -1024, 0)) then
					blocked = true
				end
				local ded = true
				for i=1, 7 do
					if Raycast(root.Position + dir * i, Vector3.new(0, -1024, 0)) then
						ded = false
					else
						targetjump = true
					end
				end
				if ded then
					blocked = true
				end
			else
				if Raycast(root.Position, dir * 3) then
					if Raycast(root.Position + Vector3.new(0, 5, 0), dir * 3) then
						blocked = true
					else
						targetjump = true
					end
				end
				if not Raycast(root.Position + dir * 2, Vector3.new(0, -1024, 0)) then
					blocked = true
				end
			end
			if blocked then
				CreateDot(targetmove + Vector3.new(0, 2, 0))
				hum:Move(Vector3.zero)
				BlockedTime += dt
			else
				hum:Move(dir)
				if targetjump then
					if hum:GetState() == Enum.HumanoidStateType.Running then
						hum:ChangeState(Enum.HumanoidStateType.Jumping)
					end
				end
				BlockedTime = math.max(0, BlockedTime - dt)
			end
			if lookat ~= nil then
				shlock.MaxTorque = Vector3.new(0, 9e9, 0)
				shlock.CFrame = lookat
			else
				shlock.MaxTorque = Vector3.new(0, 0, 0)
			end
			local sword = GetTool(CONFIG.SWORD_NAME)
			if sword then
				if havesword then
					if sword.Parent ~= char then
						sword.Parent = char
					end
					if usesword then
						sword.Enabled = true
						sword:Activate()
					end
				else
					if sword.Parent ~= back then
						sword.Parent = back
					end
				end
			end
			continue
		end
	end
	AgentWaypoints = {}
	AgentWaypointIndex = 1
	AgentBlocked = false
	IsPathfinding = false
	BlockedTime = 0
end
