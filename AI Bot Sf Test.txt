--[[ 
    Linked Sword AI Combat Script (Enhanced Version)
    Implemented improvements per user request:
    - Adaptive periodic garbage collection
    - Expanded safe pathfinding (16 alternatives)
    - Continuous movement & smooth path transitions
    - ForceField proximity detection + fleeing/evasion
    - Offensive-defensive sword combat with strafing and deceptive lunges
    - Transparent platform avoidance + intelligent jumping
    - Faster, robust respawn/equip logic
    Based on original prototype file: AI Bot Sf Prototypes :contentReference[oaicite:1]{index=1}
--]]

-- Force immediate printing
local _lastErrorMsg, _lastErrorTime, _errorCount = nil, 0, 0
local function shouldLog(msg)
    local now = tick()
    if msg == _lastErrorMsg and (now - _lastErrorTime) < 1.5 then
        _errorCount = _errorCount + 1
        if _errorCount % 5 ~= 0 then
            return false
        end
    else
        _lastErrorMsg, _lastErrorTime, _errorCount = msg, now, 0
    end
    return true
end

local function forcePrint(...)
    local message = table.concat({...}, " ")
    if shouldLog(message) then print(message) end
    print("") -- attempt flush
end

local function debugPrint(category, ...)
    local args = {...}
    local message = "[" .. category .. "] " .. table.concat(args, " ")
    local timestamp = os.date("%H:%M:%S")
    forcePrint(timestamp .. " - " .. message)
end

forcePrint("LinkedSwordAI: Enhanced script starting...")
debugPrint("INIT", "Enhanced debug logging enabled")

local success, err = pcall(function()

-- Persistent global across respawns
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {},
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        MovementHistory = {},
        FailedPaths = {},
        LastEquipAttempt = 0,
        EquipmentReady = false,
        KnownVoidAreas = {},
        PathCache = {},
        LastPathfindingTime = 0,
        PerformanceStats = {
            PathfindingTime = 0,
            CombatTime = 0,
            MovementTime = 0,
            LastOptimizationTime = 0
        },
        AlternativePaths = {},
        -- Node navigation state
        NodeGraph = { nodes = {}, adjacency = {} },
        NodePath = nil,
        CurrentNodeIndex = 1,
        LastNodePathComputedTime = 0,
        NodeGraphBuiltTime = 0,
        -- New navigation state:
        CurrentNavigationTarget = nil,
        NavigationTransitionStart = 0,
        LastGCTime = 0,
        GCInterval = 30, -- default, adaptive below
        LastUpdateTime = 0,
        LastJumpTime = 0,
        LastMoveCommandTime = 0,
        LastDistanceToTarget = math.huge,
        LastInRangeTime = 0,
        Connections = { UpdateConn = nil, CharacterAddedConn = nil },
        -- Roaming state
        RoamNodeId = nil,
        LastRoamRecomputeTime = 0,
        PrioritizePathfinding = false
    }
end

local persistentData = _G.LinkedSwordAIPersistentData

-- Configuration (tweak these values for tuning)
local CONFIG = {
    DETECTION_RADIUS = 200,
    ATTACK_RANGE = 15,
    IMMEDIATE_ATTACK_RADIUS = 8,      -- immediate attack trigger
    ATTACK_COOLDOWN = 0.6,
    LUNGE_DELAY = 0.08,               -- faster lunges
    LUNGE_SPEED_MULTIPLIER = 1.6,     -- relative lunge speed
    STUCK_CHECK_DISTANCE = 1.5,
    STUCK_CHECK_TIME = 1.0,
    MAX_TARGET_DISTANCE = 250,
    MIN_HEALTH_CHECK = 0,
    RETARGET_CHECK_TIME = 1.5,
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -100,
    FORCEFIELD_FLEE_DISTANCE = 18,    -- repaired flee distance (in studs)
    SWORD_CHECK_INTERVAL = 6,
    RESPAWN_EQUIP_DELAY = 0.3,        -- faster respawn equip attempts
    MOVEMENT_MEMORY_TIME = 0.7,
    SAFE_GAP_DISTANCE = 10,
    PATH_SMOOTHING_FACTOR = 0.7,
    MOVEMENT_RETRY_DELAY = 1.0,
    NARROW_PASSAGE_WIDTH = 3.5,
    PATHFINDING_STEPS = 10,
    COMBAT_BEHAVIOR_CHANGE_TIME = 4.0,
    COMBAT_DEFENSIVE_CHANCE = 0.2,
    COMBAT_OFFENSIVE_CHANCE = 0.5,
    STRAFE_DISTANCE = 4,
    BRIDGE_CHECK_DISTANCE = 25,
    PERFORMANCE_MODE = true,
    PATH_CACHE_TIME = 3.0,
    ALTERNATIVE_PATH_COUNT = 16,      -- expanded to 16 paths
    MIN_ATTACK_DISTANCE = 3,
    OUT_OF_RANGE_AGGRESSION_TIME = 3.0, -- if target out of attack range for this many seconds -> aggressive
    TRANSPARENT_THRESHOLD = 0.8,      -- treat parts with transparency >= this as vanishing
    IMMEDIATE_RESPAWN_FIGHT = true,   -- start fighting immediately on spawn
    JUMP_SAFE_MARGIN = 2,             -- extra margin for jumps
    MAX_KNOWN_VOID_AREAS = 80,
    PATH_CACHE_CAPACITY = 40,
    GC_MIN_INTERVAL = 15,
    GC_MAX_INTERVAL = 60,
    -- Node-based pathfinding config
    NODE_SWITCH_VOID_DISTANCE = 50,
    LEDGE_SAFE_DROP_HEIGHT = 8,
    WALL_DETECT_DISTANCE = 8,
    MIN_JUMP_TRIGGER_HEIGHT = 1.5,
    MAX_JUMP_HEIGHT = 6,
    JUMP_COOLDOWN = 0.5,
    MOVE_COMMAND_COOLDOWN = 0.1,
    STUCK_COOLDOWN = 1.0,
    STUCK_RESET_DISTANCE = 3.0,
    NARROW_EDGE_CHECK = 2.5, -- lateral edge probe for narrow walkways
    NARROW_STEP_DISTANCE = 2.2,
    ENGAGE_MAX_DISTANCE = 35,
    NODE_GRAPH_REBUILD_INTERVAL = 8,
    NODE_MAX_LINK_DISTANCE = 120,
    NODE_PATH_RECOMPUTE_INTERVAL = 3.0,
    PATH_SEGMENT_LENGTH = 20, -- Length of path segments for segmented pathfinding
    NODE_SWITCH_VOID_DISTANCE = 12,
    MAX_JUMP_HEIGHT = 6,
    WALL_DETECT_DISTANCE = 6,
    LEDGE_SAFE_DROP_HEIGHT = 12,
    LEDGE_DETECT_FORWARD_DISTANCE = 5,
    LEDGE_DETECT_DOWN_DISTANCE = 15,
    -- Advanced autoscan pathfinding config
    USE_AUTOSCAN_NODES = true,
    NAV_SCAN_STEP = 8,
    NAV_MAX_NODE_COUNT = 450,
    NAV_CONNECT_RADIUS = 28,
    NAV_RAYCAST_UP = 6,
    NAV_RAYCAST_DOWN = 12,
    NAV_MAX_SLOPE_Y = 0.5,
    NAV_MAX_ASCENT_HEIGHT = 6,
    NAV_MAX_DROP_HEIGHT = 18,
    NAV_MIN_NODE_THRESHOLD = 24,
    NODE_FOLDER_NAMES = {"Nodes", "Waypoints", "NavNodes"},
    MAX_SLOPE_ANGLE = 30, -- Degrees
    -- Roaming behavior
    ROAM_RECOMPUTE_INTERVAL = 8,
    ROAM_MIN_DISTANCE = 40,
    ROAM_MAX_DISTANCE = 160,
    -- Performance and behavior gating
    UPDATE_TICK_RATE_HZ = 15,             -- throttle Update() to ~15 Hz for low CPU
    NODE_GRAPH_REBUILD_INTERVAL = 45,     -- seconds between autoscan rebuilds
    ENGAGE_MAX_DISTANCE = 70,             -- only engage/react to targets within this distance
    ATTACK_ELEVATION_TOLERANCE = 6,     -- only attack if Y delta within this range
    MIN_JUMP_TRIGGER_HEIGHT = 0.5,        -- auto-jump for low 0.5+ stud obstacles

    NARROW_STEP_DISTANCE = 1.5            -- smaller step when on narrow passages
}

local function SafeHumanoidChangeState(state)
    if not Humanoid or not state then return false end
    -- Cooldown jump requests to prevent double-jump spam
    if state == Enum.HumanoidStateType.Jumping then
        if tick() - (persistentData.LastJumpTime or 0) < CONFIG.JUMP_COOLDOWN then
            return false
        end
        persistentData.LastJumpTime = tick()
    end
    local ok = pcall(function()
        Humanoid:ChangeState(state)
    end)
    return ok
end

-- Create status GUI (same logic, minor label improvements)
local function CreateStatusGUI()
    local gui = {}
    local Players = game:GetService("Players")
    local parentOptions = {
        game:GetService("CoreGui"),
        Players.LocalPlayer and Players.LocalPlayer:FindFirstChild("PlayerGui"),
        Players.LocalPlayer and Players.LocalPlayer.Character
    }
    local screenGui
    for _, parent in ipairs(parentOptions) do
        if parent then
            local success, result = pcall(function()
                local g = Instance.new("ScreenGui")
                g.Name = "LinkedSwordAI_Status"
                g.ResetOnSpawn = false
                g.Parent = parent
                return g
            end)
            if success then
                screenGui = result
                break
            end
        end
    end
    if not screenGui then
        forcePrint("LinkedSwordAI: Failed to create GUI")
        return nil
    end
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 220, 0, 140)
    frame.Position = UDim2.new(0.78, 0, 0.08, 0)
    frame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    frame.BackgroundTransparency = 0.4
    frame.BorderSizePixel = 1
    frame.Parent = screenGui

    local function makeLabel(y, color, text)
        local lbl = Instance.new("TextLabel")
        lbl.Size = UDim2.new(1, -10, 0, 22)
        lbl.Position = UDim2.new(0, 5, 0, y)
        lbl.BackgroundTransparency = 1
        lbl.TextColor3 = color
        lbl.Text = text
        lbl.Font = Enum.Font.SourceSans
        lbl.TextSize = 13
        lbl.TextXAlignment = Enum.TextXAlignment.Left
        lbl.Parent = frame
        return lbl
    end

    local status = makeLabel(6, Color3.new(1,1,1), "Status: Initializing...")
    local target = makeLabel(30, Color3.new(1,0.6,0.6), "Target: None")
    local distance = makeLabel(54, Color3.new(0.6,1,0.6), "Distance: N/A")
    local debug = makeLabel(78, Color3.new(1,1,0.4), "Debug: Starting...")
    local perf = makeLabel(102, Color3.new(0.6,0.8,1), "Perf: Idle")

    function gui.UpdateStatus(text) if status then status.Text = "Status: " .. text end end
    function gui.UpdateTarget(text) if target then target.Text = "Target: " .. text end end
    function gui.UpdateDistance(d) if distance then distance.Text = "Distance: " .. (d and string.format("%.1f", d) or "N/A") end end
    function gui.UpdateDebug(t) if debug then debug.Text = "Debug: " .. t end end
    function gui.UpdatePerf(t) if perf then perf.Text = "Perf: " .. t end end

    return gui
end

-- Initialize AI (protected)
local function InitializeAI()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")

    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        forcePrint("LinkedSwordAI: LocalPlayer not found")
        return false
    end

    forcePrint("LinkedSwordAI: LocalPlayer found - " .. LocalPlayer.Name)

    local Character = LocalPlayer.Character
    if not Character then
        -- wait briefly for character to spawn
        pcall(function() Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() end)
    end
    if not Character then
        forcePrint("LinkedSwordAI: Character not found")
        return false
    end

    local Humanoid = Character:FindFirstChild("Humanoid") or (pcall(function() return Character:WaitForChild("Humanoid", 2) end) and Character:FindFirstChild("Humanoid") or nil)
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart") or (pcall(function() return Character:WaitForChild("HumanoidRootPart", 2) end) and Character:FindFirstChild("HumanoidRootPart") or nil)
    if not Humanoid or not HumanoidRootPart then
        forcePrint("LinkedSwordAI: Humanoid or HumanoidRootPart not found")
        return false
    end

    forcePrint("LinkedSwordAI: Character components found")

    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
    end

    -- Add robust checks for Nav table and its critical functions
    if not Nav then
        forcePrint("LinkedSwordAI: Nav table is nil after initialization. Critical error.")
        return false
    end
    if not Nav.AStar then
        forcePrint("LinkedSwordAI: Nav.AStar is nil. Critical pathfinding function missing.")
        return false
    end
    if not Nav.ComputePath then
        forcePrint("LinkedSwordAI: Nav.ComputePath is nil. Critical path computation function missing.")
        return false
    end

    -- Robust sword finder (tries backpack and character)
    local function FindLinkedSword()
        if persistentData.SwordToolName then
            local stored = Character:FindFirstChild(persistentData.SwordToolName)
            if stored and stored:IsA("Tool") then return stored end
            stored = LocalPlayer.Backpack:FindFirstChild(persistentData.SwordToolName)
            if stored and stored:IsA("Tool") then return stored end
        end

        for _, tool in pairs(Character:GetChildren()) do
            if tool:IsA("Tool") and tostring(tool.Name):lower():find("sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end

        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tostring(tool.Name):lower():find("sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end

        return nil
    end

    -- Periodic check for sword
    local function CheckForSword()
        local currentTime = tick()
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword = FindLinkedSword()
            end
            persistentData.LastSwordCheckTime = currentTime
        end
    end

    -- Players in range
    local function FindPlayersInRange()
        local players = {}
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and
               player.Character:FindFirstChild("HumanoidRootPart") and
               player.Character:FindFirstChild("Humanoid") and
               player.Character.Humanoid.Health > CONFIG.MIN_HEALTH_CHECK then

                local hrp = player.Character.HumanoidRootPart
                local distance = (hrp.Position - HumanoidRootPart.Position).Magnitude

                if distance <= CONFIG.DETECTION_RADIUS then
                    local hasFF = false
                    for _, c in pairs(player.Character:GetChildren()) do
                        if c:IsA("ForceField") then
                            hasFF = true
                            persistentData.PlayersWithForceField[player.Name] = player
                            break
                        end
                    end
                    if not hasFF and persistentData.PlayersWithForceField[player.Name] then
                        persistentData.PlayersWithForceField[player.Name] = nil
                    end

                    table.insert(players, {player = player, distance = distance, hasForceField = hasFF})
                end
            end
        end

        table.sort(players, function(a,b) return a.distance < b.distance end)
        return players
    end

    -- Treat transparent or non-collidable parts as void (vanishing platforms)
    local function isPartUnsafe(part)
        if not part then return true end
        if part.Transparency and part.Transparency >= CONFIG.TRANSPARENT_THRESHOLD then return true end
        if part.CanCollide == false then return true end
        return false
    end

    -- Check if a position is in a void (improved)
    local function IsVoidArea(position)
        -- Known void areas quick check
        for i, vp in ipairs(persistentData.KnownVoidAreas) do
            if (position - vp).Magnitude < 5 then
                return true
            end
        end

        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            if #persistentData.KnownVoidAreas < CONFIG.MAX_KNOWN_VOID_AREAS then
                table.insert(persistentData.KnownVoidAreas, position)
            else
                table.remove(persistentData.KnownVoidAreas, 1)
                table.insert(persistentData.KnownVoidAreas, position)
            end
            return true
        end

        -- Raycast downwards and inspect hit
        if not Character then return true end
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {Character}
        params.FilterType = Enum.RaycastFilterType.Blacklist
        local rayRes = Workspace:Raycast(position, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0), params)

        if not rayRes or not rayRes.Instance then
            if #persistentData.KnownVoidAreas < CONFIG.MAX_KNOWN_VOID_AREAS then
                table.insert(persistentData.KnownVoidAreas, position)
            else
                table.remove(persistentData.KnownVoidAreas, 1)
                table.insert(persistentData.KnownVoidAreas, position)
            end
            return true
        else
            local hitPart = rayRes.Instance
            if isPartUnsafe(hitPart) then
                -- treat this as void-like because platform vanishes or non-collidable
                if #persistentData.KnownVoidAreas < CONFIG.MAX_KNOWN_VOID_AREAS then
                    table.insert(persistentData.KnownVoidAreas, position)
                else
                    table.remove(persistentData.KnownVoidAreas, 1)
                    table.insert(persistentData.KnownVoidAreas, position)
                end
                return true
            end
        end

        return false
    end

    -- IsSafeGap (unchanged fundamentals but uses IsVoidArea improvements)
    local function IsSafeGap(startPos, endPos)
        local distance = (endPos - startPos).Magnitude
        if distance < 3 then
            return not IsVoidArea(endPos)
        end
        if distance < CONFIG.SAFE_GAP_DISTANCE then
            if not Character then return false end
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {Character}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local rayRes = Workspace:Raycast(endPos, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0), params)
            return rayRes ~= nil and rayRes.Instance ~= nil and not isPartUnsafe(rayRes.Instance)
        end
        local direction = (endPos - startPos).Unit
        local checkCount = math.ceil(distance / 2)
        for i = 1, checkCount do
            if not Character then return false end
            local checkPoint = startPos + direction * (i * 2)
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {Character}
            params.FilterType = Enum.RaycastFilterType.Blacklist
            local rayRes = Workspace:Raycast(checkPoint, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0), params)
            if not rayRes or not rayRes.Instance or isPartUnsafe(rayRes.Instance) then
                return false
            end
        end
        return true
    end

    local function IsNarrowPassage(position, direction)
        local cross = direction:Cross(Vector3.new(0,1,0))
        if cross.Magnitude == 0 then cross = Vector3.new(1,0,0) end
        cross = cross.Unit
        -- Rail/wall-based narrow detection
        local leftRay = Ray.new(position, cross * CONFIG.NARROW_PASSAGE_WIDTH)
        local rightRay = Ray.new(position, -cross * CONFIG.NARROW_PASSAGE_WIDTH)
        local leftHit, _ = Workspace:FindPartOnRay(leftRay, Character)
        local rightHit, _ = Workspace:FindPartOnRay(rightRay, Character)
        local railNarrow = leftHit and rightHit
        -- Edge/void-based narrow detection (bridges without rails)
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {Character}
        params.FilterType = Enum.RaycastFilterType.Blacklist
        local leftDown = Workspace:Raycast(position + cross * CONFIG.NARROW_EDGE_CHECK, Vector3.new(0, -CONFIG.LEDGE_DETECT_DOWN_DISTANCE, 0), params)
        local rightDown = Workspace:Raycast(position - cross * CONFIG.NARROW_EDGE_CHECK, Vector3.new(0, -CONFIG.LEDGE_DETECT_DOWN_DISTANCE, 0), params)
        local leftUnsafe = (not leftDown) or (not leftDown.Instance) or isPartUnsafe(leftDown.Instance)
        local rightUnsafe = (not rightDown) or (not rightDown.Instance) or isPartUnsafe(rightDown.Instance)
        local edgeNarrow = leftUnsafe or rightUnsafe
        return railNarrow or edgeNarrow
    end

    local function FindBridgePath(startPos, endPos)
        local direction = (endPos - startPos).Unit
        local distance = (endPos - startPos).Magnitude
        for dist = 5, math.min(CONFIG.BRIDGE_CHECK_DISTANCE, distance), 5 do
            local checkPoint = startPos + direction * dist
            for y = 0, -20, -2 do
                local bridgeCheckPoint = checkPoint + Vector3.new(0, y, 0)
                local params = RaycastParams.new()
                params.FilterDescendantsInstances = {Character}
                params.FilterType = Enum.RaycastFilterType.Blacklist
                local rayRes = Workspace:Raycast(bridgeCheckPoint, Vector3.new(0, -5, 0), params)
                if rayRes and rayRes.Instance and not isPartUnsafe(rayRes.Instance) then
                    local bridgePath = rayRes.Position + Vector3.new(0, 3, 0)
                    if IsSafeGap(startPos, bridgePath) then
                        return bridgePath
                    end
                end
            end
        end
        return nil
    end

    -- Duplicate node graph helpers removed (hoisted earlier)

    -- Duplicate node graph helpers removed (ComputeNodePath, ShouldSwitchToNodeNavigation, FollowNodePath, DetectObstacleAhead)
    -- See primary implementations earlier in the file.


    -- IsSafePath (expanded alternatives and caching)
    local function IsSafePath(targetPosition)
        if CONFIG.PERFORMANCE_MODE then
            local currentTime = tick()
            local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
            local cached = persistentData.PathCache[hashKey]
            if cached and currentTime - cached.time < CONFIG.PATH_CACHE_TIME then
                debugPrint("PATH", "Using cached result")
                return cached.safe, cached.bridgePath, cached.alternativePath
            end
        end

        local startTime = tick()

        local failedCount = #persistentData.FailedPaths
        if failedCount > 0 then
            for i = failedCount, math.max(1, failedCount - 4), -1 do
                local fp = persistentData.FailedPaths[i]
                if fp and (targetPosition - fp.position).Magnitude < 5 and tick() - fp.time < 10 then
                    return false
                end
            end
        end

        local startPos = (Character and Character:FindFirstChild("HumanoidRootPart") and Character.HumanoidRootPart.Position) or persistentData.LastStuckPosition or Vector3.new(0,0,0)
        local direction = (targetPosition - startPos)
        if direction.Magnitude == 0 then
            return not IsVoidArea(targetPosition)
        end
        direction = direction.Unit
        local distance = (targetPosition - startPos).Magnitude

        local isNarrow = IsNarrowPassage(startPos, direction)
        if isNarrow then
            local narrowIncrement = math.min(2, distance / 8)
            for i = narrowIncrement, distance, narrowIncrement do
                local checkPos = startPos + direction * i
                if IsVoidArea(checkPos) then
                    if #persistentData.FailedPaths >= 12 then table.remove(persistentData.FailedPaths, 1) end
                    table.insert(persistentData.FailedPaths, {position = targetPosition, time = tick()})
                    if CONFIG.PERFORMANCE_MODE then
                        local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
                        persistentData.PathCache[hashKey] = {safe = false, time = tick(), bridgePath = nil}
                    end
                    return false
                end
            end
        else
            local increment = math.min(5, math.max(2, distance / 5))
            for i = increment, distance, increment do
                local checkPos = startPos + direction * i
                if IsVoidArea(checkPos) then
                    local bridgePath = FindBridgePath(startPos, targetPosition)
                    if bridgePath then
                        if CONFIG.PERFORMANCE_MODE then
                            local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
                            persistentData.PathCache[hashKey] = {safe = true, time = tick(), bridgePath = bridgePath}
                            persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                        end
                        return true, bridgePath
                    end

                    -- Try expanded alternative directions (16 angles)
                    local halfDistance = distance * 0.5
                    local piDivided = (2 * math.pi) / CONFIG.ALTERNATIVE_PATH_COUNT
                    local upVector = Vector3.new(0,1,0)
                    for altIndex = 0, CONFIG.ALTERNATIVE_PATH_COUNT - 1 do
                        local angle = altIndex * piDivided
                        local rotation = CFrame.fromAxisAngle(upVector, angle)
                        local altDir = (rotation * CFrame.new(direction)).lookVector
                        local altTargetPos = startPos + altDir * halfDistance
                        local altSafe = true
                        for j = increment, math.max(2, halfDistance), increment do
                            local altCheckPos = startPos + altDir * j
                            if IsVoidArea(altCheckPos) then
                                altSafe = false
                                break
                            end
                        end
                        if altSafe then
                            persistentData.AlternativePaths[targetPosition] = altTargetPos
                            if CONFIG.PERFORMANCE_MODE then
                                local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
                                persistentData.PathCache[hashKey] = {safe = false, time = tick(), bridgePath = nil, alternativePath = altTargetPos}
                                persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                            end
                            return false, nil, altTargetPos
                        end
                    end

                    if #persistentData.FailedPaths >= 12 then table.remove(persistentData.FailedPaths, 1) end
                    table.insert(persistentData.FailedPaths, {position = targetPosition, time = tick()})
                    if CONFIG.PERFORMANCE_MODE then
                        local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
                        persistentData.PathCache[hashKey] = {safe = false, time = tick(), bridgePath = nil}
                        persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                    end
                    return false
                end
            end
        end

        if IsVoidArea(targetPosition) then
            if #persistentData.FailedPaths >= 12 then table.remove(persistentData.FailedPaths, 1) end
            table.insert(persistentData.FailedPaths, {position = targetPosition, time = tick()})
            if CONFIG.PERFORMANCE_MODE then
                local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
                persistentData.PathCache[hashKey] = {safe = false, time = tick(), bridgePath = nil}
                persistentData.PerformanceStats.PathfindingTime = tick() - startTime
            end
            return false
        end

        if CONFIG.PERFORMANCE_MODE then
            local hashKey = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
            persistentData.PathCache[hashKey] = {safe = true, time = tick(), bridgePath = nil}
            persistentData.PerformanceStats.PathfindingTime = tick() - startTime
        end

        return true
    end

    -- Stuck detection
    local function CheckIfStuck()
        if not HumanoidRootPart then return false end
        local currentTime = tick()
        -- Only consider stuck if we recently attempted movement
        if (currentTime - (persistentData.LastMoveCommandTime or 0)) > (CONFIG.STUCK_CHECK_TIME + 0.1) then
            return false
        end
        -- Avoid spamming unstuck attempts
        if persistentData.IsStuck and (currentTime - (persistentData.LastUnstuckAttemptTime or 0) < CONFIG.STUCK_COOLDOWN) then
            return false
        end
        if not persistentData.LastStuckPosition then
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = currentTime
            return false
        end

        if currentTime - persistentData.LastStuckTime > CONFIG.STUCK_CHECK_TIME then
            local dist = (HumanoidRootPart.Position - persistentData.LastStuckPosition).Magnitude
            if dist < CONFIG.STUCK_CHECK_DISTANCE then
                persistentData.IsStuck = true
                persistentData.LastUnstuckAttemptTime = currentTime
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Stuck detected") end
                return true
            else
                if dist >= (CONFIG.STUCK_RESET_DISTANCE or (CONFIG.STUCK_CHECK_DISTANCE * 2)) then
                    persistentData.IsStuck = false
                end
                persistentData.LastStuckPosition = HumanoidRootPart.Position
                persistentData.LastStuckTime = currentTime
            end
        end
        return false
    end

    local function ShouldPrioritizePathfinding()
        if not HumanoidRootPart or not persistentData.CurrentTarget or not persistentData.CurrentTarget.Character then return false end
        local targetHRP = persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        if not targetHRP then return false end

        -- Check if stuck
        if CheckIfStuck() then return true end

        -- Check if on significantly lower ground
        local selfY = HumanoidRootPart.Position.Y
        local targetY = targetHRP.Position.Y
        if targetY - selfY > CONFIG.ATTACK_ELEVATION_TOLERANCE then
            return true
        end

        -- Check for wall in front (stuck against wall scenario)
        local directionToTarget = (targetHRP.Position - HumanoidRootPart.Position).Unit
        local obsType, _ = DetectObstacleAhead(directionToTarget, CONFIG.NARROW_STEP_DISTANCE)
        if obsType == "wall" then
            return true
        end

        return false
    end

    -- Terrain-aware NavManager and safe movement wrappers (clean-slate reimplementation)
    local Nav = {
        nodes = {},
        adjacency = {},
        path = {},
        lastBuild = 0,
        lastTarget = nil,
        lastPathCompute = 0,
        ComputeWorldBounds = nil,
        RaycastSafe = nil,
        InsertNode = nil,
        ScanNodes = nil,
        ConnectNodes = nil,
        NearestNode = nil,
        RebuildIfNeeded = nil,
        h = nil,
        AStar = nil,
        ComputePath = nil,
        NextStep = nil,
        FollowTo = nil
    }

    -- Robust nil checks for Nav table and its core functions
    if not Nav then error("Nav table is nil at initialization!") end
    if not Nav.AStar then error("Nav.AStar is nil at initialization!") end
    if not Nav.ComputePath then error("Nav.ComputePath is nil at initialization!") end
    if not Nav.FollowTo then error("Nav.FollowTo is nil at initialization!") end
    if not Nav.NextStep then error("Nav.NextStep is nil at initialization!") end
    if not Nav.ComputeWorldBounds then error("Nav.ComputeWorldBounds is nil at initialization!") end
    if not Nav.ScanNodes then error("Nav.ScanNodes is nil at initialization!") end
    if not Nav.RebuildIfNeeded then error("Nav.RebuildIfNeeded is nil at initialization!") end

    function Nav:ComputeWorldBounds()
        local minX, minY, minZ = math.huge, math.huge, math.huge
        local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge
        for _, inst in ipairs(Workspace:GetDescendants()) do
            if inst:IsA("BasePart") and not isPartUnsafe(inst) then
                local cf, size = inst.CFrame, inst.Size
                local corners = {
                    cf:PointToWorldSpace(Vector3.new( size.X/2,  size.Y/2,  size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new(-size.X/2,  size.Y/2,  size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new( size.X/2,  size.Y/2, -size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new(-size.X/2,  size.Y/2, -size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new( size.X/2, -size.Y/2,  size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new(-size.X/2, -size.Y/2,  size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new( size.X/2, -size.Y/2, -size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new(-size.X/2, -size.Y/2, -size.Z/2)),
                }
                for _, p in ipairs(corners) do
                    minX = math.min(minX, p.X); minY = math.min(minY, p.Y); minZ = math.min(minZ, p.Z)
                    maxX = math.max(maxX, p.X); maxY = math.max(maxY, p.Y); maxZ = math.max(maxZ, p.Z)
                end
            end
        end
        if minX == math.huge then
            local p = HumanoidRootPart and HumanoidRootPart.Position or Vector3.new(0,0,0)
            local r = 200
            return Vector3.new(p.X-r, p.Y-50, p.Z-r), Vector3.new(p.X+r, p.Y+50, p.Z+r)
        end
        return Vector3.new(minX, minY, minZ), Vector3.new(maxX, maxY, maxZ)
    end

    function Nav:RaycastSafe(origin, direction)
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {Character}
        params.FilterType = Enum.RaycastFilterType.Blacklist
        local res = Workspace:Raycast(origin, direction, params)
        if not res or not res.Instance then return nil end
        if isPartUnsafe(res.Instance) then return nil end
        return res
    end

    function Nav:InsertNode(nodes, position, instance, minSeparation)
        for _, n in ipairs(nodes or {}) do
            if (n.position - position).Magnitude < minSeparation then
                return false
            end
        end
        table.insert(nodes, { id = #nodes + 1, position = position, instance = instance })
        return true
    end

    function Nav:ScanNodes()
        local nodes = {}
        local minB, maxB = self:ComputeWorldBounds()
        local step = CONFIG.NAV_SCAN_STEP
        local minSep = math.max(4, step * 0.8)
        local maxCount = CONFIG.NAV_MAX_NODE_COUNT

        local startX = math.floor(minB.X / step) * step
        local endX   = math.ceil(maxB.X / step) * step
        local startZ = math.floor(minB.Z / step) * step
        local endZ   = math.ceil(maxB.Z / step) * step
        local castHeight = maxB.Y + CONFIG.NAV_RAYCAST_UP
        local castDepth  = Vector3.new(0, -(maxB.Y - minB.Y + CONFIG.NAV_RAYCAST_DOWN), 0)

        for x = startX, endX, step do
            for z = startZ, endZ, step do
                if #nodes >= maxCount then break end
                local origin = Vector3.new(x, castHeight, z)
                local res = self:RaycastSafe(origin, castDepth)
                if res and res.Normal.Y >= CONFIG.NAV_MAX_SLOPE_Y and not IsVoidArea(res.Position) then
                    self:InsertNode(nodes, res.Position + Vector3.new(0, 2.25, 0), res.Instance, minSep)
                end
            end
            if #nodes >= maxCount then break end
        end
        self.nodes = nodes
        return nodes
    end

    function Nav:ConnectNodes()
        local adj = {}
        for i = 1, #self.nodes do adj[i] = {} end
        for i = 1, #self.nodes do
            local pi = self.nodes[i].position
            for j = i+1, #self.nodes do
                local pj = self.nodes[j].position
                local d = (pi - pj).Magnitude
                if d <= CONFIG.NAV_CONNECT_RADIUS then
                    local dir = (pj - pi)
                    local steps = math.max(1, math.floor(d / 4))
                    local safe = true
                    for s = 1, steps do
                        local p = pi + dir * (s/steps)
                        local res = self:RaycastSafe(p + Vector3.new(0,5,0), Vector3.new(0, -12, 0))
                        if not res or IsVoidArea(res.Position) then safe = false; break end
                    end
                    local dy = pj.Y - pi.Y
                    if safe and dy <= CONFIG.NAV_MAX_ASCENT_HEIGHT and dy >= -CONFIG.NAV_MAX_DROP_HEIGHT then
                        local needsJump = (dy > CONFIG.MIN_JUMP_TRIGGER_HEIGHT)
                        table.insert(adj[i], { id = j, cost = d, jump = needsJump })
                        table.insert(adj[j], { id = i, cost = d, jump = (dy < -CONFIG.MIN_JUMP_TRIGGER_HEIGHT) })
                    end
                end
            end
        end
        self.adjacency = adj
        return adj
    end

    function Nav:NearestNode(pos)
        local bestId, bestDist = nil, math.huge
        for i, n in ipairs(self.nodes or {}) do
            local d = (n.position - pos).Magnitude
            if d < bestDist then bestDist = d; bestId = i end
        end
        return bestId
    end

    function Nav:RebuildIfNeeded()
        if (tick() - (self.lastBuild or 0) > CONFIG.NODE_GRAPH_REBUILD_INTERVAL) or (#self.nodes == 0) then
            self:ScanNodes()
            self:ConnectNodes()
            self.lastBuild = tick()
            persistentData.NodeGraph = { nodes = self.nodes, adjacency = self.adjacency }
            persistentData.NodeGraphBuiltTime = self.lastBuild
        end
    end

    function Nav:h(id, goalPos)
        return (self.nodes[id].position - goalPos).Magnitude
    end

    function Nav:AStar(startPos, goalPos)
        local startId = self:NearestNode(startPos)
        local goalId = self:NearestNode(goalPos)
        if not startId or not goalId then return {} end
        local open = {[startId] = true}
        local came = {}
        local g = {[startId] = 0}
        local f = {[startId] = self:h(startId, goalPos)}
        local function lowestOpen()
            local bid, bf = nil, math.huge
            for id in pairs(open) do
                local fi = f[id] or math.huge
                if fi < bf then bf = fi; bid = id end
            end
            return bid
        end
        while true do
            local cur = lowestOpen()
            if not cur then break end
            if cur == goalId then
                local path = {}
                local id = cur
                while id do
                    table.insert(path, 1, self.nodes[id].position)
                    id = came[id]
                end
                return path
            end
            open[cur] = nil
            for _, e in ipairs(self.adjacency[cur] or {}) do
                local tentative = (g[cur] or math.huge) + e.cost
                if tentative < (g[e.id] or math.huge) then
                    came[e.id] = cur
                    g[e.id] = tentative
                    f[e.id] = tentative + h(e.id)
                    open[e.id] = true
                end
            end
        end
        return {}
    end

    function Nav:ComputePath(startPos, goalPos)
        self:RebuildIfNeeded()
        local fullPath
        if Nav and Nav.AStar then
            fullPath = self:AStar(startPos, goalPos)
        else
            forcePrint("LinkedSwordAI: Nav or Nav.AStar is nil when attempting to compute path.")
            return {}
        end
        local path = {}
        local segmentLength = math.min(#fullPath, CONFIG.PATH_SEGMENT_LENGTH)
        for i = 1, segmentLength do
            table.insert(path, fullPath[i])
        end
        self.path = path
        self.lastTarget = goalPos
        self.lastPathCompute = tick()
        persistentData.NodePath = path
        persistentData.CurrentNodeIndex = 1
        persistentData.LastNodePathComputedTime = tick()
        return path
    end

    function Nav:NextStep(currentPos, goalPos)
        if #self.path == 0 or (self.lastTarget and (goalPos - self.lastTarget).Magnitude > 6) or (tick() - (self.lastPathCompute or 0) > CONFIG.NODE_PATH_RECOMPUTE_INTERVAL) then
            self:ComputePath(currentPos, goalPos)
        end
        local idx = persistentData.CurrentNodeIndex or 1
        local nextPos = self.path[idx]
        if not nextPos then return goalPos end
        if (nextPos - currentPos).Magnitude < 4 then
            persistentData.CurrentNodeIndex = idx + 1
            nextPos = self.path[persistentData.CurrentNodeIndex]
            if not nextPos then return goalPos end
        end
        return nextPos
    end

    function Nav:FollowTo(goalPos)
        if not Humanoid or not HumanoidRootPart or not goalPos then return false end
        local currentPos = HumanoidRootPart.Position
                local stepPos
        if Nav and Nav.NextStep then
            stepPos = self:NextStep(currentPos, goalPos)
        else
            forcePrint("LinkedSwordAI: Nav or Nav.NextStep is nil when attempting to get next step.")
            return false
        end
        if not stepPos then return false end
        local dy = stepPos.Y - currentPos.Y
        if dy > CONFIG.MIN_JUMP_TRIGGER_HEIGHT and dy <= CONFIG.MAX_JUMP_HEIGHT then
            if SafeHumanoidChangeState(Enum.HumanoidStateType.Jumping) then
                -- fall through to MoveTo landing
            end
        end
        -- Rate-limit move commands
        if tick() - (persistentData.LastMoveCommandTime or 0) < CONFIG.MOVE_COMMAND_COOLDOWN then
            return false
        end
        persistentData.LastMoveCommandTime = tick()
        local ok, err = pcall(function()
            Humanoid:MoveTo(stepPos)
        end)
        if not ok then
            forcePrint("LinkedSwordAI: Nav MoveTo failed - " .. tostring(err))
    end        return false
        end
        return true
    end

    -- Safe wrappers now delegate to Nav
    local function SafeHumanoidMoveTo(targetPosition)
        if not Character or not Humanoid or not HumanoidRootPart or not targetPosition then return false end
            if Nav and Nav.FollowTo then
        return Nav:FollowTo(targetPosition)
    else
        forcePrint("LinkedSwordAI: Nav or Nav.FollowTo is nil when attempting to follow target.")
        return false
    end
    end


        local ok = pcall(function()
            Humanoid:ChangeState(state)
        end)
        return ok and true or false

return Nav
    end

    -- Unstucking: expanded directions (16)
    local function HandleStuckOnPlayer()
        if not HumanoidRootPart then return false end
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Unstucking") end
        local directions = {}
        for i = 0, 15 do
            local angle = (i / 16) * 2 * math.pi
            table.insert(directions, Vector3.new(math.cos(angle), 0, math.sin(angle)).Unit)
        end
        for _, dir in ipairs(directions) do
            local targetPosition = HumanoidRootPart.Position + dir * 6
            if IsSafePath(targetPosition) then
                SafeHumanoidMoveTo(targetPosition)
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Moving to unstuck") end
                return true
            end
        end
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("No safe unstuck path") end
        return false
    end

    -- Flee from ForceField players (repaired & functional)
    local function HandleFleeFromForceField()
        if CONFIG.FORCEFIELD_FLEE_DISTANCE <= 0 then return false end
        if not HumanoidRootPart then return false end
        local nearestFF, nearestDist = nil, math.huge
        for _, ffPlayer in pairs(persistentData.PlayersWithForceField) do
            if ffPlayer and ffPlayer.Character and ffPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (ffPlayer.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                if dist < nearestDist then
                    nearestFF = ffPlayer
                    nearestDist = dist
                end
            end
        end
        if nearestFF and nearestDist < CONFIG.FORCEFIELD_FLEE_DISTANCE then
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateStatus("Fleeing FF: " .. nearestFF.Name)
                persistentData.StatusGUI.UpdateDebug("FF distance: " .. string.format("%.1f", nearestDist))
            end
            -- Primary flee direction: away from FF
            local fleeDir = (HumanoidRootPart.Position - nearestFF.Character.HumanoidRootPart.Position)
            if fleeDir.Magnitude == 0 then
                fleeDir = Vector3.new(math.random()-0.5, 0, math.random()-0.5).Unit
            else
                fleeDir = fleeDir.Unit
            end
            -- Preferred flee target at configured distance
            local fleeTarget = HumanoidRootPart.Position + fleeDir * CONFIG.FORCEFIELD_FLEE_DISTANCE

            -- If not safe, try perpendicular evasive maneuvers
            if IsSafePath(fleeTarget) then
                SafeHumanoidMoveTo(fleeTarget)
                return true
            else
                local altDirs = {
                    (fleeDir + Vector3.new(0.4, 0, 0.2)).Unit,
                    (fleeDir + Vector3.new(-0.4, 0, 0.2)).Unit,
                    (fleeDir + Vector3.new(0.2, 0, -0.4)).Unit,
                    (fleeDir + Vector3.new(-0.2, 0, -0.4)).Unit
                }
                for _, ad in ipairs(altDirs or {}) do
                    local altT = HumanoidRootPart.Position + ad * CONFIG.FORCEFIELD_FLEE_DISTANCE
                    if IsSafePath(altT) then
                        SafeHumanoidMoveTo(altT)
                        return true
                    end
                end
            end
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("FF: No safe flee path") end
        end
        return false
    end


    -- Movement helpers and sequential waypoint navigation (replaces nil-forward declarations)
    local function MoveTo(targetPosition, bridgePath, alternativePath)
        if not Humanoid or not HumanoidRootPart or not targetPosition then return false end
        -- Prefer provided bridge/alternative hints, otherwise go via NavManager
        local dest = targetPosition
        if bridgePath then dest = bridgePath elseif alternativePath then dest = alternativePath end
            if Nav and Nav.FollowTo then
        return Nav:FollowTo(dest)
    else
        forcePrint("LinkedSwordAI: Nav or Nav.FollowTo is nil when attempting to follow destination.")
        return false
    end
    end

    local function TryJumpTo(position)
        if not Humanoid or not HumanoidRootPart or not position then return false end
        local dy = position.Y - HumanoidRootPart.Position.Y
        -- Respect NavManager thresholds, avoid spam jumps
        if dy > (CONFIG.MIN_JUMP_TRIGGER_HEIGHT or 0.5) and dy <= (CONFIG.MAX_JUMP_HEIGHT or 6) then
            if tick() - (persistentData.LastJumpTime or 0) < (CONFIG.JUMP_COOLDOWN or 0.8) then return false end
            persistentData.LastJumpTime = tick()
            return SafeHumanoidChangeState(Enum.HumanoidStateType.Jumping)
        end
        return false
    end

    local function ExecuteAttack()
        if not persistentData.LinkedSword then return false end
        if tick() - (persistentData.LastAttackTime or 0) < (CONFIG.ATTACK_COOLDOWN or 0.6) then return false end
        persistentData.LastAttackTime = tick()
        pcall(function() persistentData.LinkedSword:Activate() end)
        return true
    end

    -- Sequential waypoint navigation utilities
    local function SetSequentialWaypoints(points, loop)
        if type(points) ~= "table" then return false end
        local validated = {}
        for i, p in ipairs(points or {}) do
            if typeof(p) == "Vector3" then
                table.insert(validated, p)
            end
        end
        if #validated == 0 then return false end
        persistentData.SequentialWaypoints = validated
        persistentData.WaypointIndex = 1
        persistentData.WaypointLoop = (loop == true)
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Waypoints loaded: " .. tostring(#validated)) end
        return true
    end

    local function NavigateSequentialWaypoints()
        local pts = persistentData.SequentialWaypoints
        if not pts or #pts == 0 then return false end
        local idx = persistentData.WaypointIndex or 1
        local wp = pts[idx]
        if not wp then return false end
        if HumanoidRootPart then
            local d = (HumanoidRootPart.Position - wp).Magnitude
            if d <= 2.5 then
                persistentData.WaypointIndex = idx + 1
                if persistentData.WaypointIndex > #pts then
                    if persistentData.WaypointLoop then
                        persistentData.WaypointIndex = 1
                    else
                        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Waypoints complete") end
                        return false
                    end
                end
                return true
            end
            -- attempt to move towards waypoint safely; use bridge if available
            local safe = IsSafePath(wp)
            if safe then
                SafeHumanoidMoveTo(wp)
            else
                local bridge = FindBridgePath(HumanoidRootPart.Position, wp)
                if bridge then
                    SafeHumanoidMoveTo(bridge)
                else
                    -- still attempt direct move to progress
                    SafeHumanoidMoveTo(wp)
                end
            end
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Navigating waypoint " .. tostring(idx) .. "/" .. tostring(#pts)) end
            return true
        end
        return false
    end

    -- Global setter to allow external configuration from command bar or other scripts
    _G.LinkedSwordAI_SetWaypoints = function(points, loop)
        _G.LinkedSwordAISequentialWaypoints = points
        _G.LinkedSwordAIWaypointLoop = loop
        if persistentData then
            SetSequentialWaypoints(points, loop)
        end
    end

    -- Also expose a cross-LocalScript BindableFunction API to avoid _G ordering issues
    do
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local bf = ReplicatedStorage:FindFirstChild("LinkedSwordAI_SetWaypoints")
        if not bf then
            bf = Instance.new("BindableFunction")
            bf.Name = "LinkedSwordAI_SetWaypoints"
            bf.Parent = ReplicatedStorage
        end
        bf.OnInvoke = function(points, loop)
            return SetSequentialWaypoints(points, loop)
        end
    end



    -- World autoscan helpers for advanced pathfinding
    local function ComputeWorldBounds()
        local minX, minY, minZ = math.huge, math.huge, math.huge
        local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge
        for _, inst in ipairs(Workspace:GetDescendants()) do
            if inst:IsA("BasePart") and not isPartUnsafe(inst) then
                local cf, size = inst.CFrame, inst.Size
                local corners = {
                    cf:PointToWorldSpace(Vector3.new( size.X/2,  size.Y/2,  size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new(-size.X/2,  size.Y/2,  size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new( size.X/2,  size.Y/2, -size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new(-size.X/2,  size.Y/2, -size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new( size.X/2, -size.Y/2,  size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new(-size.X/2, -size.Y/2,  size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new( size.X/2, -size.Y/2, -size.Z/2)),
                    cf:PointToWorldSpace(Vector3.new(-size.X/2, -size.Y/2, -size.Z/2)),
                }
                for _, p in ipairs(corners) do
                    minX = math.min(minX, p.X); minY = math.min(minY, p.Y); minZ = math.min(minZ, p.Z)
                    maxX = math.max(maxX, p.X); maxY = math.max(maxY, p.Y); maxZ = math.max(maxZ, p.Z)
                end
            end
        end
        if minX == math.huge then
            if HumanoidRootPart then
                local p = HumanoidRootPart.Position
                local r = 200
                return Vector3.new(p.X-r, p.Y-50, p.Z-r), Vector3.new(p.X+r, p.Y+50, p.Z+r)
            else
                return Vector3.new(-200,-50,-200), Vector3.new(200,50,200)
            end
        end
        return Vector3.new(minX, minY, minZ), Vector3.new(maxX, maxY, maxZ)
    end

    local function InsertNode(nodes, position, instance, minSeparation)
        for _, n in ipairs(nodes or {}) do
            if (n.position - position).Magnitude < minSeparation then
                return false
            end
        end
        table.insert(nodes, { id = #nodes + 1, position = position, instance = instance })
        return true
    end

    local function AutoscanNavNodes(existingNodes)
        local nodes = existingNodes or {}
        local minB, maxB = ComputeWorldBounds()
        local step = CONFIG.NAV_SCAN_STEP
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {Character}
        params.FilterType = Enum.RaycastFilterType.Blacklist
        local minSep = math.max(4, step * 0.8)
        local maxCount = CONFIG.NAV_MAX_NODE_COUNT

        local startX = math.floor(minB.X / step) * step
        local endX   = math.ceil(maxB.X / step) * step
        local startZ = math.floor(minB.Z / step) * step
        local endZ   = math.ceil(maxB.Z / step) * step
        local castHeight = maxB.Y + CONFIG.NAV_RAYCAST_UP
        local castDepth  = Vector3.new(0, -(maxB.Y - minB.Y + CONFIG.NAV_RAYCAST_DOWN), 0)

        for x = startX, endX, step do
            for z = startZ, endZ, step do
                if #nodes >= maxCount then break end
                local origin = Vector3.new(x, castHeight, z)
                local res = Workspace:Raycast(origin, castDepth, params)
                if res and res.Instance and not isPartUnsafe(res.Instance) then
                    if res.Normal.Y >= CONFIG.NAV_MAX_SLOPE_Y and not IsVoidArea(res.Position) then
                        InsertNode(nodes, res.Position + Vector3.new(0, 2.25, 0), res.Instance, minSep)
                    end
                end
            end
            if #nodes >= maxCount then break end
        end
        return nodes
    end

    -- Build the node graph from Workspace folders and autoscan
    local function BuildNodeGraph()
        local folders = {}
        for _, name in ipairs(CONFIG.NODE_FOLDER_NAMES or {}) do
            local f = Workspace:FindFirstChild(name)
            if f then table.insert(folders, f) end
        end
        local nodes = {}
        for _, folder in ipairs(folders or {}) do
            for _, inst in ipairs(folder:GetChildren()) do
                if inst:IsA("BasePart") then
                    table.insert(nodes, { id = #nodes+1, position = inst.Position, instance = inst })
                end
            end
        end
        if #nodes == 0 then
            for _, inst in ipairs(Workspace:GetDescendants() or {}) do
                if inst:IsA("BasePart") and tostring(inst.Name):lower():match("^node%d+") then
                    table.insert(nodes, { id = #nodes+1, position = inst.Position, instance = inst })
                end
            end
        end
        if CONFIG.USE_AUTOSCAN_NODES then
            nodes = AutoscanNavNodes(nodes)
        end
        if #nodes < (CONFIG.NAV_MIN_NODE_THRESHOLD or 20) then
            persistentData.NodeGraph = { nodes = {}, adjacency = {} }
            persistentData.NodeGraphBuiltTime = tick()
            return false
        end
        for i, n in ipairs(navNodes or {}) do n.id = i end
        local adjacency = {}
        for i = 1, #nodes do adjacency[i] = {} end
        local connectRadius = math.min(CONFIG.NODE_MAX_LINK_DISTANCE, CONFIG.NAV_CONNECT_RADIUS)
        for i = 1, #nodes do
            local a = nodes[i].position
            for j = i + 1, #nodes do
                local b = nodes[j].position
                local dist = (b - a).Magnitude
                if dist <= connectRadius then
                    local dy = b.Y - a.Y
                    if (dy >= -CONFIG.NAV_MAX_DROP_HEIGHT) and (dy <= CONFIG.NAV_MAX_ASCENT_HEIGHT) then
                        if IsSafeGap(a, b) then
                            table.insert(adjacency[i], j)
                            table.insert(adjacency[j], i)
                        end
                    end
                end
            end
        end
        persistentData.NodeGraph = { nodes = nodes, adjacency = adjacency }
        persistentData.NodeGraphBuiltTime = tick()
        return #nodes > 0
    end

    -- Find nearest node by position
    local function FindNearestNode(position)
        local graph = persistentData.NodeGraph
        if not graph or not graph.nodes or #graph.nodes == 0 then return nil end
        local bestId, bestDist = nil, math.huge
        for id, node in pairs(graph.nodes) do
            local d = (node.position - position).Magnitude
            if d < bestDist then
                bestDist = d
                bestId = id
            end
        end
        return bestId
    end

    local function ComputeNodePath(startPos, goalPos)
        if (not persistentData.NodeGraph) or (not persistentData.NodeGraph.nodes) or #persistentData.NodeGraph.nodes == 0 then
            local lastBuilt = persistentData.NodeGraphBuiltTime or 0
            if tick() - lastBuilt >= CONFIG.NODE_GRAPH_REBUILD_INTERVAL then
                local ok = BuildNodeGraph()
                if not ok then return nil end
            else
                return nil
            end
        end
        local startId = FindNearestNode(startPos)
        local goalId = FindNearestNode(goalPos)
        if not startId or not goalId then return nil end
        if startId == goalId then
            persistentData.NodePath = { persistentData.NodeGraph.nodes[startId].position }
            persistentData.CurrentNodeIndex = 1
            persistentData.LastNodePathComputedTime = tick()
            return persistentData.NodePath
        end
        local adj = persistentData.NodeGraph.adjacency
        local visited, prev = {}, {}
        local queue = { startId }
        visited[startId] = true
        local found = false
        while #queue > 0 do
            local u = table.remove(queue, 1)
            if u == goalId then found = true break end
            for _, v in ipairs(adj[u] or {}) do
                if not visited[v] then
                    visited[v] = true
                    prev[v] = u
                    table.insert(queue, v)
                end
            end
        end
        if not found then return nil end
        local pathIdxs = {}
        local cur = goalId
        while cur do
            table.insert(pathIdxs, 1, cur)
            cur = prev[cur]
        end
        local positions = {}
        for _, id in ipairs(pathIdxs) do
            table.insert(positions, persistentData.NodeGraph.nodes[id].position)
        end
        persistentData.NodePath = positions
        persistentData.CurrentNodeIndex = 1
        persistentData.LastNodePathComputedTime = tick()
        return positions
    end

    local function ShouldSwitchToNodeNavigation(currentPos, targetPos, isGroundSafe)
        if not isGroundSafe then return true end
        local dir = (targetPos - currentPos)
        if dir.Magnitude == 0 then return false end
        dir = dir.Unit
        for dist = 4, CONFIG.NODE_SWITCH_VOID_DISTANCE, 4 do
            local p = currentPos + dir * dist
            if IsVoidArea(p) then return true end
        end
        return false
    end

    local function FollowNodePath()
        local path = persistentData.NodePath
        if not Character or not HumanoidRootPart then return false end
        if not path or #path == 0 then return false end
        local idx = persistentData.CurrentNodeIndex or 1
        if idx > #path then return false end
        local waypoint = path[idx]
        local dist = (waypoint - HumanoidRootPart.Position).Magnitude
        if dist < 4 then
            persistentData.CurrentNodeIndex = idx + 1
            return true
        end
        local deltaY = waypoint.Y - HumanoidRootPart.Position.Y
        if deltaY < -1 and math.abs(deltaY) <= CONFIG.LEDGE_SAFE_DROP_HEIGHT then
            if SafeHumanoidChangeState(Enum.HumanoidStateType.Jumping) then
                SafeHumanoidMoveTo(waypoint)
            else
                MoveTo(waypoint)
            end
        else
            MoveTo(waypoint)
        end
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("NodeNav -> waypoint #" .. tostring(idx)) end
        return true
    end

    local function DetectObstacleAhead(direction, checkDistance)
        if not Character or not HumanoidRootPart then return "clear", nil end
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {Character}
        params.FilterType = Enum.RaycastFilterType.Blacklist
        local rayRes = Workspace:Raycast(HumanoidRootPart.Position, direction * checkDistance, params)
        if rayRes and rayRes.Instance then
            local hitPos = rayRes.Position
            local topCheck = Workspace:Raycast(hitPos + Vector3.new(0, CONFIG.MAX_JUMP_HEIGHT + 1, 0), Vector3.new(0, -(CONFIG.MAX_JUMP_HEIGHT + 2), 0), params)
            local topY = topCheck and topCheck.Position.Y or hitPos.Y
            local heightDiff = topY - HumanoidRootPart.Position.Y

            -- Slope detection
            local downRay = Workspace:Raycast(hitPos + Vector3.new(0, 0.1, 0), Vector3.new(0, -0.5, 0), params)
            if downRay and downRay.Normal then
                local slopeAngle = math.deg(math.acos(downRay.Normal:Dot(Vector3.new(0, 1, 0))))
                if slopeAngle > CONFIG.MAX_SLOPE_ANGLE then
                    return "slope", hitPos
                end
            end

            if heightDiff >= CONFIG.MIN_JUMP_TRIGGER_HEIGHT and heightDiff <= CONFIG.MAX_JUMP_HEIGHT then
                return "jumpable", hitPos
            elseif heightDiff > CONFIG.MAX_JUMP_HEIGHT then
                return "wall", hitPos
            end
        end
        return "clear", nil
    end

    -- Movement with smoothing and continuous operation (improved)
    MoveTo = function(targetPosition, bridgePath, alternativePath)
        if not Character or not HumanoidRootPart or not Humanoid or not targetPosition then return false end
        -- Always try to maintain continuous movement; if path unsafe pick alternative and keep moving
        local startTime = tick()

        -- Stabilize target switching to reduce flicker
        if persistentData.CurrentNavigationTarget and (tick() - (persistentData.NavigationTransitionStart or 0)) < CONFIG.MOVE_COMMAND_COOLDOWN then
            targetPosition = persistentData.CurrentNavigationTarget
        end

        if bridgePath then
            targetPosition = bridgePath
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Using bridge path") end
        end
        if alternativePath then
            targetPosition = alternativePath
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Using alternative path") end
        end

        -- Compute direction (guard against zero)
        local dirVec = (targetPosition - HumanoidRootPart.Position)
        if dirVec.Magnitude == 0 then
            -- tiny random nudge to keep movement alive
            dirVec = Vector3.new(0.01, 0, 0.01)
        end
        dirVec = dirVec.Unit

        local currentTime = tick()
        local smoothedDirection = dirVec
        if persistentData.LastMovementDirection and currentTime - persistentData.LastMovementTime < CONFIG.MOVEMENT_MEMORY_TIME then
            smoothedDirection = (persistentData.LastMovementDirection * CONFIG.PATH_SMOOTHING_FACTOR +
                                 dirVec * (1 - CONFIG.PATH_SMOOTHING_FACTOR)).Unit
        end

        local moveDistance = math.min(5, (targetPosition - HumanoidRootPart.Position).Magnitude)
        local smoothedTarget = HumanoidRootPart.Position + smoothedDirection * moveDistance

        -- Narrow passage handling (less smoothing)
        if IsNarrowPassage(HumanoidRootPart.Position, smoothedDirection) then
            smoothedDirection = dirVec
            smoothedTarget = HumanoidRootPart.Position + smoothedDirection * math.min(CONFIG.NARROW_STEP_DISTANCE, (targetPosition - HumanoidRootPart.Position).Magnitude)
        end

        -- Obstacle detection ahead: jump over low obstacles or switch to node navigation on walls
        do
            local obsType, hitPos = DetectObstacleAhead(smoothedDirection, CONFIG.WALL_DETECT_DISTANCE)
            if obsType == "jumpable" or obsType == "slope" then
                if SafeHumanoidChangeState(Enum.HumanoidStateType.Jumping) then
                    SafeHumanoidMoveTo(smoothedTarget)
                    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Jumping over obstacle/slope") end
                    return true
                end
            elseif obsType == "wall" then
                local useNode = ShouldSwitchToNodeNavigation(HumanoidRootPart.Position, targetPosition, false)
                if useNode then
                    if (not persistentData.NodePath) or (#(persistentData.NodePath or {}) == 0) or (tick() - (persistentData.LastNodePathComputedTime or 0) > CONFIG.NODE_PATH_RECOMPUTE_INTERVAL) then
                        ComputeNodePath(HumanoidRootPart.Position, targetPosition)
                    end
                    if FollowNodePath() then
                        return true
                    end
                end
            end
        end

        -- If safe gap, move; otherwise attempt to find nearest safe alternative (do not stop)
        if IsSafeGap(HumanoidRootPart.Position, smoothedTarget) then
            persistentData.LastMovementDirection = smoothedDirection
            persistentData.LastMovementTime = currentTime
            persistentData.CurrentNavigationTarget = targetPosition
            persistentData.NavigationTransitionStart = currentTime
            SafeHumanoidMoveTo(smoothedTarget)
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Moving to smoothed target") end
            if CONFIG.PERFORMANCE_MODE then persistentData.PerformanceStats.MovementTime = tick() - startTime end
            return true
        else
            -- find alternative targets around (16 directions), choose the safest nearest one, keep moving
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Unsafe path - finding alternatives") end
            local bestAlt = nil
            local bestScore = math.huge
            for i = 0, 15 do
                local angle = (i / 16) * 2 * math.pi
                local dir = Vector3.new(math.cos(angle), 0, math.sin(angle)).Unit
                local altPos = HumanoidRootPart.Position + dir * math.max(4, moveDistance)
                local safe, altBridge = IsSafePath(altPos)
                if safe then
                    local score = (altPos - targetPosition).Magnitude
                    if score < bestScore then
                        bestScore = score
                        bestAlt = altPos
                    end
                end
            end
            -- if we found an alternative, move there; otherwise try small jump forward if plausible
            if bestAlt then
                persistentData.LastMovementDirection = (bestAlt - HumanoidRootPart.Position).Unit
                persistentData.LastMovementTime = currentTime
                SafeHumanoidMoveTo(bestAlt)
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Moving to alternative") end
                return true
            else
                -- try a careful jump forward toward target if gap small and jump likely safe
                local jumpVec = HumanoidRootPart.Position + dirVec * (moveDistance + CONFIG.JUMP_SAFE_MARGIN)
                if IsSafePath(jumpVec) then
                    -- attempt jump: trigger Humanoid jump and move to landing
                    if SafeHumanoidChangeState(Enum.HumanoidStateType.Jumping) then
                    SafeHumanoidMoveTo(jumpVec)
                    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Attempting jump") end
                    return true
                end
                end
            end
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("No safe alt found - waiting minimal time") end
            return false
        end
    end

    -- Intelligent jump helper for traversing void areas (used sparingly)
    TryJumpTo = function(targetPos)
        if not Character or not HumanoidRootPart or not Humanoid or not targetPos then return false end
        -- compute required velocity/timing heuristics (simple)
        local distance = (targetPos - HumanoidRootPart.Position).Magnitude
        if distance < 3 then
            -- close - simple jump
            if SafeHumanoidChangeState(Enum.HumanoidStateType.Jumping) then
                SafeHumanoidMoveTo(targetPos)
                return true
            end
            return false
        end
        -- For longer jumps, ensure landing spot safe
        if IsSafePath(targetPos) then
            if SafeHumanoidChangeState(Enum.HumanoidStateType.Jumping) then
                SafeHumanoidMoveTo(targetPos)
                return true
            end
        end
        return false
    end

    -- Attack execution with enhanced tactics
    ExecuteAttack = function()
        if not persistentData.LinkedSword or not Character or not Humanoid or not HumanoidRootPart then
            debugPrint("COMBAT", "Cannot attack - core refs missing or no sword")
            return
        end
        if persistentData.AttackSequenceActive then return end
        persistentData.AttackSequenceActive = true
        persistentData.LastAttackTime = tick()

        -- pick behavior if needed
        if not persistentData.CurrentCombatBehavior or tick() - (persistentData.LastBehaviorChangeTime or 0) > CONFIG.COMBAT_BEHAVIOR_CHANGE_TIME then
            local r = math.random()
            if r < CONFIG.COMBAT_DEFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "defensive"
            elseif r < CONFIG.COMBAT_DEFENSIVE_CHANCE + CONFIG.COMBAT_OFFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "offensive"
            else
                persistentData.CurrentCombatBehavior = "offensive-defensive"
            end
            persistentData.LastBehaviorChangeTime = tick()
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Combat: " .. persistentData.CurrentCombatBehavior) end
        end

        -- Face target
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character and persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") and HumanoidRootPart then
            local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
            HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position, Vector3.new(targetPos.X, HumanoidRootPart.Position.Y, targetPos.Z))
        end

        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Attacking: " .. (persistentData.CurrentCombatBehavior or "unknown")) end

        -- Attack sequence (spawned so movement loop not blocked)
        spawn(function()
            local behavior = persistentData.CurrentCombatBehavior or "offensive-defensive"
            local targetHRP = persistentData.CurrentTarget and persistentData.CurrentTarget.Character and persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
            local distance = (targetHRP and HumanoidRootPart) and (targetHRP.Position - HumanoidRootPart.Position).Magnitude or math.huge

            -- Determine if we should perform deceptive partial lunge (bait)
            local doDeceptive = (distance > CONFIG.MIN_ATTACK_DISTANCE and distance <= CONFIG.ATTACK_RANGE + 4) and math.random() < 0.5

            if behavior == "defensive" then
                -- Defensive: keep range, bait, then strike
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.3)
                if doDeceptive then
                    -- small forward lunge to bait
                    if targetHRP and HumanoidRootPart then
                        local dir = (targetHRP.Position - HumanoidRootPart.Position).Unit
                        local baitPos = HumanoidRootPart.Position + dir * 1.6
                        MoveTo(baitPos)
                        wait(0.12)
                        pcall(function() persistentData.LinkedSword:Activate() end)
                        -- back off
                        local backPos = HumanoidRootPart.Position - dir * 2
                        MoveTo(backPos)
                    end
                else
                    pcall(function() persistentData.LinkedSword:Activate() end)
                end
                wait(CONFIG.LUNGE_DELAY * 1.6)
                pcall(function() persistentData.LinkedSword:Activate() end)

            elseif behavior == "offensive" then
                -- Aggressive approach, faster lunges and follow-up
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.5)
                if targetHRP and HumanoidRootPart then
                    local dir = (targetHRP.Position - HumanoidRootPart.Position).Unit
                    -- Quick lunge forward with increased speed: move closer
                    local forwardPos = HumanoidRootPart.Position + dir * (2.5 * CONFIG.LUNGE_SPEED_MULTIPLIER)
                    MoveTo(forwardPos)
                end
                wait(CONFIG.LUNGE_DELAY * 0.6)
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.5)
                pcall(function() persistentData.LinkedSword:Activate() end)

            else
                -- offensive-defensive with strafing
                pcall(function() persistentData.LinkedSword:Activate() end)

                if targetHRP and HumanoidRootPart then
                    local dir = (targetHRP.Position - HumanoidRootPart.Position).Unit
                    local strafeDir = dir:Cross(Vector3.new(0,1,0)).Unit
                    if math.random() > 0.5 then strafeDir = -strafeDir end
                    local strafePos = HumanoidRootPart.Position + strafeDir * CONFIG.STRAFE_DISTANCE
                    MoveTo(strafePos)
                    wait(0.06)
                end

                wait(CONFIG.LUNGE_DELAY)
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY)
                if targetHRP and HumanoidRootPart then
                    local dir = (targetHRP.Position - HumanoidRootPart.Position).Unit
                    local approachPos = HumanoidRootPart.Position + dir * 1.8
                    MoveTo(approachPos)
                end
                pcall(function() persistentData.LinkedSword:Activate() end)
            end

            -- Increased chance of aggressive follow-up when target was out of range for some time
            local timeSinceInRange = tick() - (persistentData.LastInRangeTime or 0)
            if timeSinceInRange > CONFIG.OUT_OF_RANGE_AGGRESSION_TIME then
                -- immediate aggressive burst
                local bursts = math.random(1,2)
                for i = 1, bursts do
                    wait(0.06)
                    pcall(function() persistentData.LinkedSword:Activate() end)
                end
            end

            -- short cooldown
            wait(0.18)
            persistentData.AttackSequenceActive = false
        end)
    end

    -- Update loop logic
    local function Update()
        -- early guards
        if not Character or not Humanoid or not HumanoidRootPart then
            local lp = game:GetService("Players").LocalPlayer
            if lp then
                Character = Character or lp.Character
                if not Character then
                    local okWait, res = pcall(function() return lp.CharacterAdded:Wait() end)
                    if okWait then Character = res end
                end
                if Character then
                    pcall(function()
                        Humanoid = Humanoid or Character:FindFirstChild("Humanoid") or Character:WaitForChild("Humanoid", 2)
                        HumanoidRootPart = HumanoidRootPart or Character:FindFirstChild("HumanoidRootPart") or Character:WaitForChild("HumanoidRootPart", 2)
                    end)
                end
            end
        end
        if not Character or not Humanoid or not HumanoidRootPart then
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Waiting for character...") end
            return
        end

        persistentData.PrioritizePathfinding = ShouldPrioritizePathfinding()

        -- adaptive periodic garbage collection
        local currentTime = tick()
        local perf = persistentData.PerformanceStats

        -- use recorded pathfinding time (default to 0 if nil)
        local recentPath = perf.PathfindingTime or 0
        -- Waypoint-first navigation: follow designated path in order when provided
        if persistentData.SequentialWaypoints and #persistentData.SequentialWaypoints > 0 then
            if NavigateSequentialWaypoints() then
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Following designated path") end
                return
            end
        end

        -- adapt GC interval based on recent pathfinding time
        local targetVal = 30 - math.min(20, recentPath)
        local newInterval = math.clamp(targetVal, CONFIG.GC_MIN_INTERVAL, CONFIG.GC_MAX_INTERVAL)
        persistentData.GCInterval = newInterval

        if currentTime - (persistentData.LastGCTime or 0) > persistentData.GCInterval then
            -- attempt collector (Roblox/Luau: collectgarbage available in many environments)
            pcall(function()
                if collectgarbage then
                    collectgarbage("collect")
                end
            end)
            persistentData.LastGCTime = currentTime
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdatePerf("GC at " .. string.format("%.1f", currentTime)) end
            debugPrint("PERF", "Garbage collected; next in", persistentData.GCInterval)
        end

        -- Periodic maintenance / cleanup of caches
        if CONFIG.PERFORMANCE_MODE and currentTime - (perf.LastOptimizationTime or 0) > 25 then
            -- Trim path cache oldest entries if too large
            local count = 0
            local oldestKey, oldestTime = nil, math.huge
            for k, v in pairs(persistentData.PathCache) do
                count = count + 1
                if v.time < oldestTime then
                    oldestTime = v.time
                    oldestKey = k
                end
            end
            if count > CONFIG.PATH_CACHE_CAPACITY and oldestKey then
                persistentData.PathCache[oldestKey] = nil
            end
            -- Cleanup failed paths older than 25s
            for i = #persistentData.FailedPaths, 1, -1 do
                if currentTime - persistentData.FailedPaths[i].time > 25 then
                    table.remove(persistentData.FailedPaths, i)
                end
            end
            perf.LastOptimizationTime = currentTime
            debugPrint("PERF", "Optimization complete")
        end

        -- Sword checks
        CheckForSword()

        -- Early branch: sequential waypoint navigation overrides other behaviors when configured
        if persistentData.SequentialWaypoints and (persistentData.WaypointIndex or 0) >= 1 then
            local progressed = NavigateSequentialWaypoints()
            if progressed then
                -- Skip combat/retargeting this frame while following waypoints
                return
            end
        end

        -- Target selection & retargeting
        local needNewTarget = not persistentData.CurrentTarget or not persistentData.CurrentTarget.Character or not persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        local shouldCheck = currentTime - persistentData.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME

        if needNewTarget or shouldCheck then
            local playersInRange = FindPlayersInRange()
            if #playersInRange > 0 then
                local newTarget = playersInRange[1].player
                if newTarget ~= persistentData.CurrentTarget then
                    persistentData.CurrentTarget = newTarget
                    if persistentData.StatusGUI then
                        persistentData.StatusGUI.UpdateTarget(newTarget.Name)
                        persistentData.StatusGUI.UpdateStatus("Targeting " .. newTarget.Name)
                    end
                    debugPrint("TARGET", "New target - " .. newTarget.Name)
                end
            else
                if persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateStatus("No targets in range")
                    persistentData.StatusGUI.UpdateTarget("None")
                end
                persistentData.CurrentTarget = nil
            end
            persistentData.LastRetargetTime = currentTime
        end

        -- If we have a target: movement + combat decisions
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character and persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") and HumanoidRootPart then
            local targetHRP = persistentData.CurrentTarget.Character.HumanoidRootPart
            local distance = (targetHRP and HumanoidRootPart) and (targetHRP.Position - HumanoidRootPart.Position).Magnitude or math.huge
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDistance(distance) end

            -- Track last time we were in attack range
            if distance <= CONFIG.ATTACK_RANGE then
                persistentData.LastInRangeTime = currentTime
            end

            -- Stuck handling
            if CheckIfStuck() then
                HandleStuckOnPlayer()
                return
            else
                persistentData.IsStuck = false
            end

            -- ForceField flee priority (if necessary)
            if HandleFleeFromForceField() then
                -- When fleeing, skip other actions this frame
                return
            end

            -- Path safety check
            local isSafe, bridgePath, alternativePath = IsSafePath(targetHRP.Position)
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PerformanceStats.PathfindingTime = tick() - currentTime
            end
            local useNodeNav = ShouldSwitchToNodeNavigation(HumanoidRootPart.Position, targetHRP.Position, isSafe)
            if useNodeNav then
                if (not persistentData.NodePath) or (#(persistentData.NodePath or {}) == 0) or (currentTime - (persistentData.LastNodePathComputedTime or 0) > CONFIG.NODE_PATH_RECOMPUTE_INTERVAL) then
                    ComputeNodePath(HumanoidRootPart.Position, targetHRP.Position)
                end
                if FollowNodePath() then
                    if HumanoidRootPart and targetHRP then
                        HumanoidRootPart.CFrame = CFrame.lookAt(HumanoidRootPart.Position, Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z))
                    end
                    return
                end
            end

            -- Continuous movement: prefer safe path; if not safe use alternative / bridge / find other routes without stopping
            if isSafe then
                MoveTo(targetHRP.Position, bridgePath, alternativePath)
            else
                MoveTo(targetHRP.Position, bridgePath, alternativePath)
            end

            -- Attack gating by distance and elevation
            local deltaY = math.abs(targetHRP.Position.Y - HumanoidRootPart.Position.Y)
            if not persistentData.PrioritizePathfinding and distance <= CONFIG.ENGAGE_MAX_DISTANCE and deltaY <= CONFIG.ATTACK_ELEVATION_TOLERANCE then
                if distance <= CONFIG.IMMEDIATE_ATTACK_RADIUS and (currentTime - (persistentData.LastAttackTime or 0)) >= CONFIG.ATTACK_COOLDOWN then
                    ExecuteAttack()
                elseif distance <= CONFIG.ATTACK_RANGE and (currentTime - (persistentData.LastAttackTime or 0)) >= CONFIG.ATTACK_COOLDOWN then
                    ExecuteAttack()
                end
            else
                -- too far or height mismatch: avoid spam, keep moving to close gap
            end

            -- If current direct path is unsafe, attempt bridge and radial alternatives
            if not isSafe then
                if persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateDebug("No safe direct path")
                end

                local bridge = FindBridgePath(HumanoidRootPart.Position, targetHRP.Position)
                if bridge then
                    MoveTo(bridge)
                    return
                end

                -- try radial alternatives (16)
                local found = false
                for i = 0, 15 do
                    local angle = (i / 16) * 2 * math.pi
                    local dir = Vector3.new(math.cos(angle), 0, math.sin(angle)).Unit
                    local altTarget = HumanoidRootPart.Position + dir * 10
                    local altSafe, altBridge = IsSafePath(altTarget)
                    if altSafe then
                        MoveTo(altTarget, altBridge)
                        found = true
                        break
                    end
                end

                if not found and persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateDebug("No safe alternatives found this update")
                end
            end

            -- Defensive stance when stationary and opponent proximity
            if HumanoidRootPart.Velocity.Magnitude < 1.5 and distance <= (CONFIG.ATTACK_RANGE + 6) then
                -- face opponent and take guarded posture (back off slightly)
                if distance < CONFIG.ATTACK_RANGE and HumanoidRootPart then
                    local dir = (HumanoidRootPart.Position - targetHRP.Position).Unit
                    local backPos = HumanoidRootPart.Position + dir * 1.6
                    MoveTo(backPos)
                    persistentData.CurrentCombatBehavior = "defensive"
                end
            end

        else
            -- Idle: roam the map using node graph with vertical transitions; fallback to small wander
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Idle - Roaming") end
            local hasGraph = (persistentData.NodeGraph and persistentData.NodeGraph.nodes and #persistentData.NodeGraph.nodes > 0) or false
            if not hasGraph then
                local lastBuilt = persistentData.NodeGraphBuiltTime or 0
                if tick() - lastBuilt >= CONFIG.NODE_GRAPH_REBUILD_INTERVAL then
                    hasGraph = BuildNodeGraph()
                else
                    hasGraph = false
                end
            end
            if hasGraph and HumanoidRootPart then
                local now = tick()
                local needRecompute = (now - (persistentData.LastRoamRecomputeTime or 0) > CONFIG.ROAM_RECOMPUTE_INTERVAL) or (not persistentData.NodePath or #persistentData.NodePath == 0)
                if needRecompute then
                    persistentData.LastRoamRecomputeTime = now
                    -- choose a roam destination node within configured distance bounds
                    local candidates = {}
                    for id, node in ipairs(persistentData.NodeGraph.nodes) do
                        local d = (node.position - HumanoidRootPart.Position).Magnitude
                        if d >= CONFIG.ROAM_MIN_DISTANCE and d <= CONFIG.ROAM_MAX_DISTANCE then
                            table.insert(candidates, id)
                        end
                    end
                    if #candidates > 0 then
                        local pick = candidates[math.random(1, #candidates)]
                        persistentData.RoamNodeId = pick
                        ComputeNodePath(HumanoidRootPart.Position, persistentData.NodeGraph.nodes[pick].position)
                    end
                end
                if FollowNodePath() then
                    -- Successfully following roam path across levels/bridges
                else
                    -- fallback small wander to avoid stalling
                    if not persistentData.CurrentNavigationTarget or (tick() - (persistentData.NavigationTransitionStart or 0)) > 3 then
                        local randDir = Vector3.new(math.random()-0.5, 0, math.random()-0.5).Unit
                        local wanderTarget = HumanoidRootPart.Position + randDir * 4
                        if IsSafePath(wanderTarget) then
                            MoveTo(wanderTarget)
                        end
                    end
                end
            else
                -- No graph available -> minimal wander
                if HumanoidRootPart then
                    if not persistentData.CurrentNavigationTarget or (tick() - (persistentData.NavigationTransitionStart or 0)) > 3 then
                        local randDir = Vector3.new(math.random()-0.5, 0, math.random()-0.5).Unit
                        local wanderTarget = HumanoidRootPart.Position + randDir * 4
                        if IsSafePath(wanderTarget) then
                            MoveTo(wanderTarget)
                        end
                    end
                end
            end
        end
    end

    -- Faster, robust sword equip that retries (works around tool disappearing issues)
    spawn(function()
        wait(CONFIG.RESPAWN_EQUIP_DELAY)
        local attempts = 0
        while attempts < 8 do
            attempts = attempts + 1
            persistentData.LinkedSword = FindLinkedSword()
            if persistentData.LinkedSword then
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Sword found: " .. persistentData.LinkedSword.Name) end
                -- attempt equip by parenting to character
                if persistentData.LinkedSword.Parent ~= Character then
                    persistentData.LinkedSword.Parent = Character
                    wait(0.25)
                    if persistentData.LinkedSword.Parent == Character then
                        persistentData.EquipmentReady = true
                        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Sword equipped") end
                        break
                    else
                        -- retry quickly
                        wait(0.25)
                    end
                else
                    persistentData.EquipmentReady = true
                    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Sword already equipped") end
                    break
                end
            else
                -- no sword found; keep trying until attempts exhausted
                wait(0.25)
            end
        end
        if not persistentData.EquipmentReady then
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Failed to equip sword") end
        end
    end)

    -- initialize pointers
    persistentData.LinkedSword = FindLinkedSword()
    persistentData.LastSwordCheckTime = tick()

    -- Cleanup any previous connections before creating new ones
    if persistentData.Connections and persistentData.Connections.UpdateConn then
        pcall(function() persistentData.Connections.UpdateConn:Disconnect() end)
        persistentData.Connections.UpdateConn = nil
    end
    if persistentData.Connections and persistentData.Connections.CharacterAddedConn then
        pcall(function() persistentData.Connections.CharacterAddedConn:Disconnect() end)
        persistentData.Connections.CharacterAddedConn = nil
    end

    -- Heartbeat update connection
    persistentData.Connections.UpdateConn = game:GetService("RunService").Heartbeat:Connect(function()
        -- Throttle update frequency for performance
        local now = tick()
        if (now - (persistentData.LastUpdateTime or 0)) < (1 / CONFIG.UPDATE_TICK_RATE_HZ) then return end
        persistentData.LastUpdateTime = now
        -- Early guards and recovery for lost references
        if (not Character) or (not Humanoid) or (not HumanoidRootPart) then
            local lp = game:GetService("Players").LocalPlayer
            if lp then
                Character = Character or lp.Character
                if not Character then
                    local okWait, res = pcall(function() return lp.CharacterAdded:Wait() end)
                    if okWait then Character = res end
                end
                if Character then
                    pcall(function()
                        Humanoid = Humanoid or Character:FindFirstChild("Humanoid") or Character:WaitForChild("Humanoid", 2)
                        HumanoidRootPart = HumanoidRootPart or Character:FindFirstChild("HumanoidRootPart") or Character:WaitForChild("HumanoidRootPart", 2)
                    end)
                end
            end
        end
        local ok, err = pcall(Update)
        if not ok then
            forcePrint("LinkedSwordAI: Update error - " .. tostring(err))
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Error: " .. tostring(err)) end
        end
    end)

    -- Character respawn handling: re-initialize cleanly on CharacterAdded
    local Players = game:GetService("Players")
    persistentData.Connections.CharacterAddedConn = Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        forcePrint("LinkedSwordAI: Character respawned - reinitializing")
        -- minimal wait for character to be usable
        wait(0.6)
        -- refresh references in-place instead of full re-run to avoid duplicates
        Character = newCharacter
        local okH, h = pcall(function() return Character:WaitForChild("Humanoid") end)
        Humanoid = okH and h or Character:FindFirstChild("Humanoid")
        local okR, r = pcall(function() return Character:WaitForChild("HumanoidRootPart") end)
        HumanoidRootPart = okR and r or Character:FindFirstChild("HumanoidRootPart")
        persistentData.LinkedSword = FindLinkedSword()
        persistentData.EquipmentReady = false
        -- try immediate equip attempts
        spawn(function()
            local tries = 0
            while tries < 8 do
                tries = tries + 1
                persistentData.LinkedSword = FindLinkedSword()
                if persistentData.LinkedSword and persistentData.LinkedSword.Parent ~= Character then
                    persistentData.LinkedSword.Parent = Character
                    wait(0.25)
                end
                if persistentData.LinkedSword and persistentData.LinkedSword.Parent == Character then
                    persistentData.EquipmentReady = true
                    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Equipped on respawn") end
                    break
                end
                wait(0.25)
            end
        end)
    end)

    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("AI Running") end
    forcePrint("LinkedSwordAI: Enhanced script initialized successfully")

    local success_init, err_init = pcall(InitializeAI)
    if not success_init then
        forcePrint("LinkedSwordAI: Initialization failed - " .. tostring(err_init))
    end

end)

if not success then
    forcePrint("LinkedSwordAI: Script execution failed - " .. tostring(err))
end
    return true
end
