--[[ LinkedSwordAI - v9 (Improved Void Handling, Node Pathfinding, Attack Range)
   - Uses the rectangular coordinates provided by the user
   - Improved IsVoidArea / IsSafePath logic
   - Node-based navigation uses area rectangles and finds safe sample points inside them
   - Configurable attack distances and pathfinding behavior
   - FE-friendly (uses Humanoid:MoveTo & ChangeState with safety wrappers)
--]]

-- === Utilities / logging ===
local function forcePrint(...)
    local message = table.concat({...}, " ")
    print(message)
end

local function debugPrint(cat, ...)
    local args = {...}
    forcePrint("[" .. tostring(cat) .. "] " .. table.concat(args, " "))
end

-- === Persistent state ===
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {}
end
local persistentData = _G.LinkedSwordAIPersistentData

-- initialize defaults if nil
persistentData = persistentData or {}
_G.LinkedSwordAIPersistentData = persistentData

-- === Configuration (tweak these) ===
local CONFIG = {
    DETECTION_RADIUS = 220,           -- detect players within this distance
    ATTACK_RANGE = 18,                -- distance to consider attempting to close/attack
    IMMEDIATE_ATTACK_RADIUS = 10,     -- immediate attack trigger (very close)
    SWING_RANGE = 16,                 -- actual sword swing effective range
    ATTACK_COOLDOWN = 0.6,
    LUNGE_DELAY = 0.08,
    LUNGE_SPEED_MULTIPLIER = 1.6,
    OUT_OF_RANGE_AGGRESSION_TIME = 3.0,
    SWORD_CHECK_INTERVAL = 6,
    RESPAWN_EQUIP_DELAY = 0.3,
    SAFE_SAMPLE_GRID = 3,             -- NxN sampling inside rectangles for safe point discovery
    SAFE_SAMPLE_STEP = 4,             -- studs between sample points when searching inside rectangle
    PATH_CACHE_TIME = 4.0,
    ALTERNATIVE_PATH_COUNT = 16,
    MAX_JUMP_HEIGHT = 6,              -- small jumps allowed up to this height
    VOID_Y_THRESHOLD = -100,
    TRANSPARENT_THRESHOLD = 0.8,
    MAX_KNOWN_VOID_AREAS = 120,
    PATH_CACHE_CAPACITY = 80,
    NODE_PATH_RECOMPUTE_INTERVAL = 2.5,
    MOVE_TIMEOUT = 4.0,               -- seconds to wait for MoveToFinished
    SWAP_NODE_RADIUS = 6,             -- if current node unreachable, try near points within this radius
}

-- === Fixed rectangular areas (exact pairs provided by user) ===
local FIXED_AREAS = {
    Center = { Vector3.new(-30.36, 249.67, -30.42), Vector3.new(30.52, 249.67, 30.36) },
    LowerBridge1 = { Vector3.new(-47.61, 260.26, -0.57), Vector3.new(-89.31, 260.18, 0.56) },
    LowerBridge2 = { Vector3.new(-117.58, 260.07, -9.98), Vector3.new(-116.46, 260.10, -37.44) },
    RegenArea = { Vector3.new(-106.42, 258.89, -8.31), Vector3.new(-125.50, 258.91, 17.55) },
    BottomArea = { Vector3.new(-19.45, 234.09, -43.63), Vector3.new(21.48, 234.09, -32.43) },
    HillBottom1 = { Vector3.new(35.40, 249.30, -97.38), Vector3.new(27.53, 249.29, -147.68) },
    HillBottom2 = { Vector3.new(26.37, 249.28, -147.67), Vector3.new(-17.55, 249.28, -141.43) },
    HillBottom3 = { Vector3.new(-17.57, 249.30, -140.63), Vector3.new(-16.47, 249.30, -97.36) },
    HillStair1 = { Vector3.new(26.40, 249.30, -97.51), Vector3.new(-14.48, 263.70, -106.51) },
    HillStair2 = { Vector3.new(-14.49, 266.10, -107.44), Vector3.new(24.41, 275.70, -116.45) },
    HillStair3 = { Vector3.new(25.62, 275.70, -117.49), Vector3.new(16.51, 285.27, -140.43) },
    Hill = { Vector3.new(15.42, 286.26, -137.49), Vector3.new(-27.53, 286.48, -125.29) },
    UpperBridge1 = { Vector3.new(-28.55, 287.70, -130.53), Vector3.new(-56.47, 288.87, -131.73) },
    UpperBridge2 = { Vector3.new(-56.51, 288.87, -129.54), Vector3.new(-55.52, 288.88, 67.58) },
    UpperBridge3 = { Vector3.new(-56.51, 290.10, 87.53), Vector3.new(46.47, 290.07, 88.55) },
    UpperBase = { Vector3.new(-57.46, 288.89, 61.56), Vector3.new(-90.67, 288.90, 92.48) },
    GrayBridge = { Vector3.new(2.46, 250.47, 208.97), Vector3.new(-1.48, 250.47, 311.91) },
    ArmorArea = { Vector3.new(17.40, 249.30, 313.59), Vector3.new(-14.58, 249.30, 342.48) },
    Base = { Vector3.new(7.56, 249.30, 207.46), Vector3.new(-7.55, 249.30, 187.56) }
}

-- === Helpers for area math ===
local function AreaCenter(area)
    local a, b = area[1], area[2]
    return Vector3.new((a.X + b.X) / 2, (a.Y + b.Y) / 2, (a.Z + b.Z) / 2)
end

local function AreaBounds(area)
    local a, b = area[1], area[2]
    local minX, maxX = math.min(a.X, b.X), math.max(a.X, b.X)
    local minY, maxY = math.min(a.Y, b.Y), math.max(a.Y, b.Y)
    local minZ, maxZ = math.min(a.Z, b.Z), math.max(a.Z, b.Z)
    return minX, maxX, minY, maxY, minZ, maxZ
end

local function IsPointInArea(position, area)
    if not (position and area) then return false end
    local minX, maxX, minY, maxY, minZ, maxZ = AreaBounds(area)
    return position.X >= minX and position.X <= maxX
       and position.Y >= minY and position.Y <= maxY
       and position.Z >= minZ and position.Z <= maxZ
end

-- Build a simple center map for the nodes (we keep both center and area)
local NAMED_NODES = {}
for k,v in pairs(FIXED_AREAS) do
    NAMED_NODES[k] = AreaCenter(v)
end

-- === Forward declarations to avoid nil-invocation races ===
local IsVoidArea, IsSafePath, FindSafePointInArea, BuildNodeGraph, ComputeNodePathBetweenAreas
local FollowPositionPath, MoveToPosition, TryJumpToPosition, ExecuteAttack, FindNearestAreaName

-- === FE-safe humanoid wrappers ===
local function SafeMoveTo(humanoid, pos)
    if not (humanoid and pos) then return false end
    local ok, err = pcall(function()
        humanoid:MoveTo(pos)
    end)
    if not ok then
        debugPrint("WARN", "SafeMoveTo failed:", tostring(err))
        return false
    end
    return true
end

local function SafeChangeState(humanoid, state)
    if not (humanoid and state) then return false end
    pcall(function() humanoid:ChangeState(state) end)
    return true
end

-- === Environment helpers: isPartUnsafe / void detection / gap detection ===
local Workspace = game:GetService("Workspace")

local function isPartUnsafe_local(part)
    if not part then return true end
    if part.Transparency and part.Transparency >= CONFIG.TRANSPARENT_THRESHOLD then return true end
    if part.CanCollide == false then return true end
    return false
end

-- Known void area cache
persistentData.KnownVoidAreas = persistentData.KnownVoidAreas or {}

IsVoidArea = function(position)
    if not position then return true end

    -- quick check in known list (within small radius)
    for i = 1, #persistentData.KnownVoidAreas do
        local vp = persistentData.KnownVoidAreas[i]
        if (position - vp).Magnitude < 4 then
            return true
        end
    end

    -- if too low, consider void
    if position.Y < CONFIG.VOID_Y_THRESHOLD then
        table.insert(persistentData.KnownVoidAreas, position)
        if #persistentData.KnownVoidAreas > CONFIG.MAX_KNOWN_VOID_AREAS then
            table.remove(persistentData.KnownVoidAreas, 1)
        end
        return true
    end

    -- Raycast downwards from position: if nothing within reasonable distance -> void
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {}
    params.FilterType = Enum.RaycastFilterType.Blacklist
    local downVec = Vector3.new(0, - (CONFIG.MAX_JUMP_HEIGHT + 20), 0)
    local success, rayRes = pcall(function()
        return Workspace:Raycast(position + Vector3.new(0, 2, 0), downVec, params)
    end)
    if not success or not rayRes or not rayRes.Instance then
        -- unknown platform / void -> register and return true
        table.insert(persistentData.KnownVoidAreas, position)
        if #persistentData.KnownVoidAreas > CONFIG.MAX_KNOWN_VOID_AREAS then
            table.remove(persistentData.KnownVoidAreas, 1)
        end
        return true
    end

    local hitPart = rayRes.Instance
    if isPartUnsafe_local(hitPart) then
        table.insert(persistentData.KnownVoidAreas, position)
        if #persistentData.KnownVoidAreas > CONFIG.MAX_KNOWN_VOID_AREAS then
            table.remove(persistentData.KnownVoidAreas, 1)
        end
        return true
    end

    -- not void
    return false
end

-- IsSafeGap: checks there is a ground under endpoint (and between start and end)
IsSafeGap = function(startPos, endPos)
    if not (startPos and endPos) then return false end
    local dist = (endPos - startPos).Magnitude
    if dist <= 2 then
        return not IsVoidArea(endPos)
    end
    local direction = (endPos - startPos).Unit
    local steps = math.ceil(dist / 2)
    for i = 1, steps do
        local checkPoint = startPos + direction * (i * 2)
        if IsVoidArea(checkPoint) then
            return false
        end
    end
    return true
end

-- IsSafePath: robust check for voids, transparent parts, and narrow passage checks
IsSafePath = function(targetPosition)
    if not targetPosition then return false end

    -- cache lookup
    local key = math.floor(targetPosition.X) .. "," .. math.floor(targetPosition.Y) .. "," .. math.floor(targetPosition.Z)
    local cache = persistentData.PathCache or {}
    if cache[key] and (tick() - (cache[key].time or 0) < CONFIG.PATH_CACHE_TIME) then
        return cache[key].safe, cache[key].bridgePath, cache[key].altPoint
    end

    if IsVoidArea(targetPosition) then
        cache[key] = { safe = false, time = tick() }
        persistentData.PathCache = persistentData.PathCache or {}
        persistentData.PathCache[key] = cache[key]
        return false
    end

    -- quick raycast from above to target position to ensure a platform in between (prevents path through tall obstructions)
    local char = persistentData.Character
    local startPos = char and char:FindFirstChild("HumanoidRootPart") and char.HumanoidRootPart.Position or nil
    if not startPos then
        -- fallback: consider not safe (we don't know)
        cache[key] = { safe = false, time = tick() }
        persistentData.PathCache = persistentData.PathCache or {}
        persistentData.PathCache[key] = cache[key]
        return false
    end

    local dir = (targetPosition - startPos)
    local distance = dir.Magnitude
    if distance <= 1 then
        cache[key] = { safe = not IsVoidArea(targetPosition), time = tick() }
        persistentData.PathCache = persistentData.PathCache or {}
        persistentData.PathCache[key] = cache[key]
        return cache[key].safe
    end

    dir = dir.Unit
    -- step along and ensure not void
    local step = math.min(5, math.max(2, distance / 6))
    local steps = math.ceil(distance / step)
    for i = 1, steps do
        local checkPos = startPos + dir * math.min(i * step, distance)
        if IsVoidArea(checkPos) then
            -- try to find bridge landing (bridge detection simplified)
            local bridge = nil
            -- simple attempt: check lower Y levels along route
            for yOff = 0, -20, -2 do
                local tryPos = checkPos + Vector3.new(0, yOff, 0)
                if not IsVoidArea(tryPos) and IsSafeGap(startPos, tryPos) then
                    bridge = tryPos
                    break
                end
            end
            cache[key] = { safe = false, time = tick(), bridgePath = bridge }
            persistentData.PathCache = persistentData.PathCache or {}
            persistentData.PathCache[key] = cache[key]
            return false, bridge
        end
    end

    -- looks okay
    cache[key] = { safe = true, time = tick() }
    persistentData.PathCache = persistentData.PathCache or {}
    persistentData.PathCache[key] = cache[key]
    return true
end

-- === Find a safe concrete Vector3 inside a named area rectangle ===
-- This is the main improvement: if the node name refers to a rectangle, sample points inside
-- (center first, then grid) and return first safe point found.
FindSafePointInArea = function(areaName, preferTowardsPosition)
    local area = FIXED_AREAS[areaName]
    if not area then return nil end
    local cx = AreaCenter(area)
    -- provide samples: center, then 4 corners, then grid (SAFE_SAMPLE_GRID x SAFE_SAMPLE_GRID)
    local samples = {}

    table.insert(samples, cx)

    local a, b = area[1], area[2]
    local corners = {
        Vector3.new(a.X, a.Y, a.Z),
        Vector3.new(a.X, a.Y, b.Z),
        Vector3.new(b.X, a.Y, a.Z),
        Vector3.new(b.X, a.Y, b.Z),
    }
    for _, c in ipairs(corners) do table.insert(samples, c) end

    -- sample grid across area (in X/Z plane) using SAFE_SAMPLE_STEP granularity (bounded by SAFE_SAMPLE_GRID)
    local minX, maxX, minY, maxY, minZ, maxZ = AreaBounds(area)
    local stepX = math.max( (maxX - minX) / (CONFIG.SAFE_SAMPLE_GRID - 1), CONFIG.SAFE_SAMPLE_STEP )
    local stepZ = math.max( (maxZ - minZ) / (CONFIG.SAFE_SAMPLE_GRID - 1), CONFIG.SAFE_SAMPLE_STEP )

    for i = 0, CONFIG.SAFE_SAMPLE_GRID - 1 do
        for j = 0, CONFIG.SAFE_SAMPLE_GRID - 1 do
            local sx = minX + i * stepX
            local sz = minZ + j * stepZ
            local sy = (minY + maxY) / 2
            table.insert(samples, Vector3.new(sx, sy + 2, sz)) -- sample slightly above surface
        end
    end

    -- If preferTowardsPosition is provided, sort samples by closeness to that pos first
    if preferTowardsPosition then
        table.sort(samples, function(a,b)
            return (a - preferTowardsPosition).Magnitude < (b - preferTowardsPosition).Magnitude
        end)
    end

    -- Evaluate samples for safe path & landing
    for _, s in ipairs(samples) do
        -- raycast down from s to snap to ground, if ground exists then candidate is ground position
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {}
        params.FilterType = Enum.RaycastFilterType.Blacklist
        local success, rayRes = pcall(function()
            return Workspace:Raycast(s, Vector3.new(0, -60, 0), params)
        end)
        local landing = nil
        if success and rayRes and rayRes.Instance and not isPartUnsafe_local(rayRes.Instance) then
            landing = rayRes.Position + Vector3.new(0, 2, 0) -- a bit above ground
        end
        if landing then
            -- make sure landing is not void, and path to landing is safe
            if not IsVoidArea(landing) and IsSafePath(landing) then
                return landing
            end
        end
    end

    -- fallback: return area center if nothing found (caller must revalidate)
    return AreaCenter(area)
end

-- === Node graph builder (uses the area names & sequences the user described) ===
BuildNodeGraph = function()
    if not persistentData.NodeGraph then
        persistentData.NodeGraph = { nodes = {}, adjacency = {} }
    end
    persistentData.NodeGraph.nodes = {}      -- names -> center (keeps area names)
    persistentData.NodeGraph.adjacency = {} -- names -> {neighborNames...}

    -- insert all area names
    for name, area in pairs(FIXED_AREAS) do
        persistentData.NodeGraph.nodes[name] = AreaCenter(area)
        persistentData.NodeGraph.adjacency[name] = persistentData.NodeGraph.adjacency[name] or {}
    end

    local function link(a,b)
        if not (persistentData.NodeGraph.adjacency[a] and persistentData.NodeGraph.adjacency[b]) then return end
        -- avoid duplicates
        local function addOnce(tbl, val)
            for _, v in ipairs(tbl) do if v == val then return end end
            table.insert(tbl, val)
        end
        addOnce(persistentData.NodeGraph.adjacency[a], b)
        addOnce(persistentData.NodeGraph.adjacency[b], a)
    end

    -- Link based on user's requested sequences:
    -- center -> bottom -> hill bottom -> staircases -> hill -> upper bridges -> lower bridge 1 etc.
    link("Center", "LowerBridge1")
    link("Center", "BottomArea")
    link("BottomArea", "HillBottom1")
    link("HillBottom1", "HillBottom2")
    link("HillBottom2", "HillBottom3")
    link("HillBottom3", "Hill")
    link("HillBottom1", "HillStair1")
    link("HillStair1", "HillStair2")
    link("HillStair2", "HillStair3")
    link("HillStair3", "Hill")
    link("Hill", "UpperBridge1")
    link("UpperBridge1", "UpperBridge2")
    link("UpperBridge2", "LowerBridge1") -- drop down to lower
    link("LowerBridge1", "LowerBridge2")
    link("LowerBridge2", "RegenArea")
    link("UpperBridge2", "UpperBase")
    link("UpperBase", "UpperBridge3")
    link("GrayBridge", "ArmorArea")
    link("Base", "GrayBridge")
    link("Base", "ArmorArea")
    link("Center", "Base") -- allow center -> base via gray bridge area

    -- spatial linking: connect nodes that are near each other (for robustness)
    for nameA, posA in pairs(persistentData.NodeGraph.nodes) do
        for nameB, posB in pairs(persistentData.NodeGraph.nodes) do
            if nameA ~= nameB then
                if (posA - posB).Magnitude <= 140 then
                    -- add if not present
                    local adjA = persistentData.NodeGraph.adjacency[nameA]
                    local found = false
                    for _, v in ipairs(adjA) do if v == nameB then found = true break end end
                    if not found then table.insert(adjA, nameB) end
                    local adjB = persistentData.NodeGraph.adjacency[nameB]
                    local found2 = false
                    for _, v in ipairs(adjB) do if v == nameA then found2 = true break end end
                    if not found2 then table.insert(adjB, nameA) end
                end
            end
        end
    end

    persistentData.NodeGraph.builtTime = tick()
    debugPrint("NAV", "Node graph built with", tostring(#(function() local c=0; for _ in pairs(persistentData.NodeGraph.nodes) do c=c+1 end; return c end)()), "nodes")
end

-- Ensure node graph exists
BuildNodeGraph()

-- === Node BFS from area name to area name, returns list of area names ===
ComputeNodePathBetweenAreas = function(startAreaName, goalAreaName)
    if not (persistentData.NodeGraph and persistentData.NodeGraph.adjacency) then BuildNodeGraph() end
    if not startAreaName or not goalAreaName then return nil end
    if startAreaName == goalAreaName then return {startAreaName} end
    local queue = { {startAreaName} }
    local visited = { [startAreaName] = true }
    while #queue > 0 do
        local path = table.remove(queue, 1)
        local last = path[#path]
        for _, neighbor in ipairs(persistentData.NodeGraph.adjacency[last] or {}) do
            if not visited[neighbor] then
                visited[neighbor] = true
                local newPath = {unpack(path)}
                table.insert(newPath, neighbor)
                if neighbor == goalAreaName then
                    return newPath
                end
                table.insert(queue, newPath)
            end
        end
    end
    return nil
end

-- === Convert area-name path into position path (safe points inside each area), preferTowards used to bias sampling ===
local function AreaNamePathToPositionPath(areaPath, startPos, goalPos)
    if not areaPath then return nil end
    local positions = {}
    for i, areaName in ipairs(areaPath) do
        local prefer = nil
        if i == 1 and startPos then prefer = startPos end
        if i == #areaPath and goalPos then prefer = goalPos end
        local p = FindSafePointInArea(areaName, prefer)
        if p then
            -- Validate p is not void and path to it is safe
            if not IsVoidArea(p) then
                -- if won't find safe path to p directly, attempt a few offsets around p
                if IsSafePath(p) then
                    table.insert(positions, p)
                else
                    -- sample around p in small radius to find safe nearby sample
                    local foundSafeNearby = false
                    for r = 2, CONFIG.SWAP_NODE_RADIUS, 2 do
                        for ang = 0, math.pi*2, math.pi/4 do
                            local alt = p + Vector3.new(math.cos(ang)*r, 0, math.sin(ang)*r)
                            if not IsVoidArea(alt) and IsSafePath(alt) then
                                table.insert(positions, alt)
                                foundSafeNearby = true
                                break
                            end
                        end
                        if foundSafeNearby then break end
                    end
                    if not foundSafeNearby then
                        -- use p anyway; caller should handle failures
                        table.insert(positions, p)
                    end
                end
            end
        end
    end
    return positions
end

-- === Move & follow helpers ===
-- MoveToPosition tries MoveTo and waits for MoveToFinished with timeout; returns true if reached
FollowPositionPath = function(humanoid, hrp, posPath)
    if not (humanoid and hrp and posPath and #posPath > 0) then return false end
    for idx, targetPos in ipairs(posPath) do
        if IsVoidArea(targetPos) then
            debugPrint("NAV", "Skipping void target at index", idx)
            return false
        end

        local ok = pcall(function() SafeMoveTo(humanoid, targetPos) end)
        local reached = false
        local conn
        local startT = tick()
        conn = humanoid.MoveToFinished:Connect(function(success)
            reached = success
            if conn then conn:Disconnect(); conn = nil end
        end)
        -- wait until reached or timeout
        while not reached and (tick() - startT) < CONFIG.MOVE_TIMEOUT do
            task.wait(0.06)
        end
        if conn then conn:Disconnect(); conn = nil end
        if not reached then
            debugPrint("NAV", "Failed to reach node idx", idx, "-> trying small jump or adjacent point")
            -- try a small jump toward target if jumpable
            local jumpOk = false
            if (targetPos.Y - hrp.Position.Y) <= CONFIG.MAX_JUMP_HEIGHT then
                SafeChangeState(humanoid, Enum.HumanoidStateType.Jumping)
                SafeMoveTo(humanoid, targetPos)
                task.wait(0.2)
                -- short wait to see if progress
                local t0 = tick()
                while (tick() - t0) < 1.2 do
                    if (hrp.Position - targetPos).Magnitude < 3 then
                        jumpOk = true
                        break
                    end
                    task.wait(0.06)
                end
            end
            if not jumpOk then
                -- try small offset points around target
                local found = false
                for r = 2, 8, 2 do
                    for ang = 0, math.pi*2, math.pi/4 do
                        local alt = targetPos + Vector3.new(math.cos(ang)*r, 0, math.sin(ang)*r)
                        if not IsVoidArea(alt) and IsSafePath(alt) then
                            SafeMoveTo(humanoid, alt)
                            -- wait briefly
                            task.wait(0.4)
                            if (hrp.Position - alt).Magnitude < 4 then found = true; break end
                        end
                    end
                    if found then break end
                end
                if not found then
                    debugPrint("NAV", "Node unreachable — aborting path")
                    return false
                end
            end
        end
    end
    return true
end

-- MoveToPosition: top-level: either direct MoveTo (if safe) or compute area-node path & follow positions
MoveToPosition = function(targetPosition)
    local char = persistentData.Character
    if not char or not targetPosition then return false end
    local humanoid = char:FindFirstChild("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return false end

    -- If direct safe path, attempt it
    local safe, bridge = IsSafePath(targetPosition)
    if safe then
        SafeMoveTo(humanoid, targetPosition)
        return true
    end

    -- If not safe, compute area-based path
    -- find nearest area names for start and goal
    local function nearestAreaName(pos)
        local bestName, bestDist = nil, math.huge
        for name, area in pairs(FIXED_AREAS) do
            local center = AreaCenter(area)
            local d = (center - pos).Magnitude
            if d < bestDist then bestDist = d; bestName = name end
        end
        return bestName
    end

    local startArea = nearestAreaName(hrp.Position)
    local goalArea = nearestAreaName(targetPosition)
    if not startArea or not goalArea then
        -- fallback: attempt small advances
        for i = 0, CONFIG.ALTERNATIVE_PATH_COUNT - 1 do
            local ang = (i / CONFIG.ALTERNATIVE_PATH_COUNT) * math.pi * 2
            local alt = hrp.Position + Vector3.new(math.cos(ang)*8,0, math.sin(ang)*8)
            if IsSafePath(alt) then
                SafeMoveTo(humanoid, alt)
                return true
            end
        end
        return false
    end

    -- Compute area-to-area path (list of area names)
    local areaPath = ComputeNodePathBetweenAreas(startArea, goalArea)
    if not areaPath or #areaPath == 0 then
        debugPrint("NAV", "No area path from", tostring(startArea), "to", tostring(goalArea))
        return false
    end

    -- Convert area names to safe positions (samples inside rectangles)
    local posPath = AreaNamePathToPositionPath(areaPath, hrp.Position, targetPosition)
    if not posPath or #posPath == 0 then
        debugPrint("NAV", "Failed to convert area path to position path")
        return false
    end

    -- Follow the position path
    local ok = FollowPositionPath(humanoid, hrp, posPath)
    return ok
end

-- TryJumpToPosition wrapper
TryJumpToPosition = function(targetPos)
    local char = persistentData.Character
    if not char then return false end
    local humanoid = char:FindFirstChild("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp or not targetPos then return false end
    -- check height
    local dy = targetPos.Y - hrp.Position.Y
    if dy > CONFIG.MAX_JUMP_HEIGHT then return false end
    SafeChangeState(humanoid, Enum.HumanoidStateType.Jumping)
    SafeMoveTo(humanoid, targetPos)
    return true
end

-- === Combat (Improved) ===
ExecuteAttack = function(targetPlayer)
    if not (targetPlayer and targetPlayer.Character) then return end
    local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return end
    local char = persistentData.Character
    if not char then return end
    local humanoid = char:FindFirstChild("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return end

    local dist = (hrp.Position - targetHRP.Position).Magnitude

    -- If out of swing range but still within ATTACK_RANGE, approach then attack
    if dist > CONFIG.SWING_RANGE and dist <= CONFIG.ATTACK_RANGE then
        -- perform a controlled lunge/approach
        local direction = (targetHRP.Position - hrp.Position).Unit
        local approachPos = hrp.Position + direction * math.max( (dist - (CONFIG.SWING_RANGE - 1)), 2 )
        -- ensure approach is safe via MoveToPosition
        MoveToPosition(approachPos)
        -- short delay then attempt swing
        task.wait(0.06)
    end

    -- now if within swing range, swing multiple times
    local newDist = (hrp.Position - targetHRP.Position).Magnitude
    if newDist <= CONFIG.SWING_RANGE then
        if persistentData.LinkedSword and persistentData.AttackSequenceActive ~= true then
            persistentData.AttackSequenceActive = true
            persistentData.LastAttackTime = tick()
            spawn(function()
                -- a little pattern: partial-lunge (deceptive), swing-swing
                pcall(function() persistentData.LinkedSword:Activate() end) -- partial
                task.wait(CONFIG.LUNGE_DELAY)
                pcall(function() persistentData.LinkedSword:Activate() end) -- main
                task.wait(CONFIG.LUNGE_DELAY * 0.8)
                -- possibly an extra swing
                pcall(function() persistentData.LinkedSword:Activate() end)
                persistentData.AttackSequenceActive = false
            end)
            return true
        end
    end
    return false
end

-- === Target area detection helper ===
FindNearestAreaName = function(position)
    if not position then return nil end
    local best, bestDist = nil, math.huge
    for name, area in pairs(FIXED_AREAS) do
        local center = AreaCenter(area)
        local d = (position - center).Magnitude
        if d < bestDist then bestDist = d; best = name end
    end
    return best
end

-- === Sword equipment & detection ===
local function FindLinkedSwordInCharacter(character, player)
    if not character then return nil end
    for _, child in ipairs(character:GetChildren()) do
        if child:IsA("Tool") and tostring(child.Name):lower():find("sword") then
            return child
        end
    end
    -- check backpack
    if player and player:IsA("Player") and player.Backpack then
        for _, t in ipairs(player.Backpack:GetChildren()) do
            if t:IsA("Tool") and tostring(t.Name):lower():find("sword") then return t end
        end
    end
    return nil
end

-- === Main AI update loop ===
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- status GUI (safely)
local StatusGUI = nil
local function CreateStatusGuiSafely()
    if StatusGUI then return StatusGUI end
    local ok, gui = pcall(function()
        local g = Instance.new("ScreenGui")
        g.Name = "LinkedSwordAI_Status"
        g.ResetOnSpawn = false
        g.Parent = LocalPlayer:WaitForChild("PlayerGui")
        return g
    end)
    if not ok then return nil end
    local frame = Instance.new("Frame", gui)
    frame.Size = UDim2.new(0,220,0,120)
    frame.Position = UDim2.new(0.78, 0, 0.08, 0)
    frame.BackgroundTransparency = 0.4
    local function makeLabel(y, textColor, text)
        local lbl = Instance.new("TextLabel")
        lbl.Size = UDim2.new(1, -10, 0, 20)
        lbl.Position = UDim2.new(0, 5, 0, y)
        lbl.BackgroundTransparency = 1
        lbl.TextColor3 = textColor
        lbl.Text = text
        lbl.Font = Enum.Font.SourceSans
        lbl.TextSize = 13
        lbl.TextXAlignment = Enum.TextXAlignment.Left
        lbl.Parent = frame
        return lbl
    end
    StatusGUI = {
        frame = frame,
        status = makeLabel(4, Color3.new(1,1,1), "Status: ..."),
        target = makeLabel(26, Color3.new(1,0.6,0.6), "Target: None"),
        dist = makeLabel(48, Color3.new(0.6,1,0.6), "Distance: N/A"),
        debug = makeLabel(70, Color3.new(1,1,0.4), "Debug: ...")
    }
    function StatusGUI.UpdateStatus(t) if StatusGUI and StatusGUI.status then StatusGUI.status.Text = "Status: " .. tostring(t) end end
    function StatusGUI.UpdateTarget(t) if StatusGUI and StatusGUI.target then StatusGUI.target.Text = "Target: " .. tostring(t) end end
    function StatusGUI.UpdateDistance(d) if StatusGUI and StatusGUI.dist then StatusGUI.dist.Text = "Distance: " .. (d and string.format("%.1f", d) or "N/A") end end
    function StatusGUI.UpdateDebug(t) if StatusGUI and StatusGUI.debug then StatusGUI.debug.Text = "Debug: " .. tostring(t) end end
    return StatusGUI
end

-- Initialize persistentData fields
persistentData.PathCache = persistentData.PathCache or {}
persistentData.KnownVoidAreas = persistentData.KnownVoidAreas or {}
persistentData.NodeGraph = persistentData.NodeGraph or nil
BuildNodeGraph() -- ensure graph built

-- Character ready handler
local function OnCharacterReady(character)
    persistentData.Character = character
    if StatusGUI == nil then CreateStatusGuiSafely() end
    if StatusGUI then StatusGUI.UpdateStatus("AI Initialized") end

    -- attempt equip sword
    spawn(function()
        local tries = 0
        while tries < 10 do
            tries = tries + 1
            local sword = FindLinkedSwordInCharacter(character, LocalPlayer)
            if sword then
                persistentData.LinkedSword = sword
                StatusGUI.UpdateDebug("Sword found: " .. tostring(sword.Name))
                break
            end
            task.wait(0.3)
        end
    end)
end

-- Hook character
if LocalPlayer then
    if LocalPlayer.Character then
        OnCharacterReady(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(function(c) task.wait(0.6); OnCharacterReady(c) end)
end

-- Main heartbeat
local lastRetarget = 0
RunService.Heartbeat:Connect(function(dt)
    local char = persistentData.Character
    if not char then return end
    local humanoid = char:FindFirstChild("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return end

    -- periodic sword check
    if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= char then
        if tick() - (persistentData.LastSwordCheckTime or 0) > CONFIG.SWORD_CHECK_INTERVAL then
            persistentData.LinkedSword = FindLinkedSwordInCharacter(char, LocalPlayer)
            persistentData.LastSwordCheckTime = tick()
        end
    end

    -- target selection: nearest player
    if tick() - lastRetarget > 0.8 then
        lastRetarget = tick()
        local players = Players:GetPlayers()
        local best, bestDist = nil, math.huge
        for _, plr in ipairs(players) do
            if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
                local d = (plr.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                if d < bestDist and d <= CONFIG.DETECTION_RADIUS then best = plr; bestDist = d end
            end
        end
        persistentData.CurrentTarget = best
        if StatusGUI then StatusGUI.UpdateTarget(best and best.Name or "None") end
    end

    local target = persistentData.CurrentTarget
    if not target or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then
        if StatusGUI then StatusGUI.UpdateStatus("Idle") end
        return
    end

    local targetHRP = target.Character.HumanoidRootPart
    local dist = (targetHRP.Position - hrp.Position).Magnitude
    if StatusGUI then StatusGUI.UpdateDistance(dist) end

    -- ForceField flee logic: if someone has forcefield and is too close, flee
    -- maintain players with forcefields
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character and plr.Character:FindFirstChildOfClass("ForceField") then
            persistentData.PlayersWithForceField = persistentData.PlayersWithForceField or {}
            persistentData.PlayersWithForceField[plr.Name] = plr
        else
            if persistentData.PlayersWithForceField then persistentData.PlayersWithForceField[plr.Name] = nil end
        end
    end
    -- flee if nearest FF within threshold
    local nearestFF, nearestDist = nil, math.huge
    if persistentData.PlayersWithForceField then
        for name, ffplr in pairs(persistentData.PlayersWithForceField) do
            if ffplr and ffplr.Character and ffplr.Character:FindFirstChild("HumanoidRootPart") then
                local d = (ffplr.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                if d < nearestDist then nearestDist = d; nearestFF = ffplr end
            end
        end
    end
    if nearestFF and nearestDist < 18 then
        -- flee away
        local fleeDir = (hrp.Position - nearestFF.Character.HumanoidRootPart.Position)
        if fleeDir.Magnitude < 0.1 then fleeDir = Vector3.new(math.random()-0.5, 0, math.random()-0.5).Unit end
        fleeDir = fleeDir.Unit
        local fleeTarget = hrp.Position + fleeDir * 18
        if not IsVoidArea(fleeTarget) then
            MoveToPosition(fleeTarget)
            if StatusGUI then StatusGUI.UpdateStatus("Fleeing FF: " .. nearestFF.Name) end
            return
        end
    end

    -- If within immediate attack radius -> attack right away
    if dist <= CONFIG.IMMEDIATE_ATTACK_RADIUS then
        if StatusGUI then StatusGUI.UpdateStatus("Immediate Attack") end
        ExecuteAttack(target)
        return
    end

    -- If within aggressive attack range (ATTACK_RANGE) but not swing range: approach then attack
    if dist <= CONFIG.ATTACK_RANGE then
        -- ensure not constantly spamming: check cooldown
        if (tick() - (persistentData.LastAttackTime or 0)) > CONFIG.ATTACK_COOLDOWN then
            if StatusGUI then StatusGUI.UpdateStatus("Approaching for attack") end
            -- try to MoveTo a safe point near target
            local targetAreaName = FindNearestAreaName(targetHRP.Position)
            local desiredPoint = nil
            if targetAreaName then
                desiredPoint = FindSafePointInArea(targetAreaName, hrp.Position)
            end
            desiredPoint = desiredPoint or (targetHRP.Position - (targetHRP.Position - hrp.Position).Unit * (CONFIG.SWING_RANGE - 0.5))
            -- move towards desiredPoint
            local moved = MoveToPosition(desiredPoint)
            task.wait(0.06)
            ExecuteAttack(target)
            return
        end
    end

    -- Otherwise, normal navigation: use node path if direct path unsafe
    local safeDirect, bridge = IsSafePath(targetHRP.Position)
    if safeDirect then
        -- move directly toward target (but keep movement smoothing by moving to intermediate point at SWING_RANGE)
        local dir = (targetHRP.Position - hrp.Position).Unit
        local targetApproach = targetHRP.Position - dir * math.min(CONFIG.SWING_RANGE * 0.6, dist*0.4)
        if not IsVoidArea(targetApproach) then
            SafeMoveTo(humanoid, targetApproach)
        else
            -- fallback to node path
            MoveToPosition(targetHRP.Position)
        end
    else
        -- use node pathing (areas)
        MoveToPosition(targetHRP.Position)
    end

end)

-- End of file
