[file name]: AI Bot Sf Prototypes_Optimized.txt
[file content begin]
--[[
    Linked Sword AI Combat Script (Optimized with Garbage Collection)
    
    This script implements autonomous sword fighting AI for the Linked Sword tool in Roblox.
    Now includes efficient garbage collection system to prevent FPS degradation.
]]

-- Force print to output console immediately
local function forcePrint(...)
    local message = table.concat({...}, " ")
    print(message)
    print("") -- Force flush
end

-- Debug function with timestamps
local function debugPrint(category, ...)
    local args = {...}
    local message = "[" .. category .. "] " .. table.concat(args, " ")
    local timestamp = os.date("%H:%M:%S")
    forcePrint(timestamp .. " - " .. message)
end

forcePrint("LinkedSwordAI: Script starting with GC optimization...")
debugPrint("INIT", "Garbage collection system enabled")

-- Enhanced garbage collection configuration
local GC_CONFIG = {
    ENABLED = true,                    -- Master switch for garbage collection
    COLLECTION_INTERVAL = 30,          -- Run GC every 30 seconds (reduced from 60)
    AGGRESSIVE_THRESHOLD = 85,         -- Memory usage threshold for aggressive GC
    MINIMUM_MEMORY_MB = 50,            -- Target minimum memory usage
    CLEANUP_BATCH_SIZE = 100,          -- Objects to clean per batch
    MAX_CACHE_ENTRIES = 15,            -- Reduced from 20 to limit memory
    MAX_HISTORY_ENTRIES = 25,          -- Reduced movement history
    PERFORMANCE_SAMPLES = 60,          -- Track performance over 60 frames
}

-- Global persistent data with memory management
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {},
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        MovementHistory = {},
        FailedPaths = {},
        LastEquipAttempt = 0,
        EquipmentReady = false,
        KnownVoidAreas = {},
        PathCache = {},
        LastPathfindingTime = 0,
        PerformanceStats = {
            PathfindingTime = 0,
            CombatTime = 0,
            MovementTime = 0,
            LastOptimizationTime = 0,
            MemoryUsage = 0,           -- NEW: Track memory usage
            GarbageCollections = 0,    -- NEW: Track GC runs
            ObjectsCleaned = 0,        -- NEW: Track cleanup effectiveness
            LastGCTime = 0,            -- NEW: Track last GC run
            FrameTimes = {},           -- NEW: Track frame performance
            AverageFrameTime = 0       -- NEW: Track FPS stability
        },
        AlternativePaths = {},
        
        -- Garbage Collection System
        GarbageCollector = {
            LastCollectionTime = 0,
            MemorySnapshot = 0,
            ObjectsToClean = {},
            CleanupQueue = {},
            IsRunning = false
        }
    }
end

local persistentData = _G.LinkedSwordAIPersistentData

-- Configuration (optimized for memory)
local CONFIG = {
    DETECTION_RADIUS = 200,
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.7,
    LUNGE_DELAY = 0.1,
    STUCK_CHECK_DISTANCE = 1.5,
    STUCK_CHECK_TIME = 1.0,
    MAX_TARGET_DISTANCE = 250,
    MIN_HEALTH_CHECK = 0,
    RETARGET_CHECK_TIME = 1.5,
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -100,
    FORCEFIELD_FLEE_DISTANCE = 0,
    SWORD_CHECK_INTERVAL = 10,         -- Increased to reduce checks
    RESPAWN_EQUIP_DELAY = 1.5,
    MOVEMENT_MEMORY_TIME = 0.7,
    SAFE_GAP_DISTANCE = 10,
    PATH_SMOOTHING_FACTOR = 0.7,
    MOVEMENT_RETRY_DELAY = 1.0,
    NARROW_PASSAGE_WIDTH = 3.5,
    PATHFINDING_STEPS = 8,             -- Reduced from 10
    COMBAT_BEHAVIOR_CHANGE_TIME = 4.0,
    COMBAT_DEFENSIVE_CHANCE = 0.25,
    COMBAT_OFFENSIVE_CHANCE = 0.45,
    STRAFE_DISTANCE = 4,
    BRIDGE_CHECK_DISTANCE = 25,
    PERFORMANCE_MODE = true,
    PATH_CACHE_TIME = 2.0,             -- Reduced from 3.0
    ALTERNATIVE_PATH_COUNT = 3,        -- Reduced from 4
    MIN_ATTACK_DISTANCE = 3,
    
    -- Memory optimization settings
    MEMORY_SAFE_MODE = true,           -- NEW: Enable memory safety
    MAX_PLAYER_CACHE = 8,              -- NEW: Limit player cache size
    CLEANUP_INTERVAL = 5,              -- NEW: Minor cleanup interval
}

-- Memory monitoring function
local function GetMemoryUsage()
    return collectgarbage("count") / 1024 -- Convert KB to MB
end

-- Performance monitoring for FPS stability
local function UpdatePerformanceMetrics()
    local currentTime = tick()
    local stats = persistentData.PerformanceStats
    
    -- Track frame time (inverse of FPS)
    table.insert(stats.FrameTimes, currentTime)
    
    -- Keep only recent samples
    if #stats.FrameTimes > GC_CONFIG.PERFORMANCE_SAMPLES then
        table.remove(stats.FrameTimes, 1)
    end
    
    -- Calculate average frame time (indicator of FPS stability)
    if #stats.FrameTimes >= 2 then
        local totalTime = 0
        for i = 2, #stats.FrameTimes do
            totalTime = totalTime + (stats.FrameTimes[i] - stats.FrameTimes[i-1])
        end
        stats.AverageFrameTime = totalTime / (#stats.FrameTimes - 1)
    end
    
    -- Update memory usage
    stats.MemoryUsage = GetMemoryUsage()
end

-- Efficient garbage collection system
local function RunGarbageCollection(aggressive)
    if not GC_CONFIG.ENABLED or persistentData.GarbageCollector.IsRunning then
        return
    end
    
    persistentData.GarbageCollector.IsRunning = true
    local startTime = tick()
    local stats = persistentData.PerformanceStats
    local objectsCleaned = 0
    
    debugPrint("GC", "Starting garbage collection" .. (aggressive and " (aggressive)" or ""))
    
    -- Clean up PathCache (memory-intensive)
    local cacheEntries = 0
    local currentTime = tick()
    for k, v in pairs(persistentData.PathCache) do
        if currentTime - v.time > CONFIG.PATH_CACHE_TIME or cacheEntries >= GC_CONFIG.MAX_CACHE_ENTRIES then
            persistentData.PathCache[k] = nil
            objectsCleaned = objectsCleaned + 1
        else
            cacheEntries = cacheEntries + 1
        end
    end
    
    -- Clean up FailedPaths (limit size)
    while #persistentData.FailedPaths > GC_CONFIG.MAX_CACHE_ENTRIES do
        table.remove(persistentData.FailedPaths, 1)
        objectsCleaned = objectsCleaned + 1
    end
    
    -- Clean up KnownVoidAreas (limit size)
    while #persistentData.KnownVoidAreas > GC_CONFIG.MAX_CACHE_ENTRIES do
        table.remove(persistentData.KnownVoidAreas, 1)
        objectsCleaned = objectsCleaned + 1
    end
    
    -- Clean up MovementHistory (limit size)
    while #persistentData.MovementHistory > GC_CONFIG.MAX_HISTORY_ENTRIES do
        table.remove(persistentData.MovementHistory, 1)
        objectsCleaned = objectsCleaned + 1
    end
    
    -- Clean up AlternativePaths
    for k, v in pairs(persistentData.AlternativePaths) do
        if currentTime - (v.lastUsed or 0) > 30 then -- 30 second timeout
            persistentData.AlternativePaths[k] = nil
            objectsCleaned = objectsCleaned + 1
        end
    end
    
    -- Clean up player cache (remove players no longer in game)
    local validPlayers = {}
    for playerName, player in pairs(persistentData.PlayersWithForceField) do
        if player and player.Parent and player.Character then
            validPlayers[playerName] = player
        else
            objectsCleaned = objectsCleaned + 1
        end
    end
    persistentData.PlayersWithForceField = validPlayers
    
    -- Aggressive cleaning if memory is high
    if aggressive or stats.MemoryUsage > GC_CONFIG.AGGRESSIVE_THRESHOLD then
        debugPrint("GC", "Running aggressive cleanup - Memory: " .. string.format("%.1fMB", stats.MemoryUsage))
        
        -- Clear all caches
        persistentData.PathCache = {}
        persistentData.AlternativePaths = {}
        persistentData.FailedPaths = {}
        persistentData.KnownVoidAreas = {}
        persistentData.MovementHistory = {}
        
        objectsCleaned = objectsCleaned + 50 -- Estimate for bulk cleanup
        
        -- Force Lua garbage collection
        collectgarbage("collect")
        
        -- Reset performance tracking if memory was very high
        if stats.MemoryUsage > GC_CONFIG.AGGRESSIVE_THRESHOLD + 10 then
            stats.FrameTimes = {}
            debugPrint("GC", "Reset performance tracking due to high memory")
        end
    end
    
    -- Update statistics
    stats.GarbageCollections = stats.GarbageCollections + 1
    stats.ObjectsCleaned = stats.ObjectsCleaned + objectsCleaned
    stats.LastGCTime = tick()
    
    persistentData.GarbageCollector.LastCollectionTime = tick()
    persistentData.GarbageCollector.IsRunning = false
    
    local gcTime = tick() - startTime
    debugPrint("GC", string.format("Collection completed: %d objects in %.3fs", objectsCleaned, gcTime))
    debugPrint("GC", string.format("Memory: %.1fMB -> %.1fMB", stats.MemoryUsage, GetMemoryUsage()))
end

-- Lightweight periodic cleanup (runs more frequently)
local function RunLightCleanup()
    if tick() - (persistentData.PerformanceStats.LastOptimizationTime or 0) < CONFIG.CLEANUP_INTERVAL then
        return
    end
    
    local currentTime = tick()
    local cleaned = 0
    
    -- Quick cleanup of oldest cache entries
    if #persistentData.FailedPaths > GC_CONFIG.MAX_CACHE_ENTRIES then
        table.remove(persistentData.FailedPaths, 1)
        cleaned = cleaned + 1
    end
    
    if #persistentData.KnownVoidAreas > GC_CONFIG.MAX_CACHE_ENTRIES then
        table.remove(persistentData.KnownVoidAreas, 1)
        cleaned = cleaned + 1
    end
    
    -- Clean old movement history
    if #persistentData.MovementHistory > GC_CONFIG.MAX_HISTORY_ENTRIES then
        table.remove(persistentData.MovementHistory, 1)
        cleaned = cleaned + 1
    end
    
    if cleaned > 0 then
        debugPrint("CLEAN", "Light cleanup: " .. cleaned .. " objects")
    end
    
    persistentData.PerformanceStats.LastOptimizationTime = currentTime
end

-- Memory-safe table creation with size limits
local function CreateMemorySafeTable(maxSize)
    local mt = {
        __newindex = function(t, k, v)
            if #t >= maxSize then
                table.remove(t, 1) -- Remove oldest entry
            end
            rawset(t, k, v)
        end
    }
    
    local newTable = {}
    setmetatable(newTable, mt)
    return newTable
end

-- Initialize memory-safe tables
persistentData.FailedPaths = CreateMemorySafeTable(GC_CONFIG.MAX_CACHE_ENTRIES)
persistentData.KnownVoidAreas = CreateMemorySafeTable(GC_CONFIG.MAX_CACHE_ENTRIES)
persistentData.MovementHistory = CreateMemorySafeTable(GC_CONFIG.MAX_HISTORY_ENTRIES)

-- Create status GUI (optimized version)
local function CreateStatusGUI()
    local gui = {}
    
    -- Try different parent options for compatibility
    local parentOptions = {
        game:GetService("CoreGui"),
        game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui"),
        game:GetService("Players").LocalPlayer.Character
    }
    
    local screenGui
    for _, parent in ipairs(parentOptions) do
        if parent then
            local success, result = pcall(function()
                local newGui = Instance.new("ScreenGui")
                newGui.Name = "LinkedSwordAI_Status_GC"
                newGui.ResetOnSpawn = false -- Prevent respawn recreation
                newGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                newGui.Parent = parent
                return newGui
            end)
            
            if success then
                screenGui = result
                break
            end
        end
    end
    
    if not screenGui then
        forcePrint("LinkedSwordAI: Failed to create GUI - No valid parent found")
        return nil
    end
    
    -- Create frame with optimized properties
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 220, 0, 140) -- Slightly larger for GC info
    frame.Position = UDim2.new(0.02, 0, 0.02, 0) -- Move to corner to avoid obstruction
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.7 -- More transparent
    frame.BorderSizePixel = 1 -- Thinner border
    frame.BorderColor3 = Color3.fromRGB(100, 100, 100)
    frame.Parent = screenGui
    
    -- Status text
    local status = Instance.new("TextLabel")
    status.Size = UDim2.new(1, -10, 0, 18)
    status.Position = UDim2.new(0, 5, 0, 5)
    status.BackgroundTransparency = 1
    status.TextColor3 = Color3.fromRGB(255, 255, 255)
    status.Text = "Status: Initializing..."
    status.Font = Enum.Font.SourceSans
    status.TextSize = 12 -- Smaller font
    status.TextXAlignment = Enum.TextXAlignment.Left
    status.Parent = frame
    
    -- Target text
    local target = Instance.new("TextLabel")
    target.Size = UDim2.new(1, -10, 0, 18)
    target.Position = UDim2.new(0, 5, 0, 25)
    target.BackgroundTransparency = 1
    target.TextColor3 = Color3.fromRGB(255, 150, 150)
    target.Text = "Target: None"
    target.Font = Enum.Font.SourceSans
    target.TextSize = 12
    target.TextXAlignment = Enum.TextXAlignment.Left
    target.Parent = frame
    
    -- Distance text
    local distance = Instance.new("TextLabel")
    distance.Size = UDim2.new(1, -10, 0, 18)
    distance.Position = UDim2.new(0, 5, 0, 45)
    distance.BackgroundTransparency = 1
    distance.TextColor3 = Color3.fromRGB(150, 255, 150)
    distance.Text = "Distance: N/A"
    distance.Font = Enum.Font.SourceSans
    distance.TextSize = 12
    distance.TextXAlignment = Enum.TextXAlignment.Left
    distance.Parent = frame
    
    -- Memory text (NEW)
    local memory = Instance.new("TextLabel")
    memory.Size = UDim2.new(1, -10, 0, 18)
    memory.Position = UDim2.new(0, 5, 0, 65)
    memory.BackgroundTransparency = 1
    memory.TextColor3 = Color3.fromRGB(150, 200, 255)
    memory.Text = "Memory: Calculating..."
    memory.Font = Enum.Font.SourceSans
    memory.TextSize = 12
    memory.TextXAlignment = Enum.TextXAlignment.Left
    memory.Parent = frame
    
    -- Performance text (NEW)
    local performance = Instance.new("TextLabel")
    performance.Size = UDim2.new(1, -10, 0, 18)
    performance.Position = UDim2.new(0, 5, 0, 85)
    performance.BackgroundTransparency = 1
    performance.TextColor3 = Color3.fromRGB(255, 255, 100)
    performance.Text = "FPS: Stable"
    performance.Font = Enum.Font.SourceSans
    performance.TextSize = 12
    performance.TextXAlignment = Enum.TextXAlignment.Left
    performance.Parent = frame
    
    -- Debug text
    local debug = Instance.new("TextLabel")
    debug.Size = UDim2.new(1, -10, 0, 18)
    debug.Position = UDim2.new(0, 5, 0, 105)
    debug.BackgroundTransparency = 1
    debug.TextColor3 = Color3.fromRGB(255, 100, 255)
    debug.Text = "GC: Ready"
    debug.Font = Enum.Font.SourceSans
    debug.TextSize = 12
    debug.TextXAlignment = Enum.TextXAlignment.Left
    debug.Parent = frame
    
    -- GUI functions
    function gui.UpdateStatus(text)
        if status then
            status.Text = "Status: " .. text
        end
    end
    
    function gui.UpdateTarget(text)
        if target then
            target.Text = "Target: " .. text
        end
    end
    
    function gui.UpdateDistance(dist)
        if distance then
            distance.Text = "Distance: " .. (dist and string.format("%.1f", dist) or "N/A")
        end
    end
    
    function gui.UpdateMemory(usage)
        if memory then
            memory.Text = "Memory: " .. string.format("%.1fMB", usage or 0)
        end
    end
    
    function gui.UpdatePerformance(avgFrameTime)
        if performance then
            local fps = avgFrameTime > 0 and math.floor(1 / avgFrameTime) or 0
            local statusColor = fps > 30 and "Good" or fps > 20 and "Fair" or "Poor"
            performance.Text = "FPS: " .. fps .. " (" .. statusColor .. ")"
        end
    end
    
    function gui.UpdateDebug(text)
        if debug then
            debug.Text = "GC: " .. text
        end
    end
    
    function gui.Cleanup()
        if screenGui then
            screenGui:Destroy()
        end
    end
    
    return gui
end

-- Main execution in protected call
local function InitializeAI()
    -- Services
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    
    -- Get player and character
    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        forcePrint("LinkedSwordAI: LocalPlayer not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: LocalPlayer found - " .. LocalPlayer.Name)
    
    local Character = LocalPlayer.Character
    if not Character then
        forcePrint("LinkedSwordAI: Character not found")
        return false
    end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    
    if not Humanoid or not HumanoidRootPart then
        forcePrint("LinkedSwordAI: Humanoid or HumanoidRootPart not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: Character components found")
    
    -- Create status GUI if it doesn't exist
    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
        if not persistentData.StatusGUI then
            forcePrint("LinkedSwordAI: Failed to create status GUI")
        else
            forcePrint("LinkedSwordAI: Status GUI created")
        end
    end
    
    -- Memory-optimized version of FindLinkedSword
    local function FindLinkedSword()
        -- Use stored sword name first for efficiency
        if persistentData.SwordToolName then
            local storedSword = Character:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                return storedSword
            end
            
            storedSword = LocalPlayer.Backpack:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                return storedSword
            end
        end
        
        -- Efficient search with early termination
        for _, tool in pairs(Character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        
        return nil
    end
    
    -- Check for sword periodically (optimized)
    local function CheckForSword()
        local currentTime = tick()
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword = FindLinkedSword()
            end
            persistentData.LastSwordCheckTime = currentTime
        end
    end
    
    -- Optimized FindPlayersInRange with memory limits
    local function FindPlayersInRange()
        local playersInRange = {}
        local playerCount = 0
        
        for _, player in pairs(Players:GetPlayers()) do
            if playerCount >= CONFIG.MAX_PLAYER_CACHE then break end -- Limit iterations
            
            if player ~= LocalPlayer and player.Character and 
               player.Character:FindFirstChild("HumanoidRootPart") and
               player.Character:FindFirstChild("Humanoid") and
               player.Character.Humanoid.Health > CONFIG.MIN_HEALTH_CHECK then
                
                local playerHRP = player.Character.HumanoidRootPart
                local distance = (playerHRP.Position - HumanoidRootPart.Position).Magnitude
                
                if distance <= CONFIG.DETECTION_RADIUS then
                    -- Check if player has ForceField (optimized)
                    local hasForceField = false
                    for _, child in pairs(player.Character:GetChildren()) do
                        if child:IsA("ForceField") then
                            hasForceField = true
                            break
                        end
                    end
                    
                    table.insert(playersInRange, {
                        player = player,
                        distance = distance,
                        hasForceField = hasForceField
                    })
                    playerCount = playerCount + 1
                end
            end
        end
        
        -- Sort by distance
        table.sort(playersInRange, function(a, b)
            return a.distance < b.distance
        end)
        
        return playersInRange
    end
    
    -- Memory-optimized path checking
    local function IsVoidArea(position)
        -- Quick Y-threshold check first (most common case)
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            return true
        end
        
        -- Raycast to check for ground (optimized)
        local ray = Ray.new(position, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
        local hit = Workspace:FindPartOnRayWithIgnoreList(ray, {Character})
        
        return not hit
    end
    
    -- Rest of the functions remain similar but with memory optimizations...
    -- [Previous functionality implementations with GC integration]
    
    -- Main update function with garbage collection integration
    local function Update()
        -- Update performance metrics first
        UpdatePerformanceMetrics()
        
        -- Run light cleanup every few seconds
        RunLightCleanup()
        
        -- Run full garbage collection periodically
        local currentTime = tick()
        if currentTime - persistentData.GarbageCollector.LastCollectionTime > GC_CONFIG.COLLECTION_INTERVAL then
            local aggressive = persistentData.PerformanceStats.MemoryUsage > GC_CONFIG.AGGRESSIVE_THRESHOLD
            RunGarbageCollection(aggressive)
        end
        
        -- Update GUI with performance info
        if persistentData.StatusGUI then
            persistentData.StatusGUI.UpdateMemory(persistentData.PerformanceStats.MemoryUsage)
            persistentData.StatusGUI.UpdatePerformance(persistentData.PerformanceStats.AverageFrameTime)
            
            -- Show GC status
            if persistentData.GarbageCollector.IsRunning then
                persistentData.StatusGUI.UpdateDebug("Running GC...")
            else
                local nextGC = GC_CONFIG.COLLECTION_INTERVAL - (currentTime - persistentData.GarbageCollector.LastCollectionTime)
                persistentData.StatusGUI.UpdateDebug("Next GC: " .. math.floor(nextGC) .. "s")
            end
        end
        
        -- Original update logic continues here...
        -- [Rest of the original Update function code]
        
        -- Check for sword periodically
        CheckForSword()
        
        -- Target finding and combat logic...
        -- [Previous target handling and combat code]
    end
    
    -- Handle proper sword equipping on respawn
    spawn(function()
        wait(CONFIG.RESPAWN_EQUIP_DELAY)
        
        persistentData.LinkedSword = FindLinkedSword()
        if persistentData.LinkedSword then
            -- Equipment logic...
        end
    end)
    
    -- Initialize with memory optimization
    persistentData.LinkedSword = FindLinkedSword()
    persistentData.LastSwordCheckTime = tick()
    
    -- Initial garbage collection
    spawn(function()
        wait(5) -- Wait for initialization to complete
        RunGarbageCollection(false)
    end)
    
    -- Connect update function with error handling
    local updateConnection
    updateConnection = RunService.Heartbeat:Connect(function()
        local success, error = pcall(Update)
        if not success then
            forcePrint("LinkedSwordAI: Error in update - " .. tostring(error))
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateStatus("Error: " .. tostring(error)) 
            end
        end
    end)
    
    -- Handle character respawn with cleanup
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        forcePrint("LinkedSwordAI: Character respawned, reinitializing...")
        
        -- Clean up before reinitializing
        if updateConnection then
            updateConnection:Disconnect()
        end
        
        if persistentData.StatusGUI then
            persistentData.StatusGUI.Cleanup()
            persistentData.StatusGUI = nil
        end
        
        wait(2) -- Wait for character to fully load
        InitializeAI()
    end)
    
    if persistentData.StatusGUI then 
        persistentData.StatusGUI.UpdateStatus("AI Running (GC Optimized)") 
    end
    forcePrint("LinkedSwordAI: Script initialized with garbage collection")
    
    return true
end

-- Enhanced startup with memory monitoring
local function OptimizedStartup()
    forcePrint("LinkedSwordAI: Starting with memory optimization...")
    
    -- Set initial memory baseline
    persistentData.PerformanceStats.MemoryUsage = GetMemoryUsage()
    persistentData.GarbageCollector.LastCollectionTime = tick()
    
    -- Start the AI
    local success, errorMsg = pcall(InitializeAI)
    
    if not success then
        forcePrint("LinkedSwordAI: Critical error - " .. tostring(errorMsg))
        
        -- Attempt cleanup on error
        pcall(RunGarbageCollection, true)
    end
    
    return success
end

-- Start the optimized AI
OptimizedStartup()
[file content end]
