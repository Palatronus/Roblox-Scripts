-- LocalScript in StarterPlayerScripts or StarterGui

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local LocalStorageService = game:GetService("LocalStorageService")

-- Wait for the player
local player = Players.LocalPlayer

-- Wait for 7.5 seconds
wait(7.5)

-- Grace period: 5 seconds where the bot ignores kills
local gracePeriod = true
wait(5)
gracePeriod = false

-- Whitelist
local whitelist = {
    Owner = {"HollowGol"},
    Mod = {
        "STEVETheReal916", "ColonThreeSpam", "SpawnYellow2", "SpawnBlack1",
        "s71pl", "Jacobthecool292", "babyyodasonglol", "forhelpingboi8",
        "Kandale_Dingul", "redalert_E", "fariahoque28", "baze15651",
        "well_ihateboblux", "0bj687Alt"
    }
}

-- Check if a player is whitelisted
local function isWhitelisted(player)
    local username = player.Name
    for _, owner in ipairs(whitelist.Owner) do
        if username == owner then
            return "Owner"
        end
    end
    for _, mod in ipairs(whitelist.Mod) do
        if username == mod then
            return "Mod"
        end
    end
    return false
end

-- Looplist (loaded from LocalStorage)
local looplist = {}
local looplistString = ""

-- Load looplist from LocalStorage
local function loadLooplist()
    local saved = LocalStorageService:GetItem("SentinelLooplist")
    if saved then
        looplistString = saved
        -- Parse the string into a table
        looplist = {}
        for username in string.gmatch(saved, "@([^,]+)") do
            table.insert(looplist, username)
        end
    else
        looplistString = ""
        looplist = {}
    end
end

-- Save looplist to LocalStorage
local function saveLooplist()
    LocalStorageService:SetItem("SentinelLooplist", looplistString)
end

-- Add a user to the looplist
local function addToLooplist(username)
    -- Check if already in looplist
    for _, name in ipairs(looplist) do
        if name == username then
            return
        end
    end
    table.insert(looplist, username)
    looplistString = looplistString .. "@" .. username .. ","
    saveLooplist()
end

-- Remove a user from the looplist
local function removeFromLooplist(username)
    local newLooplist = {}
    for _, name in ipairs(looplist) do
        if name ~= username then
            table.insert(newLooplist, name)
        end
    end
    looplist = newLooplist
    -- Rebuild the string
    looplistString = ""
    for _, name in ipairs(looplist) do
        looplistString = looplistString .. "@" .. name .. ","
    end
    saveLooplist()
end

-- Simulate key presses (using VirtualInputManager)
local function simulateKeyPress(keyCode)
    game:GetService("VirtualInputManager"):SendKeyEvent(true, keyCode, false, game)
    wait(0.05)
    game:GetService("VirtualInputManager"):SendKeyEvent(false, keyCode, false, game)
    wait(0.05)
end

-- Type a command (assuming the command bar is opened by F2)
local function typeCommand(command)
    -- Open command bar (F2)
    simulateKeyPress(Enum.KeyCode.F2)

    -- Type the command string (we are going to simulate each key)
    -- We are going to use a mapping from string to KeyCode for alphanumeric and some symbols.
    -- This is a simplified version and might not work for all characters.

    -- We are going to use a function to type a string by simulating key presses.
    local function typeString(str)
        for i = 1, #str do
            local c = str:sub(i, i)
            local keyCode = nil

            -- Map character to KeyCode
            if c:match("%a") then
                -- Letter (assume uppercase if needed, but we are going to use Shift if needed)
                keyCode = Enum.KeyCode[string.upper(c)]
            elseif c:match("%d") then
                -- Digit
                keyCode = Enum.KeyCode[c]
            else
                -- Special characters
                local special = {
                    [' '] = Enum.KeyCode.Space,
                    [':'] = Enum.KeyCode.Semicolon,
                    [';'] = Enum.KeyCode.Semicolon,
                    [','] = Enum.KeyCode.Comma,
                    ['.'] = Enum.KeyCode.Period,
                    ['/'] = Enum.KeyCode.Slash,
                    ['\\'] = Enum.KeyCode.Backslash,
                    ['['] = Enum.KeyCode.LeftBracket,
                    [']'] = Enum.KeyCode.RightBracket,
                    ['-'] = Enum.KeyCode.Hyphen,
                    ['='] = Enum.KeyCode.Equals,
                    ['`'] = Enum.KeyCode.Backquote,
                    ['~'] = Enum.KeyCode.Backquote, -- with shift
                    ['!'] = Enum.KeyCode.One, -- with shift
                    ['@'] = Enum.KeyCode.Two, -- with shift
                    ['#'] = Enum.KeyCode.Three, -- with shift
                    ['$'] = Enum.KeyCode.Four, -- with shift
                    ['%'] = Enum.KeyCode.Five, -- with shift
                    ['^'] = Enum.KeyCode.Six, -- with shift
                    ['&'] = Enum.KeyCode.Seven, -- with shift
                    ['*'] = Enum.KeyCode.Eight, -- with shift
                    ['('] = Enum.KeyCode.Nine, -- with shift
                    [')'] = Enum.KeyCode.Zero, -- with shift
                    ['_'] = Enum.KeyCode.Hyphen, -- with shift
                    ['+'] = Enum.KeyCode.Equals, -- with shift
                    ['{'] = Enum.KeyCode.LeftBracket, -- with shift
                    ['}'] = Enum.KeyCode.RightBracket, -- with shift
                    ['|'] = Enum.KeyCode.Backslash, -- with shift
                    ['"'] = Enum.KeyCode.Quote, -- with shift
                    ['<'] = Enum.KeyCode.Comma, -- with shift
                    ['>'] = Enum.KeyCode.Period, -- with shift
                    ['?'] = Enum.KeyCode.Slash, -- with shift
                }
                keyCode = special[c]
            end

            if keyCode then
                -- Check if we need Shift
                local shift = false
                if c:match("%u") or c:match("[~!@#$%%^&*()_+{}|:<>?]") then
                    shift = true
                end

                if shift then
                    -- Press Shift and then the key
                    game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
                end

                simulateKeyPress(keyCode)

                if shift then
                    game:GetService("VirtualInputManager"):SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
                end
            end
        end
    end

    typeString(command)

    -- Press Enter
    simulateKeyPress(Enum.KeyCode.Return)
end

-- Run startup commands
local function runStartupCommands()
    typeCommand("inf^5^tppos 0 -1000000 0")
    typeCommand("spawn")
    typeCommand("inf^0.1^loopkill " .. looplistString)
    typeCommand("inf^2^walkfling")
    typeCommand("inf^0.1^loopgoto " .. looplistString .. " 0")
    typeCommand("instarespawn")
    typeCommand("novoid")
    typeCommand("antiban")
    typeCommand("lessfilter 1")
end

-- Create the Looplist GUI
local function createLooplistGUI()
    -- Create a ScreenGui
    local gui = Instance.new("ScreenGui")
    gui.Name = "SentinelLooplistGUI"
    gui.Parent = player.PlayerGui

    -- Create a Frame
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 400, 0, 300)
    frame.Position = UDim2.new(0, 10, 0, 10)
    frame.BackgroundColor3 = Color3.new(0, 0, 0)
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.new(1, 1, 1)
    frame.Parent = gui

    -- Make the frame draggable
    local dragToggle = nil
    local dragInput = nil
    local dragStart = nil
    local startPos = nil

    local function updateInput(input)
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end

    frame.InputBegan:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
            dragToggle = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragToggle = false
                end
            end)
        end
    end)

    frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragToggle then
            updateInput(input)
        end
    end)

    -- Minimize button
    local minimizeButton = Instance.new("TextButton")
    minimizeButton.Size = UDim2.new(0, 20, 0, 20)
    minimizeButton.Position = UDim2.new(1, -20, 0, 0)
    minimizeButton.Text = "_"
    minimizeButton.BackgroundColor3 = Color3.new(1, 1, 1)
    minimizeButton.TextColor3 = Color3.new(0, 0, 0)
    minimizeButton.Parent = frame

    local minimized = false
    local originalSize = frame.Size
    local minimizedSize = UDim2.new(0, 100, 0, 30)

    minimizeButton.MouseButton1Click:Connect(function()
        minimized = not minimized
        if minimized then
            frame.Size = minimizedSize
            -- Hide the content
            for _, child in ipairs(frame:GetChildren()) do
                if child ~= minimizeButton then
                    child.Visible = false
                end
            end
        else
            frame.Size = originalSize
            for _, child in ipairs(frame:GetChildren()) do
                child.Visible = true
            end
        end
    end)

    -- Title
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(0, 200, 0, 20)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.Text = "Sentinel Looplist"
    title.BackgroundColor3 = Color3.new(0, 0, 0)
    title.TextColor3 = Color3.new(1, 1, 1)
    title.Parent = frame

    -- Search bar
    local searchBox = Instance.new("TextBox")
    searchBox.Size = UDim2.new(0, 200, 0, 20)
    searchBox.Position = UDim2.new(0, 0, 0, 25)
    searchBox.PlaceholderText = "Search..."
    searchBox.BackgroundColor3 = Color3.new(1, 1, 1)
    searchBox.TextColor3 = Color3.new(0, 0, 0)
    searchBox.Parent = frame

    -- Looplist text box
    local looplistBox = Instance.new("TextBox")
    looplistBox.Size = UDim2.new(0, 380, 0, 200)
    looplistBox.Position = UDim2.new(0, 10, 0, 50)
    looplistBox.Text = looplistString
    looplistBox.BackgroundColor3 = Color3.new(1, 1, 1)
    looplistBox.TextColor3 = Color3.new(0, 0, 0)
    looplistBox.MultiLine = true
    looplistBox.TextWrapped = true
    looplistBox.Parent = frame

    -- Update the looplist string when the text box is changed
    looplistBox:GetPropertyChangedSignal("Text"):Connect(function()
        looplistString = looplistBox.Text
        -- Parse the string and update the looplist table
        looplist = {}
        for username in string.gmatch(looplistString, "@([^,]+)") do
            table.insert(looplist, username)
        end
        saveLooplist()
    end)

    -- Search function
    searchBox:GetPropertyChangedSignal("Text"):Connect(function()
        local searchText = searchBox.Text:lower()
        if searchText == "" then
            looplistBox.Text = looplistString
        else
            -- Filter the looplist
            local filtered = ""
            for _, username in ipairs(looplist) do
                if username:lower():find(searchText, 1, true) then
                    filtered = filtered .. "@" .. username .. ","
                end
            end
            looplistBox.Text = filtered
        end
    end)
end

-- Chat command system
local function onChatMessage(message, speaker)
    -- Check if the speaker is whitelisted
    local rank = isWhitelisted(speaker)
    if not rank then return end

    -- Check if the message starts with "sentinel"
    if message:sub(1, 8):lower() == "sentinel" then
        local args = {}
        for word in message:gmatch("%S+") do
            table.insert(args, word)
        end

        if #args < 2 then return end

        local command = args[2]:lower()

        if command == "temploop" and #args >= 3 then
            local username = args[3]
            -- Remove the @ if present
            username = username:gsub("@", "")
            typeCommand("inf^0.1^loopkill @" .. username)
            typeCommand("inf^0.1^loopgoto @" .. username .. " 0")
            -- Do not save to looplist

        elseif command == "jump" and #args >= 3 then
            local username = args[3]
            username = username:gsub("@", "")
            typeCommand("inf^0.1^loopkill @" .. username)
            typeCommand("inf^0.1^loopgoto @" .. username .. " 0")
            addToLooplist(username)

        elseif command == "unloop" and #args >= 3 then
            local username = args[3]
            username = username:gsub("@", "")
            removeFromLooplist(username)
            -- Then we break and reapply the looplist
            typeCommand("break")
            typeCommand("unloopgoto all")
            typeCommand("unloopkill all")
            typeCommand("inf^5^tppos 0 -1000000 0")
            typeCommand("inf^0.1^loopkill " .. looplistString)
            typeCommand("inf^2^walkfling")
            typeCommand("inf^0.1^loopgoto " .. looplistString .. " 0")

        elseif command == "shop" then
            -- Server hop (we are going to use a server hopping function)
            -- We are going to use the TeleportService to teleport to a new server of the same place.
            local TeleportService = game:GetService("TeleportService")
            local placeId = game.PlaceId
            TeleportService:Teleport(placeId)
        end
    end
end

-- Listen for chat messages
local function setupChatListener()
    -- We are going to use the Player's Chatted event for the local player? But we want to listen to all players?
    -- We are going to use the game:GetService("Chat"):Chatted event? But that is for the local player.

    -- Alternatively, we can use the `Players.PlayerChatted` event? But that is not available.

    -- We are going to use a method to listen to all players' chat.

    -- We are going to use the `ChatService` if available, but it's not in every game.

    -- Since we are using an executor, we might have access to the `ChatService`? Let's use the traditional method of looping through players and connecting to their `Chatted` event.

    for _, plr in ipairs(Players:GetPlayers()) do
        plr.Chatted:Connect(function(message)
            onChatMessage(message, plr)
        end)
    end

    Players.PlayerAdded:Connect(function(plr)
        plr.Chatted:Connect(function(message)
            onChatMessage(message, plr)
        end)
    end)
end

-- Automated detection

-- We are going to check for kills on the bot (the local player) and measure the distance.

-- We are going to use the `Players.PlayerAdded` and `Players.PlayerRemoved` to track the bot's humanoid.

-- We are going to check when the bot's humanoid health reaches 0 and then check the killer.

local function setupAutomatedDetection()
    -- Track the bot's character
    local character = player.Character
    if not character then
        player.CharacterAdded:Wait()
        character = player.Character
    end

    local humanoid = character:WaitForChild("Humanoid")

    -- We are going to use a function to get the killer from the humanoid
    humanoid.Died:Connect(function()
        if gracePeriod then return end

        -- Wait for the death to be processed and then check the killer
        wait(0.1)

        -- We are going to check the humanoid's `creator` attribute or the last damage source?
        -- This is complex and game-specific.

        -- We are going to assume that the game uses the `creator` attribute on the humanoid to set the killer.

        local killer = humanoid:GetAttribute("creator")
        if killer and killer:IsA("Player") then
            -- Check the distance between the killer and the bot at the time of death
            local killerCharacter = killer.Character
            if killerCharacter then
                local killerRoot = killerCharacter:FindFirstChild("HumanoidRootPart")
                local botRoot = character:FindFirstChild("HumanoidRootPart")
                if killerRoot and botRoot then
                    local distance = (killerRoot.Position - botRoot.Position).Magnitude

                    -- Check if the distance is more than 15 studs
                    if distance >= 15 then
                        -- Apply a kill command on the killer
                        typeCommand("kill @" .. killer.Name)
                    end

                    -- If the distance is more than 24, loop the target
                    if distance >= 24 then
                        addToLooplist(killer.Name)
                        typeCommand("inf^0.1^loopkill @" .. killer.Name)
                        typeCommand("inf^0.1^loopgoto @" .. killer.Name .. " 0")
                    end
                end
            end

            -- Check account age (this requires server-side, so we skip for now)

            -- Check for multiple kills in a short time (we need to track kills per player)

            -- We are going to use a table to track kills per player and the time of the kill
            local killLog = {}
            local now = tick()
            table.insert(killLog, {player = killer, time = now})

            -- Remove old entries (older than 0.25 seconds)
            for i = #killLog, 1, -1 do
                if now - killLog[i].time > 0.25 then
                    table.remove(killLog, i)
                end
            end

            -- Check if the same player has at least 2 kills in the window
            local count = 0
            for _, log in ipairs(killLog) do
                if log.player == killer then
                    count = count + 1
                end
            end

            if count >= 2 then
                addToLooplist(killer.Name)
                typeCommand("inf^0.1^loopkill @" .. killer.Name)
                typeCommand("inf^0.1^loopgoto @" .. killer.Name .. " 0")
            end
        end
    end)

    -- Check for flinging (high velocity)
    -- We are going to check the velocity of other players and if it's too high, kill them.
    local function checkFlinging()
        while wait(0.1) do
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= player and not isWhitelisted(plr) then
                    local char = plr.Character
                    if char then
                        local root = char:FindFirstChild("HumanoidRootPart")
                        if root and root.Velocity.Magnitude > 100 then -- arbitrary high velocity
                            typeCommand("kill @" .. plr.Name)
                        end
                    end
                end
            end
        end
    end

    spawn(checkFlinging)
end

-- Server hopping
local function setupServerHop()
    while wait(5) do
        local playerCount = 0
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= player and not isWhitelisted(plr) then
                playerCount = playerCount + 1
            end
        end

        if playerCount == 0 then
            -- Server hop
            local TeleportService = game:GetService("TeleportService")
            local placeId = game.PlaceId
            TeleportService:Teleport(placeId)
        end
    end
end

-- Initialize
loadLooplist()
createLooplistGUI()
runStartupCommands()
setupChatListener()
setupAutomatedDetection()
setupServerHop()
