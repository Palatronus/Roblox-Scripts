-- SFOTHO Security Bot Script v3.1 - Complete Rewrite
-- FE Compatible Vigilante Security System
-- Fully Functional with Zero Console Leakage

 print("Loading SFOTHO Security Bot v4.0...")

-- ========================================
-- CORE SERVICES INITIALIZATION
-- ========================================

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TextChatService = game:GetService("TextChatService")
local ContextActionService = game:GetService("ContextActionService")
local CoreGui = game:GetService("CoreGui")
local StarterGui = game:GetService("StarterGui")
local TeleportService = game:GetService("TeleportService")

local LocalPlayer = Players.LocalPlayer
local botOwner = LocalPlayer.Name

-- ========================================
-- CONFIGURATION
-- ========================================

local Config = {
    NEW_ACCOUNT_THRESHOLD = 0, -- Days for new account detection
    LONG_KILL_DISTANCE = 14, -- studs; above this considered suspicious
    COMMAND_DELAY = 0.75, -- delay between commands in sequences
    CHAR_DELAY_MIN = 0.05,
    CHAR_DELAY_MAX = 0.18,
    RETRY_LIMIT = 3,
    STOP_KEYWORD = "Qpmbsjbvt",
    SEQUENCE_ON_JOIN = true,
    COMMAND_TOGGLE_CHAR = "ş", -- requested custom key to open IY command bar
    COMMAND_TOGGLE_KEYCODE = Enum.KeyCode.Semicolon, -- fallback toggle
    COMMAND_TOGGLE_FALLBACKS = {"Backquote", "Quote", "Slash"}, -- extra keys to try
    COMMAND_TOGGLE_ATTEMPTS = 3,
    COMMAND_BAR_FOCUS_TIMEOUT = 0.6,
    POST_TOGGLE_WAIT = 0.35,
    PRE_TYPE_WAIT = 0.07,
    POST_TYPE_WAIT = 0.12,
    POST_ENTER_WAIT = 0.28,
    -- Precise targeting and visual verification
    COMMAND_BAR_TARGET_HINTS = {
        "infiniteyield", "iy", "commandbar", "cmdbar", "cmd", "command"
    },
    VERIFY_INPUT_VISUALLY = true,
    VISUAL_CONFIRM_DURATION = 0.8,
    INPUT_VERIFY_TIMEOUT = 0.6,
    DEBUG_INPUT = false,
    FOCUS_RECAPTURE_RETRY = 6,
    EXTERNAL_LOOPLIST_PATH = "C:/Users/MEV/Desktop/Loopkills.txt",
    PLACE_ID = game.PlaceId,
    SERVER_HOP_CHECK_DELAY = 10, -- seconds after join to check solo
    ACTION_ON_NEW_ACCOUNT = "loopkill", -- loopkill | loopfling | singlekill
    ACTION_ON_KILL_BOT = "loopfling", -- action when someone kills the bot
    ACTION_ON_LONG_DISTANCE = "singlekill" -- action for suspicious long-distance kills
    ,
    LOOPLIST_FILE = "SecurityBot_looplist.txt" -- local file to persist current loop list
    ,
    -- Stuck watchdog
    STUCK_MOVE_EPSILON = 2.0,      -- minimum movement to consider not stuck (studs)
    STUCK_FREEZE_TIMEOUT = 10,     -- seconds with < epsilon movement before recovery
    STUCK_RECOVERY_ENABLED = true  -- run auto-recovery when frozen
    ,
    -- Persistence and security
    PERSIST_DATA_FOLDER = "SecurityBot_Data",
    PERSIST_JSON_PATH = "SecurityBot_Data/looped.json",
    TEMP_LOOP_TTL_SEC = 0,           -- 0 = never expire temporary loops
    ENCRYPT_STORAGE = true,
    ENCRYPTION_KEY_SEED = "SentinelKeySeed",
    -- Desktop bridge fallback (used when direct file writes are blocked)
    BRIDGE_ENABLED = true,
    BRIDGE_URL = "http://127.0.0.1:8765" -- expected endpoints: /append, /remove, /set
}

-- ========================================
-- WHITELIST SYSTEMS
-- ========================================

local OWNER_WHITELIST = {"HollowGol"}
local MOD_WHITELIST = {
    "STEVETheReal916", "ColonThreeSpam", "SpawnYellow2", "SpawnBlack1",
    "s71pl", "Jacobthecool292", "babyyodasonglol",
    "Kandale_Dingul", "redalert_E", "fariahoque28", "baze15651",
    "well_ihateboblux", "0bj687Alt"
}

-- ========================================
-- STATE MANAGEMENT
-- ========================================

local State = {
    processedPlayers = {},
    loopedPlayers = {},
    stoppedPlayers = {},
    botActive = false,
    seqRan = false,
    connections = {},
    textInputSupported = false,
    lastAttackerName = nil,
    lastAttackerDist = 0,
    initialSetupComplete = false,
}

-- ========================================
-- UTILITY FUNCTIONS
-- ========================================

local function safeWait(duration)
    local success, err = pcall(function()
        task.wait(duration or 0.1)
    end)
    if not success then
        print("[ERROR] Wait failed:", err)
    end
end

-- ========================================
-- FILESYSTEM HELPERS (optional, executor-dependent)
-- ========================================

local function hasFilesystem()
    return type(isfile) == "function" and type(writefile) == "function" and type(readfile) == "function"
end

local function normalizeName(name)
    if not name or name == "" then return nil end
    return name:gsub("^@", "")
end

-- Case-insensitive normalization for whitelist comparisons
local function normalizeForCompare(name)
    if not name or name == "" then return "" end
    return string.lower((name:gsub("^@", "")))
end

-- External looplist file support (Windows path)
local function resolveExternalPath(raw)
    local p = raw or Config.EXTERNAL_LOOPLIST_PATH
    if not p or p == "" then return "Loopkills.txt" end
    p = p:gsub("\\", "/")
    p = p:gsub("^/", "")
    return p
end

local function ensureLooplistFile()
    if not hasFilesystem() then return end
    local primary = resolveExternalPath()
    local ok = true
    if not isfile(primary) then
        ok = pcall(function()
            writefile(primary, "")
        end)
    end
    if not ok then
        print("[WARN] Unable to create primary looplist file:", primary)
        -- Fallback inside executor workspace
        local folder = Config.PERSIST_DATA_FOLDER
        if type(isfolder) == "function" and not isfolder(folder) then
            pcall(function() makefolder(folder) end)
        end
        local fb = Config.PERSIST_DATA_FOLDER.."/Loopkills.txt"
        State.loopPathFallback = fb
        if not isfile(fb) then
            local okfb = pcall(function() writefile(fb, "") end)
            if not okfb then print("[WARN] Fallback looplist file failed:", fb) end
        end
    else
        State.loopPathFallback = nil
    end
end

-- ========================================
-- DESKTOP BRIDGE (HTTP) FALLBACKS
-- ========================================

local function httpGet(url)
    local ok, res
    -- Try common executor-specific HTTP functions first
    if type(http_request) == "function" then
        ok, res = pcall(function() return http_request({Url = url, Method = "GET"}) end)
    elseif type(syn) == "table" and type(syn.request) == "function" then
        ok, res = pcall(function() return syn.request({Url = url, Method = "GET"}) end)
    elseif type(request) == "function" then
        ok, res = pcall(function() return request({Url = url, Method = "GET"}) end)
    end
    if ok and res then
        if type(res) == "table" then
            if res.Success == true and (res.Body or res.StatusCode == 200) then return res.Body or "" end
            if res.StatusCode == 200 and res.Body then return res.Body end
        elseif type(res) == "string" then
            return res
        end
    end
    -- Fallback to Roblox HttpService if permitted
    local ok2, body = pcall(function()
        return game:HttpGet(url)
    end)
    if ok2 and body then return body end
    return nil
end

local function bridgeEnabled()
    return Config.BRIDGE_ENABLED and type(Config.BRIDGE_URL) == "string" and #Config.BRIDGE_URL > 0
end

local function bridgeAppend(name)
    if not bridgeEnabled() then return false end
    local n = normalizeName(name)
    if not n or n == "" then return false end
    local url = string.format("%s/append?name=%s", Config.BRIDGE_URL, HttpService:UrlEncode(n))
    return httpGet(url) ~= nil
end

local function bridgeRemove(name)
    if not bridgeEnabled() then return false end
    local n = normalizeName(name)
    if not n or n == "" then return false end
    local url = string.format("%s/remove?name=%s", Config.BRIDGE_URL, HttpService:UrlEncode(n))
    return httpGet(url) ~= nil
end

local function bridgeSet(names)
    if not bridgeEnabled() then return false end
    local list
    if type(names) == "table" then
        local tmp = {}
        for _, nn in ipairs(names) do
            local u = normalizeName(nn)
            if u and u ~= "" then table.insert(tmp, u) end
        end
        list = table.concat(tmp, ",")
    else
        list = tostring(names or "")
    end
    local url = string.format("%s/set?names=%s", Config.BRIDGE_URL, HttpService:UrlEncode(list))
    return httpGet(url) ~= nil
end

local function readExternalLoopNames()
    local namesSet = {}
    if not hasFilesystem() then return {} end
    local path = resolveExternalPath()
    local ok, content = pcall(function() return readfile(path) end)
    if not ok or not content or content == "" then
        local fb = State.loopPathFallback or (Config.PERSIST_DATA_FOLDER.."/Loopkills.txt")
        ok, content = pcall(function() return readfile(fb) end)
        if not ok or not content then content = "" end
    end
    for token in string.gmatch(content, "[^,;\n]+") do
        local n = normalizeName(token:match("^%s*(.-)%s*$"))
        if n and n ~= "" then namesSet[n] = true end
    end
    local arr = {}
    for n, _ in pairs(namesSet) do table.insert(arr, n) end
    table.sort(arr)
    return arr
end

local function writeExternalLoopNames(names)
    if not hasFilesystem() then
        -- Use bridge as a fallback when direct FS writes are unavailable
        local okb = bridgeSet(names or {})
        if not okb then print("[WARN] Bridge set failed; cannot persist looplist externally.") end
        return
    end
    local path = resolveExternalPath()
    local uniq = {}
    for _, n in ipairs(names or {}) do
        local u = normalizeName(n)
        if u and u ~= "" then uniq[u] = true end
    end
    local out = {}
    for n, _ in pairs(uniq) do table.insert(out, n) end
    table.sort(out)
    local lines = {}
    for _, n in ipairs(out) do table.insert(lines, "@"..n..",") end
    local payload = table.concat(lines, "\n")
    local ok = pcall(function() writefile(path, payload) end)
    if not ok then
        local fb = State.loopPathFallback or (Config.PERSIST_DATA_FOLDER.."/Loopkills.txt")
        local okfb = pcall(function() writefile(fb, payload) end)
        State.loopPathFallback = fb
        if not okfb then
            print("[WARN] Unable to write both primary and fallback looplist files.")
            -- Last resort: desktop bridge
            local okb = bridgeSet(out)
            if not okb then print("[WARN] Bridge set failed; external list not updated.") end
        end
    end
end

local function addNameToExternalLooplist(playerName)
    if not hasFilesystem() then
        local okb = bridgeAppend(playerName)
        if not okb then print("[WARN] Bridge append failed for", playerName) end
        return
    end
    ensureLooplistFile()
    local arr = readExternalLoopNames()
    local set = {}
    for _, n in ipairs(arr) do set[n] = true end
    local name = normalizeName(playerName)
    if not name then return end
    if set[name] then return end
    set[name] = true
    local out = {}
    for n, _ in pairs(set) do table.insert(out, n) end
    writeExternalLoopNames(out)
end

local function removeNameFromExternalLooplist(playerName)
    if not hasFilesystem() then
        local okb = bridgeRemove(playerName)
        if not okb then print("[WARN] Bridge remove failed for", playerName) end
        return
    end
    local arr = readExternalLoopNames()
    local set = {}
    for _, n in ipairs(arr) do set[n] = true end
    local name = normalizeName(playerName)
    if not name then return end
    set[name] = nil
    local out = {}
    for n, _ in pairs(set) do table.insert(out, n) end
    writeExternalLoopNames(out)
end

-- Backwards-compatible wrappers
local function readLooplist()
    local arr = readExternalLoopNames()
    local list = { loopkill = {}, loopfling = {} }
    for _, n in ipairs(arr) do list.loopkill[n] = true; list.loopfling[n] = true end
    return list
end
local function writeLooplist(list)
    local arr = {}
    for n, _ in pairs((list and list.loopkill) or {}) do table.insert(arr, n) end
    writeExternalLoopNames(arr)
end
local function addToLooplist(action, playerName)
    -- Persist detection-based loops as permanent entries
    if action == "loopkill" or action == "loopfling" or action == "singlekill" then
        addNameToExternalLooplist(playerName)
        Persistent.add(playerName, "permanent", 0, "detection")
    end
end
local function removeFromLooplist(playerName)
    removeNameFromExternalLooplist(playerName)
    Persistent.remove(playerName)
end

-- ========================================
-- KEY INPUT HELPERS (enum keypress typing)
-- ========================================

local function tapKey(keyCode)
    VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
    safeWait(0.03)
    VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
end

-- Try to keep the Developer Console from stealing focus while we type commands
local function hideDevConsole()
    pcall(function()
        StarterGui:SetCore("DevConsoleVisible", false)
        StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.DevConsole, false)
    end)
end

-- Locate the IY CommandBar TextBox using path-based hints and scoring
local function findCommandTextBox()
    local hints = Config.COMMAND_BAR_TARGET_HINTS or {"infiniteyield", "iy", "commandbar"}
    local function score(tb)
        if not tb or not tb:IsA("TextBox") then return -1 end
        local full = string.lower(tb:GetFullName())
        local n = string.lower(tb.Name or "")
        local ph = string.lower(tb.PlaceholderText or "")
        local s = 0
        for _, h in ipairs(hints) do
            if #h > 0 then
                if string.find(full, h, 1, true) then s = s + 3 end
                if string.find(n, h, 1, true) then s = s + 2 end
                if ph ~= "" and string.find(ph, h, 1, true) then s = s + 2 end
            end
        end
        if string.find(n, "command", 1, true) then s = s + 1 end
        if string.find(n, "bar", 1, true) then s = s + 1 end
        if string.find(ph, "cmd", 1, true) or string.find(ph, "/cmd", 1, true) then s = s + 1 end
        if tb:IsDescendantOf(CoreGui) then s = s + 1 end
        return s
    end
    local best, bestScore = nil, -1
    local function scan(root)
        for _, d in ipairs(root:GetDescendants()) do
            if d:IsA("TextBox") then
                local sc = score(d)
                if sc > bestScore then
                    best = d
                    bestScore = sc
                end
            end
        end
    end
    pcall(function() scan(CoreGui) end)
    local pg = LocalPlayer:FindFirstChild("PlayerGui")
    if pg then pcall(function() scan(pg) end) end
    -- Require at least some confidence to avoid unintended bars
    if bestScore >= 2 then return best end
    return nil
end

local function focusCommandTextBox()
    hideDevConsole()
    local tb = findCommandTextBox()
    if tb then
        pcall(function() tb:CaptureFocus() end)
        safeWait(0.1)
        if UserInputService:GetFocusedTextBox() == tb then return true end
    end
    return false
end

-- Verify that the intended TextBox has the expected input before pressing Enter
local function verifyInputInTarget(tb, expected)
    if not tb or not tb:IsA("TextBox") then return false end
    local deadline = tick() + (Config.INPUT_VERIFY_TIMEOUT or 0.6)
    while tick() < deadline do
        local focused = UserInputService:GetFocusedTextBox()
        if focused == tb then
            local ok, current = pcall(function() return tb.Text end)
            if ok and current == expected then return true end
        end
        safeWait(0.05)
    end
    return false
end

-- Show a temporary visual overlay confirming which command bar is targeted
local function showVisualConfirm(tb, cmd)
    if not Config.VERIFY_INPUT_VISUALLY then return end
    local ok, _ = pcall(function()
        local sg = Instance.new("ScreenGui")
        sg.ResetOnSpawn = false
        sg.Name = "SB_CommandConfirm"
        sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        sg.Parent = LocalPlayer:FindFirstChild("PlayerGui") or CoreGui

        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(0, 260, 0, 80)
        frame.Position = UDim2.new(0.5, -130, 0.1, 0)
        frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        frame.BackgroundTransparency = 0.3
        frame.BorderSizePixel = 0
        frame.Parent = sg

        local ui = Instance.new("UICorner")
        ui.CornerRadius = UDim.new(0, 8)
        ui.Parent = frame

        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, -12, 1, -12)
        label.Position = UDim2.new(0, 6, 0, 6)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(255, 255, 255)
        label.TextScaled = true
        label.Font = Enum.Font.Gotham
        label.TextWrapped = true
        local targetName = "Command Bar"
        local okN, nameOrPath = pcall(function()
            return tb:GetFullName()
        end)
        if okN and nameOrPath then targetName = nameOrPath end
        label.Text = "Targeting: "..targetName.."\nCMD: "..tostring(cmd)
        label.Parent = frame

        task.delay(Config.VISUAL_CONFIRM_DURATION or 0.8, function()
            sg:Destroy()
        end)
    end)
    if not ok then
        -- Non-fatal UI failure; continue silently
    end
end

local function trySendText(text)
    local ok = pcall(function()
        -- SendTextInput(text, false) improves reliability across executors
        VirtualInputManager:SendTextInput(text, false)
    end)
    return ok
end

-- Recapture focus on the intended textbox until it sticks
local function ensureTargetFocus(tb)
    if not tb then return false end
    for i = 1, (Config.FOCUS_RECAPTURE_RETRY or 6) do
        local focused = UserInputService:GetFocusedTextBox()
        if focused == tb then return true end
        pcall(function() tb:CaptureFocus() end)
        safeWait(0.06)
    end
    return UserInputService:GetFocusedTextBox() == tb
end

-- Optional diagnostic hooks to observe text changes and focus loss
local function attachInputDebug(tb)
    if not (Config.DEBUG_INPUT and tb and tb:IsA("TextBox")) then
        return function() end
    end
    local c1, c2
    local ok = pcall(function()
        c1 = tb:GetPropertyChangedSignal("Text"):Connect(function()
            print("[INPUT-DBG] Text changed:", tb.Text)
        end)
        c2 = tb.FocusLost:Connect(function(enterPressed)
            print("[INPUT-DBG] FocusLost; enterPressed=", enterPressed)
        end)
    end)
    return function()
        if ok then
            pcall(function() if c1 then c1:Disconnect() end end)
            pcall(function() if c2 then c2:Disconnect() end end)
        end
    end
end

-- Suppress common key conflicts (chat slash, dev console F9) while typing
local function suppressConflicts(active)
    local sink = function(_, state) if state == Enum.UserInputState.Begin then return Enum.ContextActionResult.Sink end end
    if active then
        pcall(function()
            ContextActionService:BindAction("SB_SinkSlash", sink, false, Enum.KeyCode.Slash)
            ContextActionService:BindAction("SB_SinkF9", sink, false, Enum.KeyCode.F9)
        end)
    else
        pcall(function()
            ContextActionService:UnbindAction("SB_SinkSlash")
            ContextActionService:UnbindAction("SB_SinkF9")
        end)
    end
end

-- Use a single, validated key map (no invalid Enum members)
local function optKey(member)
    local ok, val = pcall(function() return Enum.KeyCode[member] end)
    if ok then return val end
    return nil
end

local KEYMAP = {
    a=Enum.KeyCode.A,b=Enum.KeyCode.B,c=Enum.KeyCode.C,d=Enum.KeyCode.D,e=Enum.KeyCode.E,
    f=Enum.KeyCode.F,g=Enum.KeyCode.G,h=Enum.KeyCode.H,i=Enum.KeyCode.I,j=Enum.KeyCode.J,
    k=Enum.KeyCode.K,l=Enum.KeyCode.L,m=Enum.KeyCode.M,n=Enum.KeyCode.N,o=Enum.KeyCode.O,
    p=Enum.KeyCode.P,q=Enum.KeyCode.Q,r=Enum.KeyCode.R,s=Enum.KeyCode.S,t=Enum.KeyCode.T,
    u=Enum.KeyCode.U,v=Enum.KeyCode.V,w=Enum.KeyCode.W,x=Enum.KeyCode.X,y=Enum.KeyCode.Y,
    z=Enum.KeyCode.Z,
    ["0"]=Enum.KeyCode.Zero,["1"]=Enum.KeyCode.One,["2"]=Enum.KeyCode.Two,["3"]=Enum.KeyCode.Three,
    ["4"]=Enum.KeyCode.Four,["5"]=Enum.KeyCode.Five,["6"]=Enum.KeyCode.Six,["7"]=Enum.KeyCode.Seven,
    ["8"]=Enum.KeyCode.Eight,["9"]=Enum.KeyCode.Nine,
    [" "]=Enum.KeyCode.Space,["."]=Enum.KeyCode.Period,[","]=Enum.KeyCode.Comma,["-"]=Enum.KeyCode.Minus,
    ["="]=Enum.KeyCode.Equals,["["]=Enum.KeyCode.LeftBracket,["]"]=Enum.KeyCode.RightBracket,
    ["\\"]=Enum.KeyCode.BackSlash,[";"]=Enum.KeyCode.Semicolon,
    ["'"]=Enum.KeyCode.Quote,["/"]=Enum.KeyCode.Slash,
    ["`"]=optKey("Backquote")
}

local function getKeyCodeForChar(char)
    return KEYMAP[string.lower(char)] or KEYMAP[char]
end

-- Detect once whether SendTextInput is supported by the current executor
local function detectTextInputSupport()
    local ok = pcall(function()
        VirtualInputManager:SendTextInput("a", false)
    end)
    State.textInputSupported = ok
end

local function typeTextSmart(text)
    -- Prefer sending the whole string at once when supported to avoid timing issues
    if State.textInputSupported then
        local ok = trySendText(text)
        if ok then return true end
        -- Fall through to keypress typing if executor blocks multi-char input
    end
    for i = 1, #text do
        local ch = string.sub(text, i, i)
        local isUpper = ch:match("[A-Z]") ~= nil
        local lower = string.lower(ch)
        local SHIFTED = {
            [":"] = Enum.KeyCode.Semicolon,
            ["_"] = Enum.KeyCode.Minus,
            ["+"] = Enum.KeyCode.Equals,
            ["\""] = Enum.KeyCode.Quote,
            ["^"] = Enum.KeyCode.Six
        }
        local base = SHIFTED[ch]
        if isUpper then base = getKeyCodeForChar(lower) end
        if base then
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
            safeWait(0.03)
            tapKey(base)
            safeWait(0.03)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
        else
            local kc = getKeyCodeForChar(ch)
            if kc then tapKey(kc) end
        end
        safeWait(math.random(math.floor(Config.CHAR_DELAY_MIN*1000), math.floor(Config.CHAR_DELAY_MAX*1000))/1000)
    end
    return true
end

-- Type robustly into a specific target TextBox, verifying after each strategy
local function typeIntoTarget(tb, text)
    if not ensureTargetFocus(tb) then return false end
    suppressConflicts(true)
    safeWait(Config.PRE_TYPE_WAIT)

    -- Strategy 1: bulk SendTextInput
    if State.textInputSupported then
        local ok = trySendText(text)
        safeWait(Config.POST_TYPE_WAIT)
        if ok and verifyInputInTarget(tb, text) then
            suppressConflicts(false)
            return true
        end
    end

    -- Strategy 2: direct property set (many IY bars rely on Text value)
    local okSet = pcall(function() tb.Text = text end)
    safeWait(0.06)
    if okSet and verifyInputInTarget(tb, text) then
        suppressConflicts(false)
        return true
    end

    -- Strategy 3: guarded keypress typing
    for i = 1, #text do
        if UserInputService:GetFocusedTextBox() ~= tb then
            ensureTargetFocus(tb)
        end
        local ch = string.sub(text, i, i)
        local isUpper = ch:match("[A-Z]") ~= nil
        local lower = string.lower(ch)
        local SHIFTED = {
            [":"] = Enum.KeyCode.Semicolon,
            ["_"] = Enum.KeyCode.Minus,
            ["+"] = Enum.KeyCode.Equals,
            ["\""] = Enum.KeyCode.Quote,
            ["^"] = Enum.KeyCode.Six
        }
        local base = SHIFTED[ch]
        if isUpper then base = getKeyCodeForChar(lower) end
        if base then
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
            safeWait(0.02)
            tapKey(base)
            safeWait(0.02)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
        else
            local kc = getKeyCodeForChar(ch)
            if kc then tapKey(kc) end
        end
        safeWait(math.random(math.floor(Config.CHAR_DELAY_MIN*1000), math.floor(Config.CHAR_DELAY_MAX*1000))/1000)
    end
    safeWait(Config.POST_TYPE_WAIT)
    local ok3 = verifyInputInTarget(tb, text)
    suppressConflicts(false)
    return ok3
end

local function pressEnter()
    tapKey(Enum.KeyCode.Return)
    safeWait(0.06)
    -- Fallback for keyboards where KeypadEnter is distinct
    local ok, keypad = pcall(function() return Enum.KeyCode.KeypadEnter end)
    if ok and keypad then tapKey(keypad) end
end

local function toggleCommandBar()
    -- Build the ordered list of keys to try
    local keys = {}
    if Config.COMMAND_TOGGLE_KEYCODE then table.insert(keys, Config.COMMAND_TOGGLE_KEYCODE) end
    for _, m in ipairs(Config.COMMAND_TOGGLE_FALLBACKS or {}) do
        local kc
        if type(m) == "string" then
            kc = optKey(m)
        else
            kc = m
        end
        if kc then table.insert(keys, kc) end
    end
    -- Try each key once, waiting for focus after each
    for _, key in ipairs(keys) do
        tapKey(key)
        safeWait(Config.POST_TOGGLE_WAIT)
        if UserInputService:GetFocusedTextBox() then return true end
    end
    return UserInputService:GetFocusedTextBox() ~= nil
end

local function ensureCommandBarFocused()
    -- Attempt limited toggles with timed wait for focus, avoiding rapid re-toggles
    hideDevConsole()
    if focusCommandTextBox() then return true end
    for attempt = 1, (Config.COMMAND_TOGGLE_ATTEMPTS or 3) do
        if UserInputService:GetFocusedTextBox() then return true end
        toggleCommandBar()
        local deadline = tick() + (Config.COMMAND_BAR_FOCUS_TIMEOUT or 0.6) + (attempt-1)*0.1
        while tick() < deadline do
            if UserInputService:GetFocusedTextBox() then return true end
            safeWait(0.05)
        end
        if focusCommandTextBox() then return true end
    end
    -- Some IY bars are not TextBox-backed; proceed optimistically
    return true
end

-- Build lowercase whitelist sets for robust matching
local OWNER_SET, MOD_SET = {}, {}
for _, n in pairs(OWNER_WHITELIST) do OWNER_SET[normalizeForCompare(n)] = true end
for _, n in pairs(MOD_WHITELIST) do MOD_SET[normalizeForCompare(n)] = true end

local function isWhitelisted(username)
    if not username then return false end
    local n = normalizeForCompare(username)
    return OWNER_SET[n] or MOD_SET[n] or false
end

local function isNewAccount(player)
    if not player or player.AccountAge == nil then return false end
    return player.AccountAge <= Config.NEW_ACCOUNT_THRESHOLD
end

-- ========================================
-- ADMIN COMMAND EXECUTION (human-like typing)
-- ========================================

local function executeCommand(command)
    for attempt = 1, Config.RETRY_LIMIT do
        local ok, err = pcall(function()
            ensureLooplistFile()
            hideDevConsole()
            -- Find and focus the intended command bar
            local target = findCommandTextBox()
            if not target then
                ensureCommandBarFocused()
                target = findCommandTextBox()
            end
            if not target then
                error("Target command bar not found")
            end
            local detachDbg = attachInputDebug(target)
            pcall(function() target:CaptureFocus() end)
            local typedOk = typeIntoTarget(target, command)
            if not typedOk then error("Input verification failed; refusing to submit") end
            showVisualConfirm(target, command)
            pressEnter()
            safeWait(0.05)
            pcall(function() target:ReleaseFocus() end)
            safeWait(Config.POST_ENTER_WAIT)
            detachDbg()
        end)
        if ok then
            print("[SUCCESS] Command executed:", command)
            return true
        else
            print("[WARN] Command attempt", attempt, "failed:", err)
            safeWait(0.35)
        end
    end
    print("[ERROR] Command execution failed after retries:", command)
    return false
end

local function executeAdminAction(action, playerName)
    if not playerName or playerName == "" then return false end
    if isWhitelisted(playerName) then
        print("[INFO] Skipping action for whitelisted:", playerName)
        return false
    end
    local cmd
    if action == "loopkill" then
        cmd = "loopkill "..playerName
    elseif action == "loopfling" then
        -- Per requirement: loopfling refers to loopgoto
        cmd = "loopgoto "..playerName
    elseif action == "singlekill" then
        cmd = "kill "..playerName
    else
        return false
    end
    local ok = executeCommand(cmd)
    if ok then addToLooplist(action, playerName) end
    return ok
end

local function stopPlayerLoop(player)
    if not player then return end
    local name = player.Name
    State.stoppedPlayers[name] = true
    executeCommand("unloopkill "..name)
    executeCommand("unloopgoto "..name)
    removeFromLooplist(name)
    print("[INFO] Stopped loops for", name)
end

-- Legacy getKeyCodeForChar removed to avoid invalid Enum members.
-- Use the validated KEYMAP and getKeyCodeForChar defined above.

-- ========================================
-- We do NOT scan or look for admin GUI per your instructions.
-- Instead, we only toggle the command bar and type via keypress/text.

-- ========================================
-- Already replaced by the human-like executor above

-- ========================================
-- ========================================
-- PLAYER MANAGEMENT AND DETECTION
-- ========================================

local function shouldProcessPlayer(player)
    if not player then return false end
    if player == LocalPlayer then return false end
    if isWhitelisted(player.Name) then return false end
    if State.stoppedPlayers[player.Name] then return false end
    if State.processedPlayers[player.Name] then return false end
    return isNewAccount(player)
end

local function runJoinSequence()
    if State.seqRan or not Config.SEQUENCE_ON_JOIN then return end
    -- Build comma-separated @name list from external file
    ensureLooplistFile()
    local names = readExternalLoopNames() -- returns plain names (no @)
    local atList = ""
    if names and #names > 0 then
        local tmp = {}
        for _, n in ipairs(names) do
            if not isWhitelisted(n) then
                table.insert(tmp, "@"..n)
            end
        end
        atList = table.concat(tmp, ",")
    end

    local seq = {
        "inf^5^tppos 0 -1000000 0",
        "spawn",
    }
    if atList ~= "" then table.insert(seq, "inf^0.1^loopkill "..atList) end
    table.insert(seq, "inf^2^walkfling")
    if atList ~= "" then
        table.insert(seq, "inf^0.1^loopgoto "..atList.." 0")
    else
        table.insert(seq, "inf^0.1^loopgoto 0")
    end
    table.insert(seq, "instarespawn")
    table.insert(seq, "novoid")

    for _, cmd in ipairs(seq) do
        executeCommand(cmd)
        safeWait(Config.COMMAND_DELAY)
    end
    State.seqRan = true
end

local function checkSoloAndHop()
    safeWait(Config.SERVER_HOP_CHECK_DELAY)
    local count = #Players:GetPlayers()
    if count <= 1 then
        print("[INFO] Solo detected; initiating server hop...")
        pcall(function()
            TeleportService:Teleport(Config.PLACE_ID, LocalPlayer)
        end)
    end
end

-- Robust position helpers to eliminate false negatives in distance checks
local function getRootPosition(character)
    if not character then return nil end
    local part = character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
        or character:FindFirstChild("Torso")
        or character:FindFirstChild("Head")
    if part and part.Position then return part.Position end
    return nil
end

local function safeDistanceBetween(charA, charB)
    local a = getRootPosition(charA)
    local b = getRootPosition(charB)
    if a and b then return (a - b).Magnitude end
    return 0
end

local function findNearestNonWhitelistedPlayer(pos)
    if not pos then return nil, math.huge end
    local nearest, best = nil, math.huge
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and not isWhitelisted(p.Name) then
            local cpos = getRootPosition(p.Character)
            if cpos then
                local d = (pos - cpos).Magnitude
                if d < best then
                    best = d
                    nearest = p
                end
            end
        end
    end
    return nearest, best
end

-- Stuck watchdog: detects freeze and auto-recovers
local function startStuckWatchdog()
    if not Config.STUCK_RECOVERY_ENABLED then return end
    local epsilon = Config.STUCK_MOVE_EPSILON or 2.0
    local timeout = Config.STUCK_FREEZE_TIMEOUT or 10
    local lastPos = nil
    local lastMoveAt = tick()
    local recovering = false

    table.insert(State.connections, RunService.Heartbeat:Connect(function()
        local char = LocalPlayer.Character
        local pos = getRootPosition(char)
        if not pos then return end
        if not lastPos then lastPos = pos; lastMoveAt = tick(); return end
        local moved = (pos - lastPos).Magnitude
        if moved >= epsilon then
            lastPos = pos
            lastMoveAt = tick()
            recovering = false
            return
        end
        if (tick() - lastMoveAt) > timeout and not recovering then
            recovering = true
            print("[WARN] Stuck freeze detected; attempting recovery...")
            -- Conservative recovery: respawn + restore movement helpers
            executeCommand("instarespawn")
            safeWait(Config.COMMAND_DELAY)
            executeCommand("novoid")
            safeWait(Config.COMMAND_DELAY)
            executeCommand("inf^2^walkfling")
            -- Reset timers to avoid repeated triggers
            lastMoveAt = tick()
        end
    end))
end

local function handleBotDeath(humanoid)
    local killerPlayer
    local tag = humanoid:FindFirstChild("creator") or humanoid:FindFirstChild("Creator")
    if tag and tag:IsA("ObjectValue") then
        local val = tag.Value
        if val and val:IsA("Player") then
            killerPlayer = val
        elseif val and val:IsA("Model") then
            -- Sometimes stores a character model, get the player by name
            killerPlayer = Players:FindFirstChild(val.Name)
        end
    end
    -- Primary path: creator tag provided a killer
    if killerPlayer and not isWhitelisted(killerPlayer.Name) then
        local dist = safeDistanceBetween(LocalPlayer.Character, killerPlayer.Character)
        local action = Config.ACTION_ON_KILL_BOT
        if dist >= Config.LONG_KILL_DISTANCE then action = Config.ACTION_ON_LONG_DISTANCE end
        print("[DETECTION] Bot killed by", killerPlayer.Name, "distance:", math.floor(dist))
        executeAdminAction(action, killerPlayer.Name)
        return
    end

    -- Fallback A: use last attacker observed during HealthChanged
    if State.lastAttackerName and not isWhitelisted(State.lastAttackerName) then
        local p = Players:FindFirstChild(State.lastAttackerName)
        if p then
            local dist = safeDistanceBetween(LocalPlayer.Character, p.Character)
            local action = Config.ACTION_ON_KILL_BOT
            if dist >= Config.LONG_KILL_DISTANCE then action = Config.ACTION_ON_LONG_DISTANCE end
            print("[DETECTION] Bot killed; fallback attacker", p.Name, "distance:", math.floor(dist))
            executeAdminAction(action, p.Name)
            return
        end
    end

    -- Fallback B: nearest non-whitelisted player at time of death
    local myPos = getRootPosition(LocalPlayer.Character)
    local nearest, dist = findNearestNonWhitelistedPlayer(myPos)
    if nearest then
        if dist >= Config.LONG_KILL_DISTANCE then
            print("[DETECTION] Bot killed; nearest suspect", nearest.Name, "distance:", math.floor(dist))
            executeAdminAction(Config.ACTION_ON_LONG_DISTANCE, nearest.Name)
        else
            print("[INFO] Death without creator; nearest suspect within threshold:", nearest.Name, math.floor(dist))
        end
    end
end

-- Apply protection: if a whitelisted owner/mod dies to a non-whitelisted player, punish the skid
local function handleProtectedDeath(deadPlayer, humanoid)
    if not deadPlayer or not isWhitelisted(deadPlayer.Name) then return end
    local killerPlayer
    local tag = humanoid:FindFirstChild("creator") or humanoid:FindFirstChild("Creator")
    if tag and tag:IsA("ObjectValue") then
        local val = tag.Value
        if val and val:IsA("Player") then
            killerPlayer = val
        elseif val and val:IsA("Model") then
            killerPlayer = Players:FindFirstChild(val.Name)
        end
    end
    if not killerPlayer then
        local pos = getRootPosition(deadPlayer.Character)
        killerPlayer = (findNearestNonWhitelistedPlayer(pos))
    end
    if type(killerPlayer) == "table" then killerPlayer = killerPlayer end -- safeguard when using tuple
    if killerPlayer and not isWhitelisted(killerPlayer.Name) then
        local dist = safeDistanceBetween(deadPlayer.Character, killerPlayer.Character)
        local action = Config.ACTION_ON_KILL_BOT
        if dist >= Config.LONG_KILL_DISTANCE then action = Config.ACTION_ON_LONG_DISTANCE end
        print("[PROTECT] Whitelisted ", deadPlayer.Name, " killed by ", killerPlayer.Name, " distance:", math.floor(dist))
        executeAdminAction(action, killerPlayer.Name)
    end
end

-- Monitor reach (stud) damage for any player. Punish attacker if distance is excessive.
local function monitorReachForPlayer(player)
    if not player or player == LocalPlayer then return end
    local function attach(char)
        if not char then return end
        local humanoid = char:FindFirstChild("Humanoid")
        if not humanoid then return end
        local last = humanoid.Health
        local c = humanoid.HealthChanged:Connect(function(newHealth)
            if last and newHealth and newHealth < last then
                local tag = humanoid:FindFirstChild("creator") or humanoid:FindFirstChild("Creator")
                if tag and tag:IsA("ObjectValue") then
                    local val = tag.Value
                    local attacker
                    if val and val:IsA("Player") then attacker = val
                    elseif val and val:IsA("Model") then attacker = Players:FindFirstChild(val.Name) end
                    if attacker and not isWhitelisted(attacker.Name) then
                        local dist = safeDistanceBetween(player.Character, attacker.Character)
                        if dist >= (Config.LONG_KILL_DISTANCE or 200) then
                            print("[DETECTION] Reach damage on ", player.Name, " from ", attacker.Name, " distance:", math.floor(dist))
                            executeAdminAction(Config.ACTION_ON_LONG_DISTANCE, attacker.Name)
                        end
                    end
                end
            end
            last = newHealth
        end)
        table.insert(State.connections, c)
    end
    if player.Character then attach(player.Character) end
    table.insert(State.connections, player.CharacterAdded:Connect(attach))
end

local function setupCharacterMonitoring(character)
    local humanoid = character:WaitForChild("Humanoid", 10)
    if humanoid then
        local conn = humanoid.Died:Connect(function()
            handleBotDeath(humanoid)
        end)
        table.insert(State.connections, conn)
        -- Real-time attacker trace: record last attacker and distance on damage
        local lastHealth = humanoid.Health
        local hc = humanoid.HealthChanged:Connect(function(newHealth)
            local tag = humanoid:FindFirstChild("creator") or humanoid:FindFirstChild("Creator")
            if tag and tag:IsA("ObjectValue") then
                local val = tag.Value
                local p
                if val and val:IsA("Player") then p = val
                elseif val and val:IsA("Model") then p = Players:FindFirstChild(val.Name) end
                if p and not isWhitelisted(p.Name) then
                    State.lastAttackerName = p.Name
                    State.lastAttackerDist = safeDistanceBetween(LocalPlayer.Character, p.Character)
                    -- Immediate reach punishment when damage occurs from long distance
                    if lastHealth and newHealth and newHealth < lastHealth then
                        if State.lastAttackerDist >= Config.LONG_KILL_DISTANCE then
                            executeAdminAction(Config.ACTION_ON_LONG_DISTANCE, p.Name)
                        end
                    end
                end
            end
            lastHealth = newHealth
        end)
        table.insert(State.connections, hc)
    end
end

local function processNewPlayer(player)
    if shouldProcessPlayer(player) then
        print("[DETECTION] New account:", player.Name, "Age:", player.AccountAge)
        State.processedPlayers[player.Name] = true
        executeAdminAction(Config.ACTION_ON_NEW_ACCOUNT, player.Name)
        safeWait(Config.COMMAND_DELAY)
    end
end

-- Sentinel chat commands for owners/mods
local function handleSentinelCommand(sender, text)
    if not sender or not isWhitelisted(sender.Name) or type(text) ~= "string" then return false end
    local raw = text
    local lower = string.lower(raw)
    local function extractUser(pattern)
        local name = raw:match(pattern)
        if not name then return nil end
        name = name:gsub("^@", "")
        name = name:gsub(",%s*$", "")
        return name
    end
    local uname
    if lower:match("^%s*sentinel%s+temploop") then
        uname = extractUser("sentinel%s+temploop%s+@?([%w_]+),?%s*$")
        if not uname then return false end
        local at = "@"..uname
        executeCommand("inf^0.1^loopkill "..at)
        safeWait(Config.COMMAND_DELAY)
        executeCommand("inf^0.1^loopgoto "..at.." 0")
        return true
    elseif lower:match("^%s*sentinel%s+loop") then
        uname = extractUser("sentinel%s+loop%s+@?([%w_]+),?%s*$")
        if not uname then return false end
        local at = "@"..uname
        executeCommand("inf^0.1^loopkill "..at)
        safeWait(Config.COMMAND_DELAY)
        executeCommand("inf^0.1^loopgoto "..at.." 0")
        if hasFilesystem() then
            addNameToExternalLooplist(uname)
        else
            print("[WARN] Filesystem unavailable; cannot persist to external looplist.")
        end
        return true
    elseif lower:match("^%s*sentinel%s+unloop") then
        uname = extractUser("sentinel%s+unloop%s+@?([%w_]+),?%s*$")
        if not uname then return false end
        executeCommand("break")
        safeWait(Config.COMMAND_DELAY)
        executeCommand("unloopkill all")
        safeWait(Config.COMMAND_DELAY)
        executeCommand("unloopgoto all")
        if hasFilesystem() then
            removeNameFromExternalLooplist(uname)
        else
            print("[WARN] Filesystem unavailable; cannot remove from external looplist.")
        end
        local path = resolveExternalPath()
        executeCommand("inf^5^tppos 0 -1000000 0")
        safeWait(Config.COMMAND_DELAY)
        executeCommand("inf^0.1^loopkill "..path)
        safeWait(Config.COMMAND_DELAY)
        executeCommand("inf^2^walkfling")
        safeWait(Config.COMMAND_DELAY)
        executeCommand("inf^0.1^loopgoto "..path.." 0")
        return true
    end
    return false
end

local function setupPlayerEvents()
    print("[INFO] Setting up player monitoring...")
    for _, p in ipairs(Players:GetPlayers()) do
        processNewPlayer(p)
        -- Reach detection for regular players
        monitorReachForPlayer(p)
        -- Protection for whitelisted players
        if isWhitelisted(p.Name) then
            local function hook(char)
                local humanoid = char:FindFirstChild("Humanoid")
                if humanoid then
                    local c = humanoid.Died:Connect(function()
                        handleProtectedDeath(p, humanoid)
                    end)
                    table.insert(State.connections, c)
                end
            end
            if p.Character then hook(p.Character) end
            table.insert(State.connections, p.CharacterAdded:Connect(hook))
        end
    end
    table.insert(State.connections, Players.PlayerAdded:Connect(function(p)
        safeWait(1)
        processNewPlayer(p)
        monitorReachForPlayer(p)
        if isWhitelisted(p.Name) then
            local function hook(char)
                local humanoid = char:FindFirstChild("Humanoid")
                if humanoid then
                    local c = humanoid.Died:Connect(function()
                        handleProtectedDeath(p, humanoid)
                    end)
                    table.insert(State.connections, c)
                end
            end
            if p.Character then hook(p.Character) end
            table.insert(State.connections, p.CharacterAdded:Connect(hook))
        end
    end))
end

local function setupChatMonitoring()
    print("[INFO] Setting up chat monitoring...")
    local ok = pcall(function()
        TextChatService.MessageReceived:Connect(function(message)
            if message.TextSource and message.TextSource.UserId then
                local p = Players:GetPlayerByUserId(message.TextSource.UserId)
                if p then
                    local txt = message.Text or ""
                    if txt == Config.STOP_KEYWORD then
                        stopPlayerLoop(p)
                    else
                        handleSentinelCommand(p, txt)
                    end
                end
            end
        end)
    end)
    if not ok then
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= LocalPlayer then
                p.Chatted:Connect(function(msg)
                    if msg == Config.STOP_KEYWORD then
                        stopPlayerLoop(p)
                    else
                        handleSentinelCommand(p, msg)
                    end
                end)
            end
        end
        Players.PlayerAdded:Connect(function(p)
            p.Chatted:Connect(function(msg)
                if msg == Config.STOP_KEYWORD then
                    stopPlayerLoop(p)
                else
                    handleSentinelCommand(p, msg)
                end
            end)
        end)
    end
end

local function initializeBot()
    print("[INFO] Initializing Security Bot...")
    State.botActive = true
    ensureLooplistFile()
    runJoinSequence()
    State.initialSetupComplete = true
    detectTextInputSupport()
    setupChatMonitoring()
    setupPlayerEvents()
    if LocalPlayer.Character then
        setupCharacterMonitoring(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(function(char)
        setupCharacterMonitoring(char)
    end)
    print("[SUCCESS] Security Bot v4.0 initialized!")
    print("[INFO] Monitoring new accounts (Age ≤", Config.NEW_ACCOUNT_THRESHOLD, "days)")
    task.spawn(checkSoloAndHop)
    startStuckWatchdog()
    return true
end

-- ========================================
-- STARTUP
-- ========================================

-- Initialize the bot
local initSuccess = initializeBot()

if initSuccess then
    print("[SUCCESS] SFOTHO Security Bot v4.0 is active!")
    print("[INFO] Stop keyword:", Config.STOP_KEYWORD)
else
    print("[ERROR] Failed to initialize Security Bot")
end
-- Simple XOR + Base64 obfuscation (optional) for persistent JSON
local function kdf()
    local seed = tostring(LocalPlayer.UserId).."-"..tostring(Config.ENCRYPTION_KEY_SEED or "")
    return seed
end
local function xorBytes(str, key)
    local out = table.create(#str)
    local klen = #key
    for i = 1, #str do
        local sb = string.byte(str, i)
        local kb = string.byte(key, ((i - 1) % klen) + 1)
        out[i] = string.char(bit32.bxor(sb, kb))
    end
    return table.concat(out)
end
local function encodeData(tbl)
    local ok, json = pcall(function() return HttpService:JSONEncode(tbl) end)
    if not ok then return nil end
    if Config.ENCRYPT_STORAGE then
        local obf = xorBytes(json, kdf())
        return (game:GetService("HttpService"):Base64Encode(obf))
    end
    return json
end
local function decodeData(str)
    if not str or str == "" then return nil end
    local raw = str
    if Config.ENCRYPT_STORAGE then
        local okb, dec = pcall(function() return HttpService:Base64Decode(raw) end)
        if not okb then return nil end
        raw = xorBytes(dec, kdf())
    end
    local ok, tbl = pcall(function() return HttpService:JSONDecode(raw) end)
    if ok then return tbl end
    return nil
end

-- Persistent storage for looped users
Persistent = { entries = {}, loaded = false }

function Persistent.load()
    if not hasFilesystem() then Persistent.loaded = true; return true end
    local folder = Config.PERSIST_DATA_FOLDER
    if type(isfolder) == "function" and not isfolder(folder) then pcall(function() makefolder(folder) end) end
    local path = Config.PERSIST_JSON_PATH
    local ok, data = pcall(function() return readfile(path) end)
    if not ok or not data or data == "" then Persistent.loaded = true; return true end
    local decoded = decodeData(data)
    if type(decoded) == "table" and decoded.entries then
        Persistent.entries = decoded.entries
        Persistent.loaded = true
        return true
    end
    Persistent.loaded = true
    return true
end

function Persistent.save()
    if not hasFilesystem() then return false end
    local blob = { entries = Persistent.entries }
    local payload = encodeData(blob)
    if not payload then return false end
    local ok = pcall(function() writefile(Config.PERSIST_JSON_PATH, payload) end)
    if not ok then print("[WARN] Persistent save failed") end
    return ok
end

function Persistent.add(name, kind, ttl_sec, source)
    local n = normalizeForCompare(name)
    if n == "" or isWhitelisted(name) then return false end
    local now = tick()
    Persistent.entries[n] = {
        username = name:gsub("^@", ""),
        kind = kind or "permanent",
        added_at = now,
        ttl_sec = tonumber(ttl_sec) or 0,
        active = true,
        source = source or "manual",
        last_applied = 0
    }
    Persistent.save()
    return true
end

function Persistent.remove(name)
    local n = normalizeForCompare(name)
    if Persistent.entries[n] then
        Persistent.entries[n] = nil
        Persistent.save()
    end
end

function Persistent.isActive(name)
    local n = normalizeForCompare(name)
    local e = Persistent.entries[n]
    if not e or not e.active then return false end
    if e.ttl_sec and e.ttl_sec > 0 then
        return (tick() - e.added_at) <= e.ttl_sec
    end
    return true
end

function Persistent.getActiveNames(permanentOnly)
    local out = {}
    for _, e in pairs(Persistent.entries) do
        if e.active and (not permanentOnly or e.kind == "permanent") then
            if Persistent.isActive(e.username) then table.insert(out, e.username) end
        end
    end
    table.sort(out)
    return out
end

function Persistent.pruneExpired()
    local changed = false
    for k, e in pairs(Persistent.entries) do
        if e.active and e.ttl_sec and e.ttl_sec > 0 then
            if (tick() - e.added_at) > e.ttl_sec then
                changed = true
                Persistent.entries[k] = nil
            end
        end
    end
    if changed then Persistent.save() end
end

function Persistent.export()
    return encodeData({ entries = Persistent.entries })
end

function Persistent.import(payload)
    local decoded = decodeData(payload)
    if type(decoded) == "table" and decoded.entries then
        Persistent.entries = decoded.entries
        Persistent.save()
        return true
    end
    return false
end
