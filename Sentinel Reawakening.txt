-- Global Variables and Constants for Sentinel AI

-- Whitelist
local OWNERS = {
    "HollowGol",
}

local MODS = {
    "STEVETheReal916",
    "ColonThreeSpam",
    "SpawnYellow2",
    "SpawnBlack1",
    "s71pl",
    "Jacobthecool292",
    "babyyodasonglol",
    "forhelpingboi8",
    "Kandale_Dingul",
    "redalert_E",
    "fariahoque28",
    "baze15651",
    "well_ihateboblux",
    "0bj687Alt",
}

-- Looplist (will be loaded from JSON)
local Looplist = {}

-- Other configurations
local INITIAL_WAIT_TIME = 7.5 -- seconds
local GRACE_PERIOD_TIME = 5 -- seconds
local GracePeriodActive = true -- New global variable
local RecentKills = {}
local COMMAND_COOLDOWN = 0.1 -- seconds (brief cooldown for keypresses)
local LOOP_KILL_DISTANCE = 24 -- studs
local KILL_DISTANCE = 15 -- studs
local MULTI_KILL_DISTANCE = 25 -- studs
local MULTI_KILL_WINDOW = 0.25 -- seconds
local FLING_VELOCITY_THRESHOLD = 100 -- Adjust as needed
local UNLOOP_PHRASE = "Qpmbsjbvt"

-- Infinite Yield command key
local COMMAND_KEY = "ÅŸ"

-- Looplist file name
local LOOPLIST_FILE_NAME = "Looplist.json"

-- Function to send a command to Infinite Yield Admin
local function send_command(command_string)
    -- This is a placeholder. Actual implementation will depend on the executor's API.
    -- It should simulate pressing the COMMAND_KEY, typing the command_string, and then pressing ENTER.
    -- For now, we'll just print the command and wait for the cooldown.
    print("Sending command: " .. command_string)
    -- Simulate keypress for COMMAND_KEY
    -- Simulate typing command_string
    -- Simulate keypress for ENTER
    wait(COMMAND_COOLDOWN)
end

-- Function to save the looplist to a JSON file
local function save_looplist()
    local json_data = game:GetService("HttpService"):JSONEncode(Looplist)
    -- This is a placeholder for writing to a file.
    -- In a real executor, you would use its file writing API.
    -- For example: writefile(LOOPLIST_FILE_NAME, json_data)
    print("Saving looplist to " .. LOOPLIST_FILE_NAME .. ": " .. json_data)
end

-- Function to load the looplist from a JSON file
local function load_looplist()
    local success, json_data = pcall(function()
        -- This is a placeholder for reading from a file.
        -- In a real executor, you would use its file reading API.
        -- For example: return readfile(LOOPLIST_FILE_NAME)
        return "" -- Simulate empty file for now
    end)

    if success and json_data and json_data ~= "" then
        local decoded_data = game:GetService("HttpService"):JSONDecode(json_data)
        if type(decoded_data) == "table" then
            Looplist = decoded_data
            print("Loaded looplist from " .. LOOPLIST_FILE_NAME)
        else
            print("Error: Decoded looplist data is not a table. Initializing empty looplist.")
            Looplist = {}
        end
    else
        print("No existing looplist found or error reading file. Initializing empty looplist.")
        Looplist = {}
    end
end

-- Function to add a username to the looplist
local function add_to_looplist(username)
    if not table.find(Looplist, username) then
        table.insert(Looplist, username)
        save_looplist()
        print(username .. " added to looplist.")
    end
end

-- Function to remove a username from the looplist
local function remove_from_looplist(username)
    for i, v in ipairs(Looplist) do
        if v == username then
            table.remove(Looplist, i)
            save_looplist()
            print(username .. " removed from looplist.")
            return
        end
    end
end

-- Helper function to check if a player is whitelisted
local function is_whitelisted(username)
    for _, owner_name in ipairs(OWNERS) do
        if owner_name == username then
            return true
        end
    end
    for _, mod_name in ipairs(MODS) do
        if mod_name == username then
            return true
        end
    end
    return false
end

-- Function to calculate distance between two characters
local function get_distance_between_characters(char1, char2)
    if char1 and char1.PrimaryPart and char2 and char2.PrimaryPart then
        return (char1.PrimaryPart.Position - char2.PrimaryPart.Position).magnitude
    end
    return math.huge -- Return a very large number if characters or primary parts are not found
end

-- Automated kill detection (15+ studs)
local function handle_kill_detection(killer_username, victim_username, distance)
    if is_whitelisted(killer_username) or is_whitelisted(victim_username) then
        return -- Ignore whitelisted players
    end

    if distance >= KILL_DISTANCE then
        print(killer_username .. " killed " .. victim_username .. " from " .. math.floor(distance) .. " studs. Applying kill command.")
        send_command("kill @" .. killer_username)
    end

    -- Automated looping detection (24+ studs after grace period)
    if not GracePeriodActive and distance >= LOOP_KILL_DISTANCE then
        print(killer_username .. " killed " .. victim_username .. " from " .. math.floor(distance) .. " studs after grace period. Looping them.")
        add_to_looplist(killer_username)
        send_command("inf^0.1^loopkill @" .. killer_username)
        send_command("inf^0.1^loopgoto @" .. killer_username .. " 0")
    end
end

-- Placeholder for hooking into kill events
-- This would typically involve monitoring player health changes or specific game events
-- For example, if there's a 'PlayerDied' event, you'd connect to it and get killer/victim info.
-- game:GetService("Players").PlayerAdded:Connect(function(player)
--     player.CharacterAdded:Connect(function(character)
--         local humanoid = character:WaitForChild("Humanoid")
--         humanoid.Died:Connect(function()
--             -- Logic to determine killer and victim, and their positions
--             local killer = -- get killer player object
--             local victim = player
--             if killer and victim then
--                 local killer_char = killer.Character
--                 local victim_char = victim.Character
--                 local dist = get_distance_between_characters(killer_char, victim_char)
--                 handle_kill_detection(killer.Name, victim.Name, dist)
--             end
--         end)
--     end)
-- end
end

-- Function to get a player's account age in days
local function get_account_age_in_days(player)
    if player and player.AccountAge then
        return player.AccountAge
    end
    return math.huge -- Return a very large number if player or AccountAge is not found
end

-- Automated looping detection based on account age (1 day old)
local function handle_account_age_detection(player)
    if is_whitelisted(player.Name) then
        return -- Ignore whitelisted players
    end

    local account_age = get_account_age_in_days(player)
    if account_age <= 1 then
        print(player.Name .. " has an account age of " .. account_age .. " days. Looping them.")
        add_to_looplist(player.Name)
        send_command("inf^0.1^loopkill @" .. player.Name)
        send_command("inf^0.1^loopgoto @" .. player.Name .. " 0")
    end
end

-- Placeholder for hooking into player added events to check account age
-- game:GetService("Players").PlayerAdded:Connect(function(player)
--     handle_account_age_detection(player)
-- end
end

-- Automated unlooping based on chat phrase
local function handle_chat_unloop(player_name, message)
    if message == UNLOOP_PHRASE then
        print(player_name .. " chatted the unloop phrase. Temporarily unlooping them.")
        remove_from_looplist(player_name)
        send_command("break")
        send_command("unloopgoto all")
        send_command("unloopkill all")
        send_command("inf^5^tppos 0 -1000000 0")
        send_command("inf^0.1^loopkill [looplist]")
        send_command("inf^2^walkfling")
        send_command("inf^0.1^loopgoto [looplist] 0")
    end
end

-- Automated detection for looping based on multiple kills
local function handle_multiple_kills_detection(killer_name, victim_name, kill_distance)
    if is_whitelisted(killer_name) then
        return -- Ignore whitelisted players
    end

    if kill_distance >= 25 then
        if not RecentKills[killer_name] then
            RecentKills[killer_name] = {}
        end

        table.insert(RecentKills[killer_name], os.time())

        -- Remove kills older than 0.25 seconds
        for i = #RecentKills[killer_name], 1, -1 do
            if os.time() - RecentKills[killer_name][i] > 0.25 then
                table.remove(RecentKills[killer_name], i)
            end
        end

        if #RecentKills[killer_name] >= 2 then
            print(killer_name .. " has multiple kills from 25+ studs within 0.25 seconds. Looping them.")
            add_to_looplist(killer_name)
            send_command("inf^0.1^loopkill @" .. killer_name)
            send_command("inf^0.1^loopgoto @" .. killer_name .. " 0")
            RecentKills[killer_name] = {} -- Reset their kill count after looping
        end
    end
end

-- Placeholder for hooking into kill events to check for multiple kills
-- game:GetService("Players").PlayerAdded:Connect(function(player)
--     player.CharacterAdded:Connect(function(character)
--         character.Humanoid.Died:Connect(function()
--             local killer = character.Humanoid:FindFirstChildOfClass("ObjectValue") -- Assuming killer is stored here
--             if killer and killer.Value then
--                 local killer_char = killer.Value.Character
--                 if killer_char then
--                     local distance = get_distance_between_characters(killer_char, character)
--                     handle_multiple_kills_detection(killer.Value.Name, player.Name, distance)
--                 end
--             end
--         end)
--     end
    end
end

-- Automated detection for kills based on fling attempts
local function handle_fling_detection(player_character)
    if not player_character or not player_character:FindFirstChildOfClass("HumanoidRootPart") then
        return
    end

    local player_name = player_character.Parent.Name
    if is_whitelisted(player_name) then
        return -- Ignore whitelisted players
    end

    local humanoid_root_part = player_character:FindFirstChildOfClass("HumanoidRootPart")
    if humanoid_root_part then
        local velocity = humanoid_root_part.Velocity.Magnitude
        if velocity > FLING_VELOCITY_THRESHOLD then
            print(player_name .. " detected attempting to fling (velocity: " .. velocity .. "). Killing them.")
            send_command("kill @" .. player_name)
        end
    end
end

-- Placeholder for continuously monitoring player velocities for fling detection
-- game:GetService("Players").PlayerAdded:Connect(function(player)
--     player.CharacterAdded:Connect(function(character)
--         -- You would typically use a loop or a RunService.Heartbeat connection here
--         -- to continuously check character.HumanoidRootPart.Velocity.Magnitude
--         -- For example:
--         -- local connection
--         -- connection = game:GetService("RunService").Heartbeat:Connect(function()
--         --     if character and character:FindFirstChildOfClass("HumanoidRootPart") then
--         --         handle_fling_detection(character)
--         --     else
--         --         connection:Disconnect()
--         --     end
--         -- end)
--     end)
-- end
end

-- Chat command parsing and execution
local function handle_chat_commands(player_name, message)
    local args = {}
    for word in string.gmatch(message, "%S+") do
        table.insert(args, word)
    end

    if #args == 0 then return end

    local command_prefix = args[1]:lower()
    if command_prefix ~= "sentinel" then return end

    if not is_whitelisted(player_name) then
        print(player_name .. " attempted to use a Sentinel command but is not whitelisted.")
        return
    end

    local sub_command = args[2]:lower()
    local target_username = args[3]

    if sub_command == "temploop" then
        if target_username then
            -- Check if the target is whitelisted
            if is_whitelisted(target_username) then
                print("Cannot temploop a whitelisted player: " .. target_username)
                return
            end
            print(player_name .. " temporarily looping " .. target_username)
            send_command("inf^0.1^loopkill @" .. target_username)
            send_command("inf^0.1^loopgoto @" .. target_username .. " 0")
            -- Note: Temploop does not add to the persistent looplist
        else
            print("Usage: sentinel temploop @Username")
        end
    elseif sub_command == "jump" then
        if target_username then
            if is_whitelisted(target_username) then
                print("Cannot jump-loop a whitelisted player: " .. target_username)
                return
            end
            print(player_name .. " jump-looping and adding to looplist: " .. target_username)
            add_to_looplist(target_username)
            send_command("inf^0.1^loopkill @" .. target_username)
            send_command("inf^0.1^loopgoto @" .. target_username .. " 0")
        else
            print("Usage: sentinel jump @Username")
        end
    elseif sub_command == "unloop" then
        if target_username then
            if is_whitelisted(target_username) then
                print("Cannot unloop a whitelisted player: " .. target_username)
                return
            end
            print(player_name .. " unlooping and removing from looplist: " .. target_username)
            remove_from_looplist(target_username)
            send_command("unloopkill @" .. target_username)
            send_command("unloopgoto @" .. target_username)
        else
            print("Usage: sentinel unloop @Username")
        end
    elseif sub_command == "shop" then
        print(player_name .. " initiated a manual server hop.")
        server_hop()
    else
        print("Unknown Sentinel command: " .. sub_command)
    end
end

-- Placeholder for hooking into chat events
-- game:GetService("Players").PlayerAdded:Connect(function(player)
--     player.Chatted:Connect(function(message)
--         handle_chat_commands(player.Name, message)
--     end)
-- end
end

-- Server hopping logic
local function should_server_hop()
    local players = game:GetService("Players"):GetPlayers()
    local non_whitelisted_players = 0

    for _, player in ipairs(players) do
        if player.Name ~= game:GetService("Players").LocalPlayer.Name and not is_whitelisted(player.Name) then
            non_whitelisted_players = non_whitelisted_players + 1
        end
    end

    -- If there are no other players (excluding self and whitelisted players), server hop
    return non_whitelisted_players == 0
end

local function server_hop()
    print("Initiating server hop...")
    -- Placeholder for actual server hopping using TeleportService
    -- game:GetService("TeleportService"):Teleport(game.PlaceId)
end
end

-- Looplist GUI Implementation
local function create_looplist_gui()
    local player = game:GetService("Players").LocalPlayer
    local player_gui = player:WaitForChild("PlayerGui")

    local screen_gui = Instance.new("ScreenGui")
    screen_gui.Name = "LooplistScreenGui"
    screen_gui.Parent = player_gui

    local main_frame = Instance.new("Frame")
    main_frame.Name = "LooplistFrame"
    main_frame.Size = UDim2.new(0, 300, 0, 400)
    main_frame.Position = UDim2.new(0.5, -150, 0.5, -200) -- Center of the screen
    main_frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    main_frame.BorderSizePixel = 1
    main_frame.BorderColor3 = Color3.fromRGB(20, 20, 20)
    main_frame.Active = true -- Essential for dragging
    main_frame.Draggable = true -- Make the frame draggable
    main_frame.Parent = screen_gui

    local title_bar = Instance.new("Frame")
    title_bar.Name = "TitleBar"
    title_bar.Size = UDim2.new(1, 0, 0, 30)
    title_bar.Position = UDim2.new(0, 0, 0, 0)
    title_bar.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    title_bar.BorderSizePixel = 0
    title_bar.Parent = main_frame

    local title_label = Instance.new("TextLabel")
    title_label.Name = "TitleLabel"
    title_label.Size = UDim2.new(1, -40, 1, 0)
    title_label.Position = UDim2.new(0, 0, 0, 0)
    title_label.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    title_label.Text = "Sentinel Looplist"
    title_label.TextColor3 = Color3.fromRGB(255, 255, 255)
    title_label.Font = Enum.Font.SourceSansBold
    title_label.TextSize = 18
    title_label.TextXAlignment = Enum.TextXAlignment.Center
    title_label.TextYAlignment = Enum.TextYAlignment.Center
    title_label.BorderSizePixel = 0
    title_label.Parent = title_bar

    local minimize_button = Instance.new("TextButton")
    minimize_button.Name = "MinimizeButton"
    minimize_button.Size = UDim2.new(0, 30, 1, 0)
    minimize_button.Position = UDim2.new(1, -30, 0, 0)
    minimize_button.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    minimize_button.Text = "_"
    minimize_button.TextColor3 = Color3.fromRGB(255, 255, 255)
    minimize_button.Font = Enum.Font.SourceSansBold
    minimize_button.TextSize = 20
    minimize_button.BorderSizePixel = 0
    minimize_button.Parent = title_bar

    minimize_button.MouseButton1Click:Connect(function()
        main_frame.Visible = not main_frame.Visible
    end)

    -- Search bar
    local search_bar = Instance.new("TextBox")
    search_bar.Name = "SearchBar"
    search_bar.Size = UDim2.new(1, -20, 0, 25)
    search_bar.Position = UDim2.new(0, 10, 0, 40)
    search_bar.PlaceholderText = "Search looplist..."
    search_bar.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    search_bar.TextColor3 = Color3.fromRGB(255, 255, 255)
    search_bar.Font = Enum.Font.SourceSans
    search_bar.TextSize = 14
    search_bar.ClearTextOnFocus = false
    search_bar.Parent = main_frame

    -- Scrolling frame for looplist items
    local looplist_scrolling_frame = Instance.new("ScrollingFrame")
    looplist_scrolling_frame.Name = "LooplistScrollingFrame"
    looplist_scrolling_frame.Size = UDim2.new(1, -20, 1, -80)
    looplist_scrolling_frame.Position = UDim2.new(0, 10, 0, 75)
    looplist_scrolling_frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    looplist_scrolling_frame.BorderSizePixel = 1
    looplist_scrolling_frame.BorderColor3 = Color3.fromRGB(20, 20, 20)
    looplist_scrolling_frame.CanvasSize = UDim2.new(0, 0, 0, 0) -- Will be updated dynamically
    looplist_scrolling_frame.ScrollBarThickness = 8
    looplist_scrolling_frame.Parent = main_frame

    local ui_list_layout = Instance.new("UIListLayout")
    ui_list_layout.Name = "LooplistLayout"
    ui_list_layout.FillDirection = Enum.FillDirection.Vertical
    ui_list_layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    ui_list_layout.VerticalAlignment = Enum.VerticalAlignment.Top
    ui_list_layout.Padding = UDim.new(0, 5)
    ui_list_layout.Parent = looplist_scrolling_frame

    -- Function to update the displayed looplist items
    local function update_looplist_display(filter_text)
        for _, child in ipairs(looplist_scrolling_frame:GetChildren()) do
            if child:IsA("TextLabel") or child:IsA("Frame") then
                child:Destroy()
            end
        end

        local current_y_offset = 0
        local item_height = 25

        for _, username in ipairs(Looplist) do
            if filter_text == "" or string.find(username:lower(), filter_text:lower()) then
                local item_frame = Instance.new("Frame")
                item_frame.Name = username .. "_Item"
                item_frame.Size = UDim2.new(1, 0, 0, item_height)
                item_frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                item_frame.BorderSizePixel = 0
                item_frame.Parent = looplist_scrolling_frame

                local username_label = Instance.new("TextLabel")
                username_label.Name = "UsernameLabel"
                username_label.Size = UDim2.new(1, -60, 1, 0)
                username_label.Position = UDim2.new(0, 0, 0, 0)
                username_label.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                username_label.Text = username
                username_label.TextColor3 = Color3.fromRGB(255, 255, 255)
                username_label.Font = Enum.Font.SourceSans
                username_label.TextSize = 16
                username_label.TextXAlignment = Enum.TextXAlignment.Left
                username_label.TextYAlignment = Enum.TextYAlignment.Center
                username_label.TextWrapped = true
                username_label.BorderSizePixel = 0
                username_label.Parent = item_frame

                local unloop_button = Instance.new("TextButton")
                unloop_button.Name = "UnloopButton"
                unloop_button.Size = UDim2.new(0, 50, 1, 0)
                unloop_button.Position = UDim2.new(1, -50, 0, 0)
                unloop_button.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
                unloop_button.Text = "Unloop"
                unloop_button.TextColor3 = Color3.fromRGB(255, 255, 255)
                unloop_button.Font = Enum.Font.SourceSansBold
                unloop_button.TextSize = 14
                unloop_button.BorderSizePixel = 0
                unloop_button.Parent = item_frame

                unloop_button.MouseButton1Click:Connect(function()
                    remove_from_looplist(username)
                    send_command("unloopkill @" .. username)
                    send_command("unloopgoto @" .. username)
                    update_looplist_display(search_bar.Text)
                end)

                current_y_offset = current_y_offset + item_height + ui_list_layout.Padding.Offset
            end
        end
        looplist_scrolling_frame.CanvasSize = UDim2.new(0, 0, 0, current_y_offset)
    end

    search_bar.Changed:Connect(function(property)
        if property == "Text" then
            update_looplist_display(search_bar.Text)
        end
    end)

    -- Initial display update
    update_looplist_display("")

    -- Connect looplist changes to GUI update
    -- (This assumes add_to_looplist and remove_from_looplist will trigger an event or can be modified to do so)
    -- For now, we'll just call update_looplist_display after any change to Looplist

    -- Example of how to refresh the GUI after a looplist change
    -- This would ideally be an event-driven update, but for now, direct calls will work.
    local original_add = add_to_looplist
    function add_to_looplist(username)
        original_add(username)
        update_looplist_display(search_bar.Text)
    end

    local original_remove = remove_from_looplist
    function remove_from_looplist(username)
        original_remove(username)
        update_looplist_display(search_bar.Text)
    end
end

-- Call the GUI creation function after startup sequence
    create_looplist_gui()

    -- Initial startup sequence
    local function startup_sequence()
    load_looplist() -- Load looplist at startup
    print("Waiting for " .. INITIAL_WAIT_TIME .. " seconds for bot script to initialize...")
    wait(INITIAL_WAIT_TIME)
    print("Bot script initialized. Grace period of " .. GRACE_PERIOD_TIME .. " seconds begins...")
    wait(GRACE_PERIOD_TIME)
    GracePeriodActive = false
    print("Grace period ended.")

    -- Send initial commands
    send_command("inf^5^tppos 0 -1000000 0")
    send_command("spawn")
    send_command("inf^0.1^loopkill [looplist]")
    send_command("inf^2^walkfling")
    send_command("inf^0.1^loopgoto [looplist] 0")
    send_command("instarespawn")
    send_command("novoid")
    send_command("antiban")
    send_command("lessfilter 1")
end

-- Call the startup sequence when the script runs
startup_sequence()
