--[[ 
    Sentinel AI - Advanced Anti-Exploit and Player Management System

    This script provides a robust framework for detecting and managing exploiters
    and problematic players within a Roblox game. It includes features such as:
    - Automated detection for various exploits (e.g., fling, multiple kills, new accounts).
    - Player looping and unlooping functionalities.
    - Chat command processing for administrative actions.
    - Server hopping utility.
    - Whitelisting and permission management.
    - Persistent looplist storage.

    Key Modules:
    - Modules.Config: Centralized configuration settings.
    - Modules.Permissions: Manages player permissions (owner, mod, whitelisted).
    - Modules.Detection: Contains logic for various exploit detections.
    - Modules.Commands: Handles sending commands to the game executor.
    - Modules.Looplist: Manages the persistent list of looped players.
    - Modules.Utils: Provides utility functions like account age retrieval and server hopping.
    - Modules.Chat: Processes chat messages for commands and unloop phrases.

    Dependencies:
    - Roblox HttpService for JSON encoding/decoding.
    - Roblox TeleportService for server hopping.
    - Executor-specific functions for file I/O (readfile, writefile) and command execution (send_command).

    Usage:
    This script is designed to be injected and run within a Roblox game environment
    using a compatible executor. Configuration can be adjusted in Modules.Config.

    Last Updated: 2024-05-15
]]

-- Global Configuration for Sentinel AI
local Config = {
    -- Whitelist (using tables as sets for efficient lookups)
    -- List of Roblox usernames who are considered owners. Owners have full administrative privileges.
    OWNERS = {
        ["HollowGol"] = true,
    },
    -- List of Roblox usernames who are considered moderators. Moderators have elevated privileges for managing players.
    MODS = {
        ["STEVETheReal916"] = true,
        ["ColonThreeSpam"] = true,
        ["SpawnYellow2"] = true,
        ["SpawnBlack1"] = true,
        ["s71pl"] = true,
        ["Jacobthecool292"] = true,
        ["babyyodasonglol"] = true,
        ["forhelpingboi8"] = true,
        ["Kandale_Dingul"] = true,
        ["redalert_E"] = true,
        ["fariahoque28"] = true,
        ["baze15651"] = true,
        ["well_ihateboblux"] = true,
        ["0bj687Alt"] = true,
    },

    -- Looplist (will be loaded from JSON)
    -- Stores a list of players currently being looped. This table is populated dynamically from a file.
    Looplist = {}, -- This will be populated dynamically

    -- Other configurations
    -- Initial wait time before the system starts monitoring, allowing players to load in.
    INITIAL_WAIT_TIME = 7.5, -- seconds
    -- Grace period during which certain detections (e.g., automated looping) are inactive.
    GRACE_PERIOD_TIME = 5, -- seconds
    -- Flag indicating if the grace period is currently active.
    GracePeriodActive = true, -- New global variable
    -- Table to track recent kills by players for multi-kill detection.
    RecentKills = {}, -- This will be populated dynamically
    -- Brief delay between consecutive command keypresses to prevent spamming the executor.
    COMMAND_COOLDOWN = 0.1, -- seconds
    -- Maximum distance (in studs) for applying loop kill commands to a player.
    LOOP_KILL_DISTANCE = 24, -- studs
    -- Maximum distance (in studs) for applying standard kill commands to a player.
    KILL_DISTANCE = 15, -- studs
    -- Minimum distance (in studs) for a kill to count toward multi-kill detection.
    MULTI_KILL_DISTANCE = 25, -- studs
    -- Time window (in seconds) during which multiple kills from the same player trigger detection.
    MULTI_KILL_WINDOW = 0.25, -- seconds
    -- Minimum velocity (in studs per second) to trigger fling detection for a player.
    FLING_VELOCITY_THRESHOLD = 100, -- Adjust based on game's movement mechanics
    -- Secret chat phrase required to initiate an unloop command for a player.
    UNLOOP_PHRASE = "Qpmbsjbvt",

    -- Executor-specific key used to trigger the execution of commands.
    COMMAND_KEY = "ÅŸ",

    -- Name of the JSON file where the looplist is saved and loaded from.
    LOOPLIST_FILE_NAME = "Looplist.json",
}

local Modules = {}

Modules.Commands = {}
Modules.Looplist = {}

Modules.Utils = {}

function Modules.Utils.normalizeName(name)
    if not name or name == "" then return nil end
    return name:gsub("^@", "")

function Modules.Utils.normalizeForCompare(name)
    if not name or name == "" then return "" end
    return string.lower((name:gsub("^@", "")))
end
Modules.Detection = {}
Modules.Chat = {}
function Modules.Commands.send_command(command_string)
    -- This function is a placeholder for sending commands to the Roblox executor.
    -- Its actual implementation will depend heavily on the specific executor being used.
    -- Executors typically provide a global function (e.g., `game.Players.LocalPlayer.Chat:Chat()`, `execute`, `send_command`) 
    -- or a specific API to send commands to the game.
    print("Attempting to send command: " .. command_string)

    -- Example of how an executor might send a command:
    -- game:GetService("ReplicatedStorage").RemoteEvent:FireServer("execute", command_string)
    -- _G.execute(command_string)

    -- The keypress simulation below is a highly executor-dependent implementation.
    -- It's intended for executors that might require a simulated keypress to activate a command bar
    -- or similar input mechanism before the command string can be processed.
    if Config.COMMAND_KEY and Config.COMMAND_COOLDOWN then
        -- Uncomment and adapt the following lines based on your executor's capabilities:
        -- local UserInputService = game:GetService("UserInputService")
        -- UserInputService:SimulateKeyPress(Config.COMMAND_KEY, true) -- 'true' for release after press
        wait(Config.COMMAND_COOLDOWN) -- Wait for the command to potentially register
    end
end

Modules.Looplist = {}
function Modules.Looplist.save_looplist()
    -- This function relies on the executor's 'writefile' API.
    -- Ensure your executor supports 'writefile' for persistent looplist storage.
    local success, err = pcall(function()
        local json_data = game:GetService("HttpService"):JSONEncode(Config.Looplist)
        writefile(Config.LOOPLIST_FILE_NAME, json_data)
    end)
    if not success then
        warn("Looplist Save Error: Failed to save looplist. This usually means the executor's 'writefile' function is not available or encountered an error: " .. err)
    else
        print("Looplist saved successfully to " .. Config.LOOPLIST_FILE_NAME)
    end
end

function Modules.Looplist.load_looplist()
    -- This function relies on the executor's 'readfile' API.
    -- Ensure your executor supports 'readfile' for loading the looplist.
    local file_content_success, file_content = pcall(function()
        return readfile(Config.LOOPLIST_FILE_NAME)
    end)

    if not file_content_success then
        warn("Looplist Load Error: Failed to read looplist file. This usually means the executor's 'readfile' function is not available or the file does not exist: " .. file_content)
        Config.Looplist = {} -- Initialize an empty looplist if loading fails
        return
    end

    if file_content and file_content ~= "" then
        local decode_success, decoded_data = pcall(function()
            return game:GetService("HttpService"):JSONDecode(file_content)
        end)

        if not decode_success then
            warn("Looplist Load Error: Failed to decode looplist JSON. The file might be corrupted or not valid JSON: " .. decoded_data)
            Config.Looplist = {} -- Initialize an empty looplist if decoding fails
            return
        end

        if type(decoded_data) == "table" then
            Config.Looplist = decoded_data
            print("Looplist loaded successfully from " .. Config.LOOPLIST_FILE_NAME .. " with " .. #Config.Looplist .. " entries.")
        else
            warn("Looplist Load Warning: Loaded looplist data is not a table. Initializing an empty looplist.")
            Config.Looplist = {}
        end
    else
        print("Looplist file is empty or does not exist. Initializing a new empty looplist.")
        Config.Looplist = {}
    end
end

function Modules.Looplist.add_to_looplist(username)
    -- Adds a username to the in-memory looplist and saves the updated list to file.
    -- The username is normalized before being added to ensure consistency.
    local normalized_username = Modules.Utils.normalizeName(username)
    if normalized_username and not Config.Looplist[normalized_username] then
        Config.Looplist[normalized_username] = true
        Modules.Looplist.save_looplist()
        print(normalized_username .. " added to looplist.")
    end
end

function Modules.Looplist.remove_from_looplist(username)
    -- Removes a username from the in-memory looplist and saves the updated list to file.
    -- The username is normalized before attempting to remove it.
    local normalized_username = Modules.Utils.normalizeName(username)
    if normalized_username and Config.Looplist[normalized_username] then
        Config.Looplist[normalized_username] = nil
        Modules.Looplist.save_looplist()
        print(normalized_username .. " removed from looplist.")
    end
end

function Modules.Permissions.is_whitelisted(username)
    -- Checks if a given username is present in either the OWNERS or MODS configuration tables.
    -- This function is used to determine if a player has elevated permissions.
    -- The username should be normalized before being passed to this function for consistent checks.
    return Config.OWNERS[username] or Config.MODS[username]
end

function Modules.Utils.get_distance_between_characters(char1, char2)
    -- Calculates the distance between the PrimaryParts of two Roblox character models.
    -- Returns math.huge if either character or their PrimaryPart is not found, 
    -- indicating an immeasurable or infinite distance.
    if char1 and char2 and char1.PrimaryPart and char2.PrimaryPart then
        return (char1.PrimaryPart.Position - char2.PrimaryPart.Position).Magnitude
    end
    return math.huge -- Return a very large number if characters or primary parts are not found
end

function Modules.Detection.handle_kill_detection(killer_username, victim_username, distance)
    -- Detects suspicious kills based on distance and applies appropriate actions.
    -- Ignores whitelisted players to prevent false positives.
    -- If a kill occurs beyond Config.KILL_DISTANCE, a kill command is sent to the killer.
    -- After the grace period, if a kill occurs beyond Config.LOOP_KILL_DISTANCE, the killer is added to the looplist.
    if Modules.Permissions.is_whitelisted(killer_username) or Modules.Permissions.is_whitelisted(victim_username) then
        return -- Ignore whitelisted players
    end

    if distance >= Config.KILL_DISTANCE then
        print(killer_username .. " killed " .. victim_username .. " from " .. math.floor(distance) .. " studs. Applying kill command.")
        Modules.Commands.send_command("kill @" .. killer_username)
    end

    -- Automated looping detection (24+ studs after grace period)   -- This section handles automatic looping of players who kill from a distance greater than Config.LOOP_KILL_DISTANCE
    -- after the initial grace period has ended.
    if not Config.GracePeriodActive and distance >= Config.LOOP_KILL_DISTANCE then
        print(killer_username .. " killed " .. victim_username .. " from " .. math.floor(distance) .. " studs after grace period. Looping them.")
        Modules.Looplist.add_to_looplist(killer_username)
        Modules.Commands.send_command("inf^0.1^loopkill @" .. killer_username)
        Modules.Commands.send_command("inf^0.1^loopgoto @" .. killer_username .. " 0")
    end

-- Placeholder for kill event handling (logic moved to Modules.Detection.handle_kill_detection)
function Modules.Utils.get_account_age_in_days(player)
    -- Calculates the age of a Roblox player's account in days.
    -- This is useful for detecting potentially suspicious new accounts.
    -- 'player' is expected to be a Roblox Player object.
    local now = os.time()
    local created = player.AccountAge
    local diff = now - created
    return math.floor(diff / (60 * 60 * 24))
end

function Modules.Detection.handle_account_age_detection(player)
    -- Detects and loops players with very new accounts (account age <= 1 day).
    -- This helps in identifying and mitigating potential alt accounts or exploiters.
    -- Ignores whitelisted players.
    -- 'player' is expected to be a Roblox Player object.
    if Modules.Permissions.is_whitelisted(player.Name) then
        return -- Ignore whitelisted players
    end

    local account_age = Modules.Utils.get_account_age_in_days(player)
    -- If account age is 1 day or less, consider them a new account and loop them.
    if account_age <= 1 then
        print(player.Name .. " has an account age of " .. account_age .. " days. Looping them.")
        Modules.Looplist.add_to_looplist(player.Name)
        Modules.Commands.send_command("inf^0.1^loopkill @" .. player.Name)
        Modules.Commands.send_command("inf^0.1^loopgoto @" .. player.Name .. " 0")
    end
end

-- Placeholder for account age detection (logic moved to Modules.Detection.handle_account_age_detection)

function Modules.Chat.handle_chat_unloop(player_name, message)
    -- Handles the unloop chat command. When a player chats the Config.UNLOOP_PHRASE,
    -- this function temporarily removes them from the looplist and sends a series of commands
    -- to the executor to stop any active looping actions for that player.
    -- 'player_name' is the name of the player who chatted, 'message' is the full chat message.
    if message == Config.UNLOOP_PHRASE then
        print(player_name .. " chatted the unloop phrase. Temporarily unlooping them.")
        Modules.Looplist.remove_from_looplist(player_name)
        Modules.Commands.send_command("break")
        Modules.Commands.send_command("unloopgoto all")
        Modules.Commands.send_command("unloopkill all")
        Modules.Commands.send_command("inf^5^tppos 0 -1000000 0")
        Modules.Commands.send_command("inf^0.1^loopkill [looplist]")
        Modules.Commands.send_command("inf^2^walkfling")
        Modules.Commands.send_command("inf^0.1^loopgoto [looplist] 0")
    end
end

function Modules.Detection.handle_multiple_kills_detection(killer_name, victim_name, kill_distance)
    -- Detects players who rapidly accumulate multiple kills within a defined time window and distance.
    -- This helps identify potential exploiters or abusers.
    -- Ignores whitelisted players.
    -- 'killer_name' and 'victim_name' are strings, 'kill_distance' is a number.
    -- Ignore whitelisted players to prevent false positives
    if Modules.Permissions.is_whitelisted(killer_name) then
        return
    end

    -- Check if the kill distance exceeds the configured threshold for multiple kills
    if kill_distance >= Config.MULTI_KILL_DISTANCE then
        -- Initialize RecentKills table for the killer if it doesn't exist
        if not Config.RecentKills[killer_name] then
            Config.RecentKills[killer_name] = {}
        end

        -- Record the current kill time
        table.insert(Config.RecentKills[killer_name], os.time())

        -- Remove old kill entries that are outside the MULTI_KILL_WINDOW
        local current_time = os.time()
        for i = #Config.RecentKills[killer_name], 1, -1 do
            if (current_time - Config.RecentKills[killer_name][i]) > Config.MULTI_KILL_WINDOW then
                table.remove(Config.RecentKills[killer_name], i)
            end
        end

        -- If the number of recent kills exceeds the threshold, loop the player
        if #Config.RecentKills[killer_name] >= Config.MULTI_KILL_THRESHOLD then
            print(killer_name .. " has accumulated " .. #Config.RecentKills[killer_name] .. " kills within " .. Config.MULTI_KILL_WINDOW .. " seconds. Looping them.")
            Modules.Looplist.add_to_looplist(killer_name)
            Modules.Commands.send_command("inf^0.1^loopkill @" .. killer_name)
            Modules.Commands.send_command("inf^0.1^loopgoto @" .. killer_name .. " 0")
            Config.RecentKills[killer_name] = {} -- Reset kill count after looping
  --     end
    end

-- Placeholder for multiple kills detection (logic moved to Modules.Detection.handle_multiple_kills_detection)
end

function Modules.Detection.handle_fling_detection(player, character)
    -- Detects players who are potentially flinging others based on their character's velocity.
    -- If a player's velocity exceeds Config.FLINGER_VELOCITY_THRESHOLD, a kill command is sent to them.
    -- Ignores whitelisted players.
    -- 'player' is a Roblox Player object, 'character' is the player's Character model.
    if Modules.Permissions.is_whitelisted(player.Name) then
        return -- Ignore whitelisted players
    end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end

    local velocity = humanoidRootPart.AssemblyLinearVelocity or humanoidRootPart.Velocity
    if velocity and velocity.Magnitude > Config.FLINGER_VELOCITY_THRESHOLD then
        print(player.Name .. " detected flinging. Applying kill command.")
        Modules.Commands.send_command("kill @" .. player.Name)
    end
-- Placeholder for fling detection (logic moved to Modules.Detection.handle_fling_detection)

function Modules.Chat.handle_chat_commands(player_name, message)
    -- Processes chat commands prefixed with "sentinel".
    -- This function parses the message, validates the command and arguments,
    -- and executes the corresponding action (e.g., temploop, jump, unloop).
    -- Only whitelisted players can execute these commands.
    -- 'player_name' is the name of the player who sent the command, 'message' is the full chat message.
    local args = {}
    for word in string.gmatch(message, "%S+") do
        table.insert(args, word)
    end

    if #args == 0 then return end

    local command_prefix = args[1]:lower()
    if command_prefix ~= "sentinel" then return end

    if not Modules.Permissions.is_whitelisted(player_name) then
        print(player_name .. " attempted to use a Sentinel command but is not whitelisted.")
        return
    end

    if #args < 2 then
        print("Usage: sentinel <command> [args]")
        return
    end

    local sub_command = args[2]:lower()
    local target_username_raw = args[3]

    if sub_command == "temploop" or sub_command == "jump" or sub_command == "unloop" then
        if not target_username_raw or target_username_raw == "" then
            print("Usage: sentinel " .. sub_command .. " <Username>")
            return
        end
    end
    local target_username = target_username_raw and Modules.Utils.normalizeName(target_username_raw) or nil

    if sub_command == "temploop" then
        if not target_username or target_username == "" then
            print("Usage: sentinel temploop <Username>")
            return
        end
        -- Check if the target is whitelisted
        if Modules.Permissions.is_whitelisted(target_username) then
            print("Cannot temploop a whitelisted player: " .. target_username)
            return
        end
        print(player_name .. " temporarily looping " .. target_username)
        Modules.Commands.send_command("inf^0.1^loopkill @" .. target_username)
        Modules.Commands.send_command("inf^0.1^loopgoto @" .. target_username .. " 0")
        -- Note: Temploop does not add to the persistent looplist
    elseif sub_command == "jump" then
        if not target_username or target_username == "" then
            print("Usage: sentinel jump <Username>")
            return
        end
        if Modules.Permissions.is_whitelisted(target_username) then
            print("Cannot jump-loop a whitelisted player: " .. target_username)
            return
        end
        print(player_name .. " jump-looping and adding to looplist: " .. target_username)
        Modules.Looplist.add_to_looplist(target_username)
        Modules.Commands.send_command("inf^0.1^loopkill @" .. target_username)
        Modules.Commands.send_command("inf^0.1^loopgoto @" .. target_username .. " 0")
    elseif sub_command == "unloop" then
        if not target_username or target_username == "" then
            print("Usage: sentinel unloop <Username>")
            return
        end
        if Modules.Permissions.is_whitelisted(target_username) then
            print("Cannot unloop a whitelisted player: " .. target_username)
            return
        end
        print(player_name .. " unlooping and removing from looplist: " .. target_username)
        Modules.Looplist.remove_from_looplist(target_username)
        Modules.Commands.send_command("unloopkill @" .. target_username)
        Modules.Commands.send_command("unloopgoto @" .. target_username)
    elseif sub_command == "shop" then
        print(player_name .. " initiated a manual server hop.")
        Modules.Utils.server_hop()
    else
        print("Unknown Sentinel command: " .. sub_command)
    end
end

-- Placeholder for chat command handling (logic moved to Modules.Chat.handle_chat_commands)

-- Server hopping logic
function Modules.Utils.should_server_hop()
    local players = game:GetService("Players"):GetPlayers()
    local non_whitelisted_players = 0

    for _, player in ipairs(players) do
        if player.Name ~= game:GetService("Players").LocalPlayer.Name and not Modules.Permissions.is_whitelisted(player.Name) then
            non_whitelisted_players = non_whitelisted_players + 1
        end
    end

    -- If there are no other players (excluding self and whitelisted players), server hop
    return non_whitelisted_players >= Config.PLAYER_COUNT_THRESHOLD
end

function Modules.Utils.server_hop()
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    -- Placeholder for actual server hopping logic
    -- In a real scenario, you would find a new server to teleport to.
    -- This might involve a pre-determined server ID, or logic to find a less populated server.
    print("Attempting to server hop...")

    -- Example: Teleport to a new, empty server of the current place
    -- This requires the place to be set up for private servers or have available public servers.
    -- For demonstration, we'll just print a message.
    local success, err = pcall(function() TeleportService:Teleport(game.PlaceId) end)
    if not success then
        warn("Teleport failed: ", err)
    else
        print("Teleport initiated successfully.")
    end
end
end

-- Looplist GUI Implementation
function Modules.GUI.create_looplist_gui()
    local player = game:GetService("Players").LocalPlayer
    local player_gui = player:WaitForChild("PlayerGui")

    local screen_gui = Instance.new("ScreenGui")
    screen_gui.Name = "LooplistScreenGui"
    screen_gui.Parent = player_gui

    local main_frame = Instance.new("Frame")
    main_frame.Name = "LooplistFrame"
    main_frame.Size = UDim2.new(0, 300, 0, 400)
    main_frame.Position = UDim2.new(0.5, -150, 0.5, -200) -- Center of the screen
    main_frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    main_frame.BorderSizePixel = 1
    main_frame.BorderColor3 = Color3.fromRGB(20, 20, 20)
    main_frame.Active = true -- Essential for dragging
    main_frame.Draggable = true -- Make the frame draggable
    main_frame.Parent = screen_gui

    local title_bar = Instance.new("Frame")
    title_bar.Name = "TitleBar"
    title_bar.Size = UDim2.new(1, 0, 0, 30)
    title_bar.Position = UDim2.new(0, 0, 0, 0)
    title_bar.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    title_bar.BorderSizePixel = 0
    title_bar.Parent = main_frame

    local title_label = Instance.new("TextLabel")
    title_label.Name = "TitleLabel"
    title_label.Size = UDim2.new(1, -40, 1, 0)
    title_label.Position = UDim2.new(0, 0, 0, 0)
    title_label.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    title_label.Text = "Sentinel Looplist"
    title_label.TextColor3 = Color3.fromRGB(255, 255, 255)
    title_label.Font = Enum.Font.SourceSansBold
    title_label.TextSize = 18
    title_label.TextXAlignment = Enum.TextXAlignment.Center
    title_label.TextYAlignment = Enum.TextYAlignment.Center
    title_label.BorderSizePixel = 0
    title_label.Parent = title_bar

    local minimize_button = Instance.new("TextButton")
    minimize_button.Name = "MinimizeButton"
    minimize_button.Size = UDim2.new(0, 30, 1, 0)
    minimize_button.Position = UDim2.new(1, -30, 0, 0)
    minimize_button.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    minimize_button.Text = "_"
    minimize_button.TextColor3 = Color3.fromRGB(255, 255, 255)
    minimize_button.Font = Enum.Font.SourceSansBold
    minimize_button.TextSize = 20
    minimize_button.BorderSizePixel = 0
    minimize_button.Parent = title_bar

    minimize_button.MouseButton1Click:Connect(function()
        main_frame.Visible = not main_frame.Visible
    end)

    -- Search bar
    local search_bar = Instance.new("TextBox")
    search_bar.Name = "SearchBar"
    search_bar.Size = UDim2.new(1, -20, 0, 25)
    search_bar.Position = UDim2.new(0, 10, 0, 40)
    search_bar.PlaceholderText = "Search looplist..."
    search_bar.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    search_bar.TextColor3 = Color3.fromRGB(255, 255, 255)
    search_bar.Font = Enum.Font.SourceSans
    search_bar.TextSize = 14
    search_bar.ClearTextOnFocus = false
    search_bar.Parent = main_frame

    -- Scrolling frame for looplist items
    local looplist_scrolling_frame = Instance.new("ScrollingFrame")
    looplist_scrolling_frame.Name = "LooplistScrollingFrame"
    looplist_scrolling_frame.Size = UDim2.new(1, -20, 1, -80)
    looplist_scrolling_frame.Position = UDim2.new(0, 10, 0, 75)
    looplist_scrolling_frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    looplist_scrolling_frame.BorderSizePixel = 1
    looplist_scrolling_frame.BorderColor3 = Color3.fromRGB(20, 20, 20)
    looplist_scrolling_frame.CanvasSize = UDim2.new(0, 0, 0, 0) -- Will be updated dynamically
    looplist_scrolling_frame.ScrollBarThickness = 8
    looplist_scrolling_frame.Parent = main_frame

    local ui_list_layout = Instance.new("UIListLayout")
    ui_list_layout.Name = "LooplistLayout"
    ui_list_layout.FillDirection = Enum.FillDirection.Vertical
    ui_list_layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    ui_list_layout.VerticalAlignment = Enum.VerticalAlignment.Top
    ui_list_layout.Padding = UDim.new(0, 5)
    ui_list_layout.Parent = looplist_scrolling_frame

    -- Function to update the displayed looplist items
    local function update_looplist_display(filter_text)
        for _, child in ipairs(looplist_scrolling_frame:GetChildren()) do
            if child:IsA("TextLabel") or child:IsA("Frame") then
                child:Destroy()
            end
        end

        local current_y_offset = 0
        local item_height = 25

        -- Iterate over Config.Looplist (which is now a set)
        for username, _ in pairs(Modules.Looplist.get_looplist()) do
            if filter_text == "" or string.find(username:lower(), filter_text:lower()) then
                local item_frame = Instance.new("Frame")
                item_frame.Name = username .. "_Item"
                item_frame.Size = UDim2.new(1, 0, 0, item_height)
                item_frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                item_frame.BorderSizePixel = 0
                item_frame.Parent = looplist_scrolling_frame

                local username_label = Instance.new("TextLabel")
                username_label.Name = "UsernameLabel"
                username_label.Size = UDim2.new(1, -60, 1, 0)
                username_label.Position = UDim2.new(0, 0, 0, 0)
                username_label.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                username_label.Text = username
                username_label.TextColor3 = Color3.fromRGB(255, 255, 255)
                username_label.Font = Enum.Font.SourceSans
                username_label.TextSize = 16
                username_label.TextXAlignment = Enum.TextXAlignment.Left
                username_label.TextYAlignment = Enum.TextYAlignment.Center
                username_label.TextWrapped = true
                username_label.BorderSizePixel = 0
                username_label.Parent = item_frame

                local unloop_button = Instance.new("TextButton")
                unloop_button.Name = "UnloopButton"
                unloop_button.Size = UDim2.new(0, 50, 1, 0)
                unloop_button.Position = UDim2.new(1, -50, 0, 0)
                unloop_button.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
                unloop_button.Text = "Unloop"
                unloop_button.TextColor3 = Color3.fromRGB(255, 255, 255)
                unloop_button.Font = Enum.Font.SourceSansBold
                unloop_button.TextSize = 14
                unloop_button.BorderSizePixel = 0
                unloop_button.Parent = item_frame

                unloop_button.MouseButton1Click:Connect(function()
                    Modules.Looplist.remove_from_looplist(username)
                    Modules.Commands.send_command("unloopkill @" .. username)
                    Modules.Commands.send_command("unloopgoto @" .. username)
                    update_looplist_display(search_bar.Text)
                end)

                current_y_offset = current_y_offset + item_height + ui_list_layout.Padding.Offset
            end
        end
        looplist_scrolling_frame.CanvasSize = UDim2.new(0, 0, 0, current_y_offset)
    end

    search_bar.Changed:Connect(function(property)
        if property == "Text" then
            update_looplist_display(search_bar.Text)
        end
    end)

    -- Initial display update
    update_looplist_display("")

    -- Connect looplist changes to GUI update
    Modules.Looplist.looplist_changed:Connect(function()
        update_looplist_display(search_bar.Text)
    end)

    return screen_gui
end

local function startup_sequence()
    Modules.Looplist.load_looplist()
    print("Sentinel AI initializing...")
    wait(Config.INITIAL_WAIT_TIME)
    print("Grace period active for " .. Config.GRACE_PERIOD_TIME .. " seconds.")
    wait(Config.GRACE_PERIOD_TIME)
    Config.GracePeriodActive = false
    print("Grace period ended. All automated detections are now active.")
    create_looplist_gui()
end

-- Call the startup sequence when the script runs
startup_sequence()
