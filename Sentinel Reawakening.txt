-- SFOTHO Security Bot Script v3.1 - Complete Rewrite
-- FE Compatible Vigilante Security System
-- Fully Functional with Zero Console Leakage

 print("Loading SFOTHO Security Bot v4.0...")

-- ========================================
-- CORE SERVICES INITIALIZATION
-- ========================================

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TextChatService = game:GetService("TextChatService")
local CoreGui = game:GetService("CoreGui")
local TeleportService = game:GetService("TeleportService")

local LocalPlayer = Players.LocalPlayer
local botOwner = LocalPlayer.Name

-- ========================================
-- CONFIGURATION
-- ========================================

local Config = {
    NEW_ACCOUNT_THRESHOLD = 0, -- Days for new account detection
    LONG_KILL_DISTANCE = 200, -- studs; above this considered suspicious
    COMMAND_DELAY = 0.75, -- delay between commands in sequences
    CHAR_DELAY_MIN = 0.05,
    CHAR_DELAY_MAX = 0.18,
    RETRY_LIMIT = 3,
    STOP_KEYWORD = "Qpmbsjbvt",
    SEQUENCE_ON_JOIN = true,
    COMMAND_TOGGLE_CHAR = "ş", -- requested custom key to open IY command bar
    COMMAND_TOGGLE_KEYCODE = Enum.KeyCode.Semicolon, -- fallback toggle
    PLACE_ID = game.PlaceId,
    SERVER_HOP_CHECK_DELAY = 10, -- seconds after join to check solo
    ACTION_ON_NEW_ACCOUNT = "loopkill", -- loopkill | loopfling | singlekill
    ACTION_ON_KILL_BOT = "loopfling", -- action when someone kills the bot
    ACTION_ON_LONG_DISTANCE = "singlekill" -- action for suspicious long-distance kills
    ,
    LOOPLIST_FILE = "SecurityBot_looplist.txt" -- local file to persist current loop list
}

-- ========================================
-- WHITELIST SYSTEMS
-- ========================================

local OWNER_WHITELIST = {"HollowGol"}
local MOD_WHITELIST = {
    "STEVETheReal916", "ColonThreeSpam", "SpawnYellow2", "SpawnBlack1",
    "s71pl", "TheSwordFightingBot2", "Jacobthecool292", "babyyodasonglol",
    "Kandale_Dingul", "redalert_E", "fariahoque28", "baze15651",
    "well_ihateboblux", "0bj687Alt"
}

local loopkillsList = {
    "@ImACute_Gorl4", "@guaiabsi", "@x990Xd", "@kgkkgkktll", "@ldsklfklsdfkldskfds", 
    "@jrtkgkkgkgkgkhk","@BoomyRealTop1Global", "@Lucasshed_1", "@SpawnYeIIow8", "@noradrenilne",
    "@djskfjdskfjkdsjfkds", "@spy6767676767678", "@gavotx", "@7389322",
    "@SayuriWasTaken", "@bacondude629", "@sdsssssssssssssssfss", "@entity9258",
    "@tomitoest", "@randomsnakeguy2", "@soetidjou", "@dontyoudare911",
    "@aerotypings", "@vaziolele2222", "@fdgdffdsf3424", "@hiyahiya583",
    "@CapyBarchik87", "@burpboy67", "@SkinnyLegendCeana",
    "@norasnewaccheh", "@Sugarcrashjojo", "@thetgpugooner", "@Mr_Remembers",
    "@Tomryden2cuzwhynot", "@slaitmyarwse", "@Aquatic_515", "@lukenicolotreoyo",
    "@Man06Tay10", "@unknownexp9", "@Jaja1og5",
    "@unknownexp10", "@unknownexp12", "@hazaeur", "@homier_822825", "@cookie_333128", "@wubberio",
    "@yesus120strange", "@guest_201406", "@LOS_HACKERSS", "@inbluejeans", "@nicopla1234", "@baskanpro200",
    "@Luc_2004sad", "@suspiciousacc15", "@ohnobabyohno11", "@1B0b7", "@c00l_stark", "@miscoloredspawn",
    "@tytytyttyyyttyytyy", "@hackerdude977", "@bloxfruit4372763", "@PavoIski", "@ceanaphobic",
    "@BannedYouXx4_1x1x1x1", "@russki_krutoi", "@JustAnExploiterr", "@Tuscan_12345689", "@DERZKO69",
    "@Reallylongnamelololm", "@yahyaslapbattle", "@SonicShadows126", "@sadssdasddasss", "@falooda12345_1",
    "@bombplanner256", "@h00zgui", "@deaglestabbed", "@Luka123631", "@luigimario_1241", "@Hackerbacon694",
    "@WhiteGuy603", "@aygul3103", "@TMKOC63", "@damnitnega", "@haushhidnuxw8eu", "@PurpleGuySmashes1",
    "@PurpleGuySmashes", "@T0_Testing", "@Dollmyaccdisabled686", "@benzoine", "@Jqsminx", "@TheBoselyMan"
}

-- ========================================
-- STATE MANAGEMENT
-- ========================================

local State = {
    processedPlayers = {},
    loopedPlayers = {},
    stoppedPlayers = {},
    botActive = false,
    seqRan = false,
    connections = {},
    textInputSupported = false,
}

-- ========================================
-- UTILITY FUNCTIONS
-- ========================================

local function safeWait(duration)
    local success, err = pcall(function()
        task.wait(duration or 0.1)
    end)
    if not success then
        print("[ERROR] Wait failed:", err)
    end
end

-- ========================================
-- FILESYSTEM HELPERS (optional, executor-dependent)
-- ========================================

local function hasFilesystem()
    return type(isfile) == "function" and type(writefile) == "function" and type(readfile) == "function"
end

local function normalizeName(name)
    if not name or name == "" then return nil end
    return name:gsub("^@", "")
end

local function ensureLooplistFile()
    if hasFilesystem() then
        local ok = true
        if not isfile(Config.LOOPLIST_FILE) then
            ok = pcall(function()
                writefile(Config.LOOPLIST_FILE, "")
            end)
        end
        if not ok then
            print("[WARN] Unable to create looplist file:", Config.LOOPLIST_FILE)
        end
    end
end

local function readLooplist()
    local list = { loopkill = {}, loopfling = {} }
    if not hasFilesystem() then return list end
    local ok, content = pcall(function()
        return readfile(Config.LOOPLIST_FILE)
    end)
    if not ok or not content then return list end
    for line in string.gmatch(content .. "\n", "([^\n]*)\n") do
        local ln = line:match("^%s*(.-)%s*$")
        if ln and ln ~= "" then
            local action, user = ln:match("^(loopkill)%s*:%s*(.+)$")
            if not action then action, user = ln:match("^(loopfling)%s*:%s*(.+)$") end
            if action and user then
                user = normalizeName(user)
                list[action][user] = true
            else
                -- Fallback: if line starts with @name, treat as loopkill
                local plain = normalizeName(ln)
                if plain then list.loopkill[plain] = true end
            end
        end
    end
    return list
end

local function writeLooplist(list)
    if not hasFilesystem() then return end
    local buf = {}
    for user, _ in pairs(list.loopkill or {}) do
        table.insert(buf, "loopkill: " .. user)
    end
    for user, _ in pairs(list.loopfling or {}) do
        table.insert(buf, "loopfling: " .. user)
    end
    local ok = pcall(function()
        writefile(Config.LOOPLIST_FILE, table.concat(buf, "\n"))
    end)
    if not ok then
        print("[WARN] Unable to write looplist file:", Config.LOOPLIST_FILE)
    end
end

local function addToLooplist(action, playerName)
    if not hasFilesystem() then return end
    ensureLooplistFile()
    local list = readLooplist()
    local name = normalizeName(playerName)
    if not name then return end
    list[action] = list[action] or {}
    list[action][name] = true
    writeLooplist(list)
end

local function removeFromLooplist(playerName)
    if not hasFilesystem() then return end
    local list = readLooplist()
    local name = normalizeName(playerName)
    if not name then return end
    if list.loopkill then list.loopkill[name] = nil end
    if list.loopfling then list.loopfling[name] = nil end
    writeLooplist(list)
end

-- ========================================
-- KEY INPUT HELPERS (enum keypress typing)
-- ========================================

local function tapKey(keyCode)
    VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
    safeWait(0.03)
    VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
end

local function trySendText(char)
    local ok = pcall(function()
        -- SendTextInput is more robust for non-ASCII like "ş" and symbols like "^"
        VirtualInputManager:SendTextInput(char)
    end)
    return ok
end

-- Use a single, validated key map (no invalid Enum members)
local function optKey(member)
    local ok, val = pcall(function() return Enum.KeyCode[member] end)
    if ok then return val end
    return nil
end

local KEYMAP = {
    a=Enum.KeyCode.A,b=Enum.KeyCode.B,c=Enum.KeyCode.C,d=Enum.KeyCode.D,e=Enum.KeyCode.E,
    f=Enum.KeyCode.F,g=Enum.KeyCode.G,h=Enum.KeyCode.H,i=Enum.KeyCode.I,j=Enum.KeyCode.J,
    k=Enum.KeyCode.K,l=Enum.KeyCode.L,m=Enum.KeyCode.M,n=Enum.KeyCode.N,o=Enum.KeyCode.O,
    p=Enum.KeyCode.P,q=Enum.KeyCode.Q,r=Enum.KeyCode.R,s=Enum.KeyCode.S,t=Enum.KeyCode.T,
    u=Enum.KeyCode.U,v=Enum.KeyCode.V,w=Enum.KeyCode.W,x=Enum.KeyCode.X,y=Enum.KeyCode.Y,
    z=Enum.KeyCode.Z,
    ["0"]=Enum.KeyCode.Zero,["1"]=Enum.KeyCode.One,["2"]=Enum.KeyCode.Two,["3"]=Enum.KeyCode.Three,
    ["4"]=Enum.KeyCode.Four,["5"]=Enum.KeyCode.Five,["6"]=Enum.KeyCode.Six,["7"]=Enum.KeyCode.Seven,
    ["8"]=Enum.KeyCode.Eight,["9"]=Enum.KeyCode.Nine,
    [" "]=Enum.KeyCode.Space,["."]=Enum.KeyCode.Period,[","]=Enum.KeyCode.Comma,["-"]=Enum.KeyCode.Minus,
    ["="]=Enum.KeyCode.Equals,["["]=Enum.KeyCode.LeftBracket,["]"]=Enum.KeyCode.RightBracket,
    ["\\"]=Enum.KeyCode.BackSlash,[";"]=Enum.KeyCode.Semicolon,
    ["'"]=Enum.KeyCode.Quote,["/"]=Enum.KeyCode.Slash,
    ["`"]=optKey("Backquote")
}

local function getKeyCodeForChar(char)
    return KEYMAP[string.lower(char)] or KEYMAP[char]
end

-- Detect once whether SendTextInput is supported by the current executor
local function detectTextInputSupport()
    local ok = pcall(function()
        VirtualInputManager:SendTextInput("a")
    end)
    State.textInputSupported = ok
end

local function typeTextSmart(text)
    for i=1,#text do
        local ch = string.sub(text,i,i)
        -- Prefer SendTextInput for full symbol support, if available
        if State.textInputSupported then
            local ok = trySendText(ch)
            if not ok then
                -- Fallback on executor failure: shifted keys and base map
                local base
                local isUpper = ch:match("[A-Z]") ~= nil
                local lower = string.lower(ch)
                local SHIFTED = {
                    [":"] = Enum.KeyCode.Semicolon,
                    ["_"] = Enum.KeyCode.Minus,
                    ["+"] = Enum.KeyCode.Equals,
                    ["\""] = Enum.KeyCode.Quote,
                    ["^"] = Enum.KeyCode.Six
                }
                base = SHIFTED[ch]
                if isUpper then base = getKeyCodeForChar(lower) end
                if base then
                    -- press with shift
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
                    safeWait(0.02)
                    tapKey(base)
                    safeWait(0.02)
                    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
                else
                    local kc = getKeyCodeForChar(ch)
                    if kc then tapKey(kc) end
                end
            end
        else
            local isUpper = ch:match("[A-Z]") ~= nil
            local lower = string.lower(ch)
            local SHIFTED = {
                [":"] = Enum.KeyCode.Semicolon,
                ["_"] = Enum.KeyCode.Minus,
                ["+"] = Enum.KeyCode.Equals,
                ["\""] = Enum.KeyCode.Quote,
                ["^"] = Enum.KeyCode.Six
            }
            local base = SHIFTED[ch]
            if isUpper then base = getKeyCodeForChar(lower) end
            if base then
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
                safeWait(0.02)
                tapKey(base)
                safeWait(0.02)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
            else
                local kc = getKeyCodeForChar(ch)
                if kc then tapKey(kc) end
            end
        end
        safeWait(math.random(math.floor(Config.CHAR_DELAY_MIN*1000), math.floor(Config.CHAR_DELAY_MAX*1000))/1000)
    end
end

local function pressEnter()
    tapKey(Enum.KeyCode.Return)
end

local function toggleCommandBar()
    -- Try the requested custom char first ("ş"); only fall back if needed
    local opened = trySendText(Config.COMMAND_TOGGLE_CHAR)
    if not opened then
        tapKey(Config.COMMAND_TOGGLE_KEYCODE)
    end
    safeWait(0.15)
    return opened
end

local function ensureCommandBarFocused()
    local focused = UserInputService:GetFocusedTextBox()
    if focused then return true end
    toggleCommandBar()
    safeWait(0.1)
    focused = UserInputService:GetFocusedTextBox()
    return focused ~= nil
end

local function isWhitelisted(username)
    if not username then return false end
    
    for _, name in pairs(OWNER_WHITELIST) do
        if name == username then return true end
    end
    
    for _, name in pairs(MOD_WHITELIST) do
        if name == username then return true end
    end
    
    return false
end

local function isNewAccount(player)
    if not player or player.AccountAge == nil then return false end
    return player.AccountAge <= Config.NEW_ACCOUNT_THRESHOLD
end

-- ========================================
-- ADMIN COMMAND EXECUTION (human-like typing)
-- ========================================

local function executeCommand(command)
    for attempt = 1, Config.RETRY_LIMIT do
        local ok, err = pcall(function()
            ensureLooplistFile()
            if not ensureCommandBarFocused() then
                error("Command bar not focused")
            end
            safeWait(0.05)
            typeTextSmart(command)
            safeWait(0.05)
            pressEnter()
        end)
        if ok then
            print("[SUCCESS] Command executed:", command)
            return true
        else
            print("[WARN] Command attempt", attempt, "failed:", err)
            safeWait(0.25)
        end
    end
    print("[ERROR] Command execution failed after retries:", command)
    return false
end

local function executeAdminAction(action, playerName)
    if not playerName or playerName == "" then return false end
    local cmd
    if action == "loopkill" then
        cmd = "loopkill "..playerName
    elseif action == "loopfling" then
        -- Per requirement: loopfling refers to loopgoto
        cmd = "loopgoto "..playerName
    elseif action == "singlekill" then
        cmd = "kill "..playerName
    else
        return false
    end
    local ok = executeCommand(cmd)
    if ok then addToLooplist(action, playerName) end
    return ok
end

local function stopPlayerLoop(player)
    if not player then return end
    local name = player.Name
    State.stoppedPlayers[name] = true
    executeCommand("unloopkill "..name)
    executeCommand("unloopgoto "..name)
    removeFromLooplist(name)
    print("[INFO] Stopped loops for", name)
end

-- Legacy getKeyCodeForChar removed to avoid invalid Enum members.
-- Use the validated KEYMAP and getKeyCodeForChar defined above.

-- ========================================
-- We do NOT scan or look for admin GUI per your instructions.
-- Instead, we only toggle the command bar and type via keypress/text.

-- ========================================
-- Already replaced by the human-like executor above

-- ========================================
-- ========================================
-- PLAYER MANAGEMENT AND DETECTION
-- ========================================

local function shouldProcessPlayer(player)
    if not player then return false end
    if player == LocalPlayer then return false end
    if isWhitelisted(player.Name) then return false end
    if State.stoppedPlayers[player.Name] then return false end
    if State.processedPlayers[player.Name] then return false end
    return isNewAccount(player)
end

local function runJoinSequence()
    if State.seqRan or not Config.SEQUENCE_ON_JOIN then return end
    local seq = {
        "novoid",
        "inf^10^tppos 0 -1000000 0",
        "inf^0.1^loopkill",
        "inf^2^walkfling",
        "inf^0.1^loopgoto",
        "instarespawn",
        "antiban",
        "lessfilter 1"
    }
    for _, cmd in ipairs(seq) do
        executeCommand(cmd)
        safeWait(Config.COMMAND_DELAY)
    end
    State.seqRan = true
end

local function checkSoloAndHop()
    safeWait(Config.SERVER_HOP_CHECK_DELAY)
    local count = #Players:GetPlayers()
    if count <= 1 then
        print("[INFO] Solo detected; initiating server hop...")
        pcall(function()
            TeleportService:Teleport(Config.PLACE_ID, LocalPlayer)
        end)
    end
end

local function handleBotDeath(humanoid)
    local killerPlayer
    local tag = humanoid:FindFirstChild("creator") or humanoid:FindFirstChild("Creator")
    if tag and tag:IsA("ObjectValue") then
        local val = tag.Value
        if val and val:IsA("Player") then
            killerPlayer = val
        elseif val and val:IsA("Model") then
            -- Sometimes stores a character model, get the player by name
            killerPlayer = Players:FindFirstChild(val.Name)
        end
    end
    if killerPlayer and not isWhitelisted(killerPlayer.Name) then
        local dist = 0
        pcall(function()
            local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            local krRoot = killerPlayer.Character and killerPlayer.Character:FindFirstChild("HumanoidRootPart")
            if myRoot and krRoot then
                dist = (myRoot.Position - krRoot.Position).Magnitude
            end
        end)
        local action = Config.ACTION_ON_KILL_BOT
        if dist >= Config.LONG_KILL_DISTANCE then
            action = Config.ACTION_ON_LONG_DISTANCE
        end
        print("[DETECTION] Bot killed by", killerPlayer.Name, "distance:", math.floor(dist))
        executeAdminAction(action, killerPlayer.Name)
    end
end

local function setupCharacterMonitoring(character)
    local humanoid = character:WaitForChild("Humanoid", 10)
    if humanoid then
        local conn = humanoid.Died:Connect(function()
            handleBotDeath(humanoid)
        end)
        table.insert(State.connections, conn)
    end
end

local function processNewPlayer(player)
    if shouldProcessPlayer(player) then
        print("[DETECTION] New account:", player.Name, "Age:", player.AccountAge)
        State.processedPlayers[player.Name] = true
        executeAdminAction(Config.ACTION_ON_NEW_ACCOUNT, player.Name)
        safeWait(Config.COMMAND_DELAY)
    end
end

local function setupPlayerEvents()
    print("[INFO] Setting up player monitoring...")
    for _, p in ipairs(Players:GetPlayers()) do
        processNewPlayer(p)
    end
    table.insert(State.connections, Players.PlayerAdded:Connect(function(p)
        safeWait(1)
        processNewPlayer(p)
    end))
end

local function setupChatMonitoring()
    print("[INFO] Setting up chat monitoring...")
    local ok = pcall(function()
        TextChatService.MessageReceived:Connect(function(message)
            if message.TextSource and message.TextSource.UserId then
                local p = Players:GetPlayerByUserId(message.TextSource.UserId)
                if p and message.Text == Config.STOP_KEYWORD then
                    stopPlayerLoop(p)
                end
            end
        end)
    end)
    if not ok then
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= LocalPlayer then
                p.Chatted:Connect(function(msg)
                    if msg == Config.STOP_KEYWORD then
                        stopPlayerLoop(p)
                    end
                end)
            end
        end
        Players.PlayerAdded:Connect(function(p)
            p.Chatted:Connect(function(msg)
                if msg == Config.STOP_KEYWORD then
                    stopPlayerLoop(p)
                end
            end)
        end)
    end
end

local function initializeBot()
    print("[INFO] Initializing Security Bot...")
    State.botActive = true
    detectTextInputSupport()
    setupChatMonitoring()
    setupPlayerEvents()
    ensureLooplistFile()
    local persisted = readLooplist()
    for name, _ in pairs(persisted.loopkill or {}) do
        executeCommand("loopkill "..name)
        safeWait(Config.COMMAND_DELAY)
    end
    for name, _ in pairs(persisted.loopfling or {}) do
        executeCommand("loopgoto "..name)
        safeWait(Config.COMMAND_DELAY)
    end
    if LocalPlayer.Character then
        setupCharacterMonitoring(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(function(char)
        setupCharacterMonitoring(char)
    end)
    print("[SUCCESS] Security Bot v4.0 initialized!")
    print("[INFO] Monitoring new accounts (Age ≤", Config.NEW_ACCOUNT_THRESHOLD, "days)")
    runJoinSequence()
    task.spawn(checkSoloAndHop)
    return true
end

-- ========================================
-- STARTUP
-- ========================================

-- Initialize the bot
local initSuccess = initializeBot()

if initSuccess then
    print("[SUCCESS] SFOTHO Security Bot v4.0 is active!")
    print("[INFO] Stop keyword:", Config.STOP_KEYWORD)
else
    print("[ERROR] Failed to initialize Security Bot")
end
