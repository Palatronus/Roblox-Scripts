-- LinkedSwordAI_Professional.lua
-- Professional version with smart pathfinding and advanced combat behaviors

-- Force print function to ensure output is visible
local function forcePrint(...)
    local args = {...}
    local message = ""
    for i, v in ipairs(args) do
        message = message .. tostring(v) .. (i < #args and " " or "")
    end
    
    -- Try multiple output methods to ensure visibility
    print(message)
    warn(message)
    
    -- Also try rconsoleprint if available (for some executors)
    pcall(function() rconsoleprint(message .. "\n") end)
end

forcePrint("LinkedSwordAI: Professional script starting...")

-- Professional Configuration
local CONFIG = {
    DETECTION_RADIUS = 100,
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.8,
    LUNGE_DELAY = 0.1,
    STUCK_CHECK_DISTANCE = 1.5,
    STUCK_CHECK_TIME = 1.0,
    MAX_TARGET_DISTANCE = 150,
    RETARGET_CHECK_TIME = 1.0,
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -10,
    FORCEFIELD_FLEE_DISTANCE = 30,
    SWORD_CHECK_INTERVAL = 5,
    -- Professional settings
    EQUIP_DELAY = 1.0,
    PATH_REFRESH_RATE = 0.3,
    COMBAT_MODE_DURATION = 3, -- Seconds before switching combat style
    STRAFING_RANGE = 10,
    AGGRESSIVE_CHARGE_DISTANCE = 8,
    RETREAT_DISTANCE = 5,
    NAVIGATION_RAYCAST_DISTANCE = 30,
    BRIDGE_DETECTION_WIDTH = 5,
    OBSTACLE_AVOIDANCE_DISTANCE = 3
}

-- Create a status GUI with combat mode display
local function CreateStatusGUI()
    forcePrint("LinkedSwordAI: Creating professional status GUI...")
    
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "LinkedSwordAI_Professional"
    
    local success = false
    local parentMethods = {
        function() ScreenGui.Parent = game:GetService("CoreGui") end,
        function() ScreenGui.Parent = game.Players.LocalPlayer.PlayerGui end,
        function() ScreenGui.Parent = game.Players.LocalPlayer:FindFirstChildOfClass("PlayerGui") end
    }
    
    for _, method in ipairs(parentMethods) do
        success = pcall(method)
        if success then
            forcePrint("LinkedSwordAI: Successfully parented GUI")
            break
        end
    end
    
    if not success then
        forcePrint("LinkedSwordAI: WARNING - Could not create GUI, continuing without visual feedback")
        return nil
    end
    
    local Frame = Instance.new("Frame")
    Frame.Size = UDim2.new(0, 220, 0, 140) -- Increased height for combat mode
    Frame.Position = UDim2.new(0, 10, 0, 10)
    Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Frame.BackgroundTransparency = 0.5
    Frame.BorderSizePixel = 2
    Frame.Parent = ScreenGui
    
    local Title = Instance.new("TextLabel")
    Title.Size = UDim2.new(1, 0, 0, 20)
    Title.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.Text = "LinkedSword AI (Professional)"
    Title.Font = Enum.Font.SourceSansBold
    Title.TextSize = 14
    Title.Parent = Frame
    
    local Status = Instance.new("TextLabel")
    local Target = Instance.new("TextLabel")
    local Distance = Instance.new("TextLabel")
    local CombatMode = Instance.new("TextLabel") -- New combat mode display
    
    Status.Size = UDim2.new(1, 0, 0, 20)
    Status.Position = UDim2.new(0, 0, 0, 20)
    Status.BackgroundTransparency = 1
    Status.TextColor3 = Color3.fromRGB(255, 255, 255)
    Status.Text = "Status: Initializing..."
    Status.Font = Enum.Font.SourceSans
    Status.TextSize = 14
    Status.TextXAlignment = Enum.TextXAlignment.Left
    Status.Parent = Frame
    
    Target.Size = UDim2.new(1, 0, 0, 20)
    Target.Position = UDim2.new(0, 0, 0, 40)
    Target.BackgroundTransparency = 1
    Target.TextColor3 = Color3.fromRGB(255, 255, 255)
    Target.Text = "Target: None"
    Target.Font = Enum.Font.SourceSans
    Target.TextSize = 14
    Target.TextXAlignment = Enum.TextXAlignment.Left
    Target.Parent = Frame
    
    Distance.Size = UDim2.new(1, 0, 0, 20)
    Distance.Position = UDim2.new(0, 0, 0, 60)
    Distance.BackgroundTransparency = 1
    Distance.TextColor3 = Color3.fromRGB(255, 255, 255)
    Distance.Text = "Distance: N/A"
    Distance.Font = Enum.Font.SourceSans
    Distance.TextSize = 14
    Distance.TextXAlignment = Enum.TextXAlignment.Left
    Distance.Parent = Frame
    
    CombatMode.Size = UDim2.new(1, 0, 0, 20)
    CombatMode.Position = UDim2.new(0, 0, 0, 80)
    CombatMode.BackgroundTransparency = 1
    CombatMode.TextColor3 = Color3.fromRGB(0, 255, 255)
    CombatMode.Text = "Combat: None"
    CombatMode.Font = Enum.Font.SourceSans
    CombatMode.TextSize = 14
    CombatMode.TextXAlignment = Enum.TextXAlignment.Left
    CombatMode.Parent = Frame
    
    local Debug = Instance.new("TextLabel")
    Debug.Size = UDim2.new(1, 0, 0, 20)
    Debug.Position = UDim2.new(0, 0, 0, 100)
    Debug.BackgroundTransparency = 1
    Debug.TextColor3 = Color3.fromRGB(255, 255, 0)
    Debug.Text = "Debug: Ready"
    Debug.Font = Enum.Font.SourceSans
    Debug.TextSize = 14
    Debug.TextXAlignment = Enum.TextXAlignment.Left
    Debug.Parent = Frame
    
    local statusInterface = {}
    
    function statusInterface.UpdateStatus(text)
        if Status then
            Status.Text = "Status: " .. text
        end
    end
    
    function statusInterface.UpdateTarget(text)
        if Target then
            Target.Text = "Target: " .. text
        end
    end
    
    function statusInterface.UpdateDistance(distance)
        if Distance then
            Distance.Text = "Distance: " .. (distance and string.format("%.1f", distance) or "N/A")
        end
    end
    
    function statusInterface.UpdateCombatMode(mode)
        if CombatMode then
            CombatMode.Text = "Combat: " .. mode
        end
    end
    
    function statusInterface.UpdateDebug(text)
        if Debug then
            Debug.Text = "Debug: " .. text
        end
    end
    
    return statusInterface
end

-- Smart pathfinding system
local function CreatePathfinder()
    local pathfinder = {}
    
    -- Improved void detection that's less paranoid
    function pathfinder.IsVoidArea(position, character)
        -- Less strict Y threshold check
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            return true
        end
        
        -- Check for immediate ground below (more lenient)
        local rayOrigin = position + Vector3.new(0, 2, 0)
        local rayDirection = Vector3.new(0, -10, 0) -- Shorter ray
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {character}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        
        local raycastResult = workspace:Raycast(rayOrigin, rayDirection, rayParams)
        return raycastResult == nil
    end
    
    -- Smart path assessment for bridges and narrow passages
    function pathfinder.FindSafePath(startPos, targetPos, character)
        local direction = (targetPos - startPos).Unit
        local distance = (targetPos - startPos).Magnitude
        
        -- Check for bridges by testing multiple points across potential gap
        local function IsBridgePresent(checkDistance)
            local checkPoint = startPos + direction * checkDistance
            
            -- Test multiple points across potential bridge width
            for offset = -CONFIG.BRIDGE_DETECTION_WIDTH, CONFIG.BRIDGE_DETECTION_WIDTH, 2 do
                local perpendicular = direction:Cross(Vector3.new(0, 1, 0)).Unit * offset
                local testPoint = checkPoint + perpendicular
                
                if not pathfinder.IsVoidArea(testPoint, character) then
                    return true -- Bridge detected
                end
            end
            return false
        end
        
        -- Check critical points along path
        local checkPoints = {5, 10, 15, 20, 25}
        
        for _, checkDist in ipairs(checkPoints) do
            if checkDist > distance then break end
            
            local checkPoint = startPos + direction * checkDist
            
            -- If this point is void, check if there's a bridge
            if pathfinder.IsVoidArea(checkPoint, character) then
                if not IsBridgePresent(checkDist) then
                    return false, "Unsafe path at distance " .. checkDist
                else
                    forcePrint("LinkedSwordAI: Bridge detected, proceeding safely")
                end
            end
        end
        
        return true, "Path clear"
    end
    
    -- Obstacle avoidance for narrow passages
    function pathfinder.AvoidObstacles(currentPos, targetPos, character)
        local direction = (targetPos - currentPos).Unit
        
        -- Check for immediate obstacles
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {character}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        
        local obstacleCheck = workspace:Raycast(currentPos, direction * CONFIG.OBSTACLE_AVOIDANCE_DISTANCE, rayParams)
        
        if obstacleCheck then
            -- Try alternative paths
            local alternatives = {
                direction:Cross(Vector3.new(0, 1, 0)), -- Left
                direction:Cross(Vector3.new(0, -1, 0)), -- Right
                (direction + Vector3.new(0, 0.3, 0)).Unit -- Upward
            }
            
            for _, altDir in ipairs(alternatives) do
                local altCheck = workspace:Raycast(currentPos, altDir * CONFIG.OBSTACLE_AVOIDANCE_DISTANCE, rayParams)
                if not altCheck then
                    forcePrint("LinkedSwordAI: Avoiding obstacle by moving " .. (altDir == alternatives[1] and "left" or altDir == alternatives[2] and "right" or "up"))
                    return currentPos + altDir * 3 -- Small adjustment
                end
            end
        end
        
        return targetPos -- No obstacles, proceed normally
    end
    
    return pathfinder
end

-- Professional combat system
local function CreateCombatManager()
    local combat = {}
    combat.CurrentMode = "Defensive"
    combat.LastModeChange = 0
    combat.StrafeDirection = 1 -- 1 for right, -1 for left
    
    -- Randomly select combat mode
    function combat.SelectCombatMode()
        local modes = {"Defensive", "Offensive", "Offensive-Defensive"}
        local weights = {0.4, 0.3, 0.3} -- Defensive slightly more common
        
        local random = math.random()
        local cumulative = 0
        
        for i, weight in ipairs(weights) do
            cumulative = cumulative + weight
            if random <= cumulative then
                combat.CurrentMode = modes[i]
                combat.LastModeChange = tick()
                return modes[i]
            end
        end
        
        combat.CurrentMode = "Defensive"
        combat.LastModeChange = tick()
        return "Defensive"
    end
    
    -- Execute behavior based on current combat mode
    function combat.ExecuteCombatBehavior(humanoid, targetPosition, currentPosition, distance, statusGUI)
        local currentTime = tick()
        
        -- Change mode periodically
        if currentTime - combat.LastModeChange > CONFIG.COMBAT_MODE_DURATION then
            local newMode = combat.SelectCombatMode()
            forcePrint("LinkedSwordAI: Switching to " .. newMode .. " combat mode")
            if statusGUI then
                statusGUI.UpdateCombatMode(newMode)
            end
        end
        
        -- Face the target naturally
        combat.FaceTarget(targetPosition, currentPosition, humanoid)
        
        -- Execute mode-specific behavior
        if combat.CurrentMode == "Defensive" then
            return combat.DefensiveBehavior(humanoid, targetPosition, distance)
        elseif combat.CurrentMode == "Offensive" then
            return combat.OffensiveBehavior(humanoid, targetPosition, distance)
        else -- Offensive-Defensive
            return combat.OffensiveDefensiveBehavior(humanoid, targetPosition, distance, currentTime)
        end
    end
    
    -- Natural target facing
    function combat.FaceTarget(targetPosition, currentPosition, humanoid)
        local lookVector = (targetPosition - currentPosition).Unit
        humanoid:MoveTo(currentPosition + lookVector * 0.1) -- Tiny movement to face direction
    end
    
    -- Defensive behavior: Wait and swing from distance
    function combat.DefensiveBehavior(humanoid, targetPosition, distance)
        if distance > CONFIG.STRAFING_RANGE then
            humanoid:MoveTo(targetPosition) -- Approach cautiously
        else
            humanoid:MoveTo(humanoid.Parent.HumanoidRootPart.Position) -- Stay in place
        end
        return "waiting" -- Don't attack immediately
    end
    
    -- Offensive behavior: Direct aggression
    function combat.OffensiveBehavior(humanoid, targetPosition, distance)
        if distance > CONFIG.AGGRESSIVE_CHARGE_DISTANCE then
            humanoid:MoveTo(targetPosition) -- Charge forward
        else
            -- Small movements to maintain optimal distance
            local direction = (targetPosition - humanoid.Parent.HumanoidRootPart.Position).Unit
            local optimalPosition = targetPosition - direction * 3
            humanoid:MoveTo(optimalPosition)
        end
        return "attack" -- Always try to attack
    end
    
    -- Offensive-Defensive behavior: Strafing and tactical movement
    function combat.OffensiveDefensiveBehavior(humanoid, targetPosition, distance, currentTime)
        local rootPart = humanoid.Parent.HumanoidRootPart
        local currentPos = rootPart.Position
        
        -- Change strafe direction periodically
        if math.random(1, 100) < 10 then -- 10% chance to change direction
            combat.StrafeDirection = -combat.StrafeDirection
        end
        
        if distance > CONFIG.STRAFING_RANGE then
            humanoid:MoveTo(targetPosition) -- Approach
        else
            -- Strafing movement
            local toTarget = (targetPosition - currentPos).Unit
            local strafeDir = toTarget:Cross(Vector3.new(0, 1, 0)).Unit * combat.StrafeDirection
            local strafePos = currentPos + strafeDir * 2 + toTarget * 1
            
            -- Occasionally retreat
            if math.random(1, 100) < 15 then -- 15% chance to retreat briefly
                strafePos = currentPos - toTarget * CONFIG.RETREAT_DISTANCE
                forcePrint("LinkedSwordAI: Tactical retreat")
            end
            
            humanoid:MoveTo(strafePos)
        end
        return "attack" -- Attack while moving
    end
    
    return combat
end

-- Main execution with professional systems
local function InitializeAI()
    forcePrint("LinkedSwordAI: Initializing professional AI...")
    
    -- Persistent data with new professional fields
    if not _G.LinkedSwordAIPersistentData then
        _G.LinkedSwordAIPersistentData = {
            StatusGUI = nil,
            LinkedSword = nil,
            SwordToolName = nil,
            CurrentTarget = nil,
            LastAttackTime = 0,
            LastRetargetTime = 0,
            LastSwordCheckTime = 0,
            StuckStartTime = 0,
            IsStuck = false,
            AttackSequenceActive = false,
            PlayersWithForceField = {},
            -- Professional fields
            Pathfinder = nil,
            CombatManager = nil,
            LastPathUpdate = 0,
            CurrentDestination = nil,
            IsEquipping = false,
            LastForceFieldCheck = 0
        }
    end
    
    local persistentData = _G.LinkedSwordAIPersistentData
    
    -- Initialize professional systems
    if not persistentData.Pathfinder then
        persistentData.Pathfinder = CreatePathfinder()
    end
    
    if not persistentData.CombatManager then
        persistentData.CombatManager = CreateCombatManager()
    end
    
    -- Create or reuse status GUI
    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
    end
    
    if persistentData.StatusGUI then
        persistentData.StatusGUI.UpdateStatus("Initializing...")
        persistentData.StatusGUI.UpdateDebug("Loading systems...")
    end
    
    -- Get necessary services
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local RunService = game:GetService("RunService")
    
    if not LocalPlayer then
        forcePrint("LinkedSwordAI: ERROR - LocalPlayer not found")
        return
    end
    
    -- Wait for character to load with proper timing
    local Character = LocalPlayer.Character
    if not Character then
        Character = LocalPlayer.CharacterAdded:Wait()
        wait(0.8) -- Wait for character to fully initialize
    end
    
    if not Character then
        forcePrint("LinkedSwordAI: ERROR - Character not found")
        return
    end
    
    local Humanoid = Character:WaitForChild("Humanoid", 5)
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart", 5)
    
    if not Humanoid or not HumanoidRootPart then
        forcePrint("LinkedSwordAI: ERROR - Humanoid or HumanoidRootPart not found")
        return
    end
    
    -- Enhanced sword equipping (unchanged from previous version)
    local function EquipLinkedSword()
        if persistentData.IsEquipping then return persistentData.LinkedSword end
        persistentData.IsEquipping = true
        
        wait(CONFIG.EQUIP_DELAY)
        
        local function FindLinkedSword()
            if persistentData.SwordToolName then
                local tool = Character:FindFirstChild(persistentData.SwordToolName)
                if tool and tool:IsA("Tool") then
                    forcePrint("LinkedSwordAI: Found sword: " .. tool.Name)
                    return tool
                end
            end
            
            for _, item in pairs(Character:GetChildren()) do
                if item:IsA("Tool") then
                    persistentData.SwordToolName = item.Name
                    return item
                end
            end
            
            local Backpack = LocalPlayer:FindFirstChild("Backpack")
            if Backpack then
                for _, item in pairs(Backpack:GetChildren()) do
                    if item:IsA("Tool") then
                        persistentData.SwordToolName = item.Name
                        local success = pcall(function() Humanoid:EquipTool(item) end)
                        if success then
                            wait(0.2)
                            local equippedTool = Character:FindFirstChild(item.Name)
                            if equippedTool then return equippedTool end
                        end
                        return item
                    end
                end
            end
            
            return nil
        end
        
        persistentData.LinkedSword = FindLinkedSword()
        persistentData.IsEquipping = false
        return persistentData.LinkedSword
    end
    
    local function CheckForSword()
        local currentTime = tick()
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            persistentData.LastSwordCheckTime = currentTime
            if not persistentData.LinkedSword or not persistentData.LinkedSword.Parent then
                return EquipLinkedSword()
            end
        end
        return persistentData.LinkedSword
    end
    
    -- Initial equipment
    spawn(function()
        wait(CONFIG.EQUIP_DELAY)
        EquipLinkedSword()
    end)
    
    -- Smart player detection (unchanged)
    local function FindPlayersInRange()
        local playersInRange = {}
        local playersWithFF = {}
        local currentTime = tick()
        local shouldUpdateFF = currentTime - persistentData.LastForceFieldCheck > 0.5
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                local humanoid = player.Character:FindFirstChild("Humanoid")
                
                if humanoidRootPart and humanoid and humanoid.Health > 0 then
                    local distance = (humanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                    
                    if distance <= CONFIG.MAX_TARGET_DISTANCE then
                        local hasForceField = false
                        if shouldUpdateFF then
                            hasForceField = player.Character:FindFirstChild("ForceField") ~= nil
                        else
                            hasForceField = persistentData.PlayersWithForceField[player] == true
                        end
                        
                        if hasForceField then
                            playersWithFF[player] = true
                        else
                            table.insert(playersInRange, {
                                Player = player,
                                Distance = distance,
                                HumanoidRootPart = humanoidRootPart
                            })
                        end
                    end
                end
            end
        end
        
        if shouldUpdateFF then
            persistentData.PlayersWithForceField = playersWithFF
            persistentData.LastForceFieldCheck = currentTime
        end
        
        table.sort(playersInRange, function(a, b) return a.Distance < b.Distance end)
        return playersInRange
    end
    
    -- Professional movement system
    local function SmartMoveTo(targetPosition)
        local currentTime = tick()
        if currentTime - persistentData.LastPathUpdate < CONFIG.PATH_REFRESH_RATE then
            return
        end
        
        persistentData.LastPathUpdate = currentTime
        
        -- Use smart pathfinding to check safety
        local isSafe, reason = persistentData.Pathfinder.FindSafePath(
            HumanoidRootPart.Position, 
            targetPosition, 
            Character
        )
        
        if isSafe then
            -- Avoid obstacles in narrow passages
            local finalPosition = persistentData.Pathfinder.AvoidObstacles(
                HumanoidRootPart.Position,
                targetPosition,
                Character
            )
            
            Humanoid:MoveTo(finalPosition)
            persistentData.CurrentDestination = finalPosition
        else
            forcePrint("LinkedSwordAI: Path unsafe - " .. reason)
            -- Try to find alternative path by moving to a safer position first
            local direction = (targetPosition - HumanoidRootPart.Position).Unit
            local safeRetreat = HumanoidRootPart.Position - direction * 5
            if not persistentData.Pathfinder.IsVoidArea(safeRetreat, Character) then
                Humanoid:MoveTo(safeRetreat)
            end
        end
    end
    
    -- Enhanced attack execution
    local function ExecuteAttack()
        if not persistentData.LinkedSword or persistentData.AttackSequenceActive then
            return
        end
        
        persistentData.AttackSequenceActive = true
        persistentData.LastAttackTime = tick()
        
        if persistentData.StatusGUI then
            persistentData.StatusGUI.UpdateStatus("Attacking")
        end
        
        local function PerformAttack(attackNumber)
            pcall(function() 
                if persistentData.LinkedSword and persistentData.LinkedSword.Parent then
                    persistentData.LinkedSword:Activate()
                end
            end)
        end
        
        spawn(function()
            PerformAttack(1)
            wait(CONFIG.LUNGE_DELAY)
            PerformAttack(2)
            wait(CONFIG.LUNGE_DELAY)
            PerformAttack(3)
            wait(0.1)
            persistentData.AttackSequenceActive = false
        end)
    end
    
    -- Forcefield handling (unchanged)
    local function HandleFleeFromForceField()
        local closestFFPlayer = nil
        local closestDistance = math.huge
        
        for player, _ in pairs(persistentData.PlayersWithForceField) do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (player.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestFFPlayer = player
                end
            end
        end
        
        if closestFFPlayer and closestFFPlayer.Character then
            local ffHRP = closestFFPlayer.Character.HumanoidRootPart
            if ffHRP and closestDistance < CONFIG.FORCEFIELD_FLEE_DISTANCE then
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Fleeing from FF")
                end
                
                local fleeDir = (HumanoidRootPart.Position - ffHRP.Position).Unit
                local fleePos = HumanoidRootPart.Position + fleeDir * 10
                
                if not persistentData.Pathfinder.IsVoidArea(fleePos, Character) then
                    Humanoid:MoveTo(fleePos)
                    return true
                end
            end
        end
        
        return false
    end
    
    -- Professional update loop
    local function Update()
        CheckForSword()
        
        if next(persistentData.PlayersWithForceField) ~= nil then
            if HandleFleeFromForceField() then return end
        end
        
        local playersInRange = FindPlayersInRange()
        local currentTime = tick()
        
        -- Target selection with smart pathfinding
        if #playersInRange > 0 and (not persistentData.CurrentTarget or 
           currentTime - persistentData.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME) then
            
            persistentData.LastRetargetTime = currentTime
            
            for _, playerData in ipairs(playersInRange) do
                local targetPlayer = playerData.Player
                local targetHRP = playerData.HumanoidRootPart
                
                local isSafe, reason = persistentData.Pathfinder.FindSafePath(
                    HumanoidRootPart.Position, 
                    targetHRP.Position, 
                    Character
                )
                
                if isSafe then
                    persistentData.CurrentTarget = targetPlayer
                    
                    if persistentData.StatusGUI then
                        persistentData.StatusGUI.UpdateTarget(targetPlayer.Name)
                        persistentData.StatusGUI.UpdateCombatMode("Selecting...")
                    end
                    
                    forcePrint("LinkedSwordAI: New target - " .. targetPlayer.Name)
                    persistentData.CombatManager.SelectCombatMode() -- Initialize combat mode
                    break
                else
                    forcePrint("LinkedSwordAI: Path to " .. targetPlayer.Name .. " unsafe - " .. reason)
                end
            end
        end
        
        -- Professional combat engagement
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character then
            local targetChar = persistentData.CurrentTarget.Character
            local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
            local targetHumanoid = targetChar:FindFirstChild("Humanoid")
            
            if targetHRP and targetHumanoid and targetHumanoid.Health > 0 then
                local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
                
                if persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateDistance(distance)
                end
                
                -- Execute professional combat behavior
                local combatAction = persistentData.CombatManager.ExecuteCombatBehavior(
                    Humanoid, 
                    targetHRP.Position, 
                    HumanoidRootPart.Position, 
                    distance, 
                    persistentData.StatusGUI
                )
                
                -- Attack based on combat behavior decision
                if combatAction == "attack" and distance <= CONFIG.ATTACK_RANGE and 
                   persistentData.LinkedSword and 
                   currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    ExecuteAttack()
                end
            else
                persistentData.CurrentTarget = nil
            end
        else
            persistentData.CurrentTarget = nil
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateTarget("None")
                persistentData.StatusGUI.UpdateCombatMode("None")
                persistentData.StatusGUI.UpdateStatus("Searching")
            end
        end
    end
    
    -- Main loop
    local updateConnection
    updateConnection = RunService.Heartbeat:Connect(function()
        local success, err = pcall(Update)
        if not success then
            forcePrint("LinkedSwordAI: Update error - " .. tostring(err))
        end
    end)
    
    -- Handle character death
    Humanoid.Died:Connect(function()
        forcePrint("LinkedSwordAI: Character died")
        if updateConnection then
            updateConnection:Disconnect()
        end
    end)
    
    forcePrint("LinkedSwordAI: Professional initialization complete")
    if persistentData.StatusGUI then
        persistentData.StatusGUI.UpdateStatus("Ready")
        persistentData.StatusGUI.UpdateDebug("Professional AI active")
    end
end

-- Enhanced respawn handling
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

if LocalPlayer then
    LocalPlayer.CharacterAdded:Connect(function(character)
        forcePrint("LinkedSwordAI: Character respawned, initializing...")
        wait(1.2) -- Increased wait for full character load
        InitializeAI()
    end)
end

-- Start the AI
local success, err = pcall(function()
    wait(1)
    InitializeAI()
end)

if not success then
    forcePrint("LinkedSwordAI: Failed to initialize - " .. tostring(err))
end

forcePrint("LinkedSwordAI: Professional script execution complete")
