-- LinkedSwordAI_VoidAware.lua
-- Fixed version that properly responds to void detection

local function forcePrint(...)
    local args = {...}
    local message = ""
    for i, v in ipairs(args) do
        message = message .. tostring(v) .. (i < #args and " " or "")
    end
    print("LinkedSwordAI: " .. message)
    warn("LinkedSwordAI: " .. message)
end

forcePrint("Starting void-aware version...")

-- Enhanced Configuration
local CONFIG = {
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.8,
    DETECTION_RANGE = 100,
    VOID_Y_LEVEL = -20,
    EQUIP_DELAY = 0.5,
    RETARGET_DELAY = 1,
    FORCEFIELD_FLEE_DISTANCE = 25,
    STUCK_CHECK_DISTANCE = 3,
    VOID_CHECK_DISTANCE = 10, -- How far ahead to check for voids
    VOID_RETREAT_DISTANCE = 8 -- How far to retreat from voids
}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

if not LocalPlayer then
    forcePrint("Error: No local player found")
    return
end

-- Simple GUI
local function CreateSimpleGUI()
    local success, gui = pcall(function()
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "LinkedSwordAI_GUI"
        ScreenGui.Parent = game:GetService("CoreGui")
        
        local Frame = Instance.new("Frame")
        Frame.Size = UDim2.new(0, 220, 0, 100)
        Frame.Position = UDim2.new(0, 10, 0, 10)
        Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        Frame.BackgroundTransparency = 0.7
        Frame.BorderSizePixel = 1
        
        local Status = Instance.new("TextLabel")
        Status.Size = UDim2.new(1, 0, 0, 20)
        Status.Position = UDim2.new(0, 0, 0, 0)
        Status.BackgroundTransparency = 1
        Status.TextColor3 = Color3.fromRGB(255, 255, 255)
        Status.Text = "Status: Loading..."
        Status.Font = Enum.Font.SourceSans
        Status.TextSize = 14
        Status.TextXAlignment = Enum.TextXAlignment.Left
        Status.Parent = Frame
        
        local Target = Instance.new("TextLabel")
        Target.Size = UDim2.new(1, 0, 0, 20)
        Target.Position = UDim2.new(0, 0, 0, 20)
        Target.BackgroundTransparency = 1
        Target.TextColor3 = Color3.fromRGB(255, 255, 255)
        Target.Text = "Target: None"
        Target.Font = Enum.Font.SourceSans
        Target.TextSize = 14
        Target.TextXAlignment = Enum.TextXAlignment.Left
        Target.Parent = Frame
        
        local Distance = Instance.new("TextLabel")
        Distance.Size = UDim2.new(1, 0, 0, 20)
        Distance.Position = UDim2.new(0, 0, 0, 40)
        Distance.BackgroundTransparency = 1
        Distance.TextColor3 = Color3.fromRGB(255, 255, 255)
        Distance.Text = "Distance: N/A"
        Distance.Font = Enum.Font.SourceSans
        Distance.TextSize = 14
        Distance.TextXAlignment = Enum.TextXAlignment.Left
        Distance.Parent = Frame
        
        local Void = Instance.new("TextLabel")
        Void.Size = UDim2.new(1, 0, 0, 20)
        Void.Position = UDim2.new(0, 0, 0, 60)
        Void.BackgroundTransparency = 1
        Void.TextColor3 = Color3.fromRGB(255, 100, 100)
        Void.Text = "Void: Safe"
        Void.Font = Enum.Font.SourceSans
        Void.TextSize = 14
        Void.TextXAlignment = Enum.TextXAlignment.Left
        Void.Parent = Frame
        
        Frame.Parent = ScreenGui
        
        return {
            UpdateStatus = function(text) Status.Text = "Status: " .. text end,
            UpdateTarget = function(text) Target.Text = "Target: " .. text end,
            UpdateDistance = function(text) Distance.Text = "Distance: " .. text end,
            UpdateVoid = function(text) Void.Text = "Void: " .. text end
        }
    end)
    
    return success and gui or nil
end

-- Enhanced void detection system
local function CreateVoidAwarenessSystem()
    local voidSystem = {}
    voidSystem.lastVoidCheck = 0
    voidSystem.voidAhead = false
    voidSystem.lastSafePosition = nil
    voidSystem.voidRetreatCooldown = 0
    
    -- Check if a position is safe (not void)
    function voidSystem.IsPositionSafe(position)
        -- Basic Y-level check
        if position.Y < CONFIG.VOID_Y_LEVEL then
            return false
        end
        
        -- Raycast down to check for ground
        local rayOrigin = position + Vector3.new(0, 2, 0)
        local rayDirection = Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0)
        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        
        local rayResult = workspace:Raycast(rayOrigin, rayDirection, rayParams)
        return rayResult ~= nil
    end
    
    -- Check the path ahead for voids
    function voidSystem.CheckPathAhead(currentPos, targetPos, character)
        local currentTime = tick()
        
        -- Only check periodically for performance
        if currentTime - voidSystem.lastVoidCheck < 0.2 then
            return voidSystem.voidAhead
        end
        
        voidSystem.lastVoidCheck = currentTime
        
        -- Get direction to target
        local direction = (targetPos - currentPos).Unit
        local distanceToTarget = (targetPos - currentPos).Magnitude
        
        -- Check multiple points along the path
        local checkDistance = math.min(distanceToTarget, CONFIG.VOID_CHECK_DISTANCE)
        local voidDetected = false
        
        for i = 5, checkDistance, 5 do
            local checkPoint = currentPos + (direction * i)
            
            if not voidSystem.IsPositionSafe(checkPoint) then
                voidDetected = true
                forcePrint("Void detected at distance: " .. i)
                break
            end
        end
        
        voidSystem.voidAhead = voidDetected
        
        -- Remember safe position if no void detected
        if not voidDetected then
            voidSystem.lastSafePosition = currentPos
        end
        
        return voidDetected
    end
    
    -- Handle void avoidance
    function voidSystem.AvoidVoid(humanoid, currentPos, targetPos, character, gui)
        local currentTime = tick()
        
        -- Check if we need to avoid a void
        if voidSystem.CheckPathAhead(currentPos, targetPos, character) then
            if gui then
                gui.UpdateVoid("DANGER AHEAD!")
            end
            
            -- Cooldown check to prevent rapid direction changes
            if currentTime - voidSystem.voidRetreatCooldown < 1 then
                return true -- Still in cooldown, continue avoiding
            end
            
            voidSystem.voidRetreatCooldown = currentTime
            
            -- Try different retreat directions
            local retreatDirections = {
                Vector3.new(-1, 0, 0),   -- Left
                Vector3.new(1, 0, 0),    -- Right
                Vector3.new(0, 0, -1),   -- Back
                Vector3.new(-0.7, 0, -0.7), -- Back-left
                Vector3.new(0.7, 0, -0.7),  -- Back-right
            }
            
            -- Try to find a safe retreat direction
            for _, dir in ipairs(retreatDirections) do
                local retreatPos = currentPos + (dir * CONFIG.VOID_RETREAT_DISTANCE)
                
                if voidSystem.IsPositionSafe(retreatPos) then
                    humanoid:MoveTo(retreatPos)
                    forcePrint("Avoiding void - moving to safe position")
                    return true
                end
            end
            
            -- If no safe direction found, try to go back to last safe position
            if voidSystem.lastSafePosition then
                humanoid:MoveTo(voidSystem.lastSafePosition)
                forcePrint("Retreating to last safe position")
                return true
            end
            
            -- Last resort: small random movement
            local randomDir = Vector3.new(math.random(-1, 1), 0, math.random(-1, 1)).Unit
            humanoid:MoveTo(currentPos + randomDir * 3)
            return true
        end
        
        if gui then
            gui.UpdateVoid("Safe")
        end
        
        return false -- No void detected
    end
    
    return voidSystem
end

-- Main AI function
local function InitializeAI()
    forcePrint("Initializing void-aware AI...")
    
    -- Persistent data
    if not _G.LinkedSwordAIData then
        _G.LinkedSwordAIData = {
            GUI = nil,
            Sword = nil,
            CurrentTarget = nil,
            LastAttack = 0,
            LastRetarget = 0,
            PlayersWithForceField = {},
            VoidSystem = nil
        }
    end
    
    local data = _G.LinkedSwordAIData
    
    -- Create GUI
    if not data.GUI then
        data.GUI = CreateSimpleGUI()
    end
    
    -- Initialize void system
    if not data.VoidSystem then
        data.VoidSystem = CreateVoidAwarenessSystem()
    end
    
    if data.GUI then
        data.GUI.UpdateStatus("Initializing...")
        data.GUI.UpdateVoid("Checking...")
    end
    
    -- Wait for character
    local character = LocalPlayer.Character
    if not character then
        forcePrint("Waiting for character...")
        character = LocalPlayer.CharacterAdded:Wait()
        wait(1) -- Wait for character to fully load
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    
    forcePrint("Character loaded successfully")
    
    -- Sword handling
    local function EquipSword()
        -- Check character first
        for _, item in pairs(character:GetChildren()) do
            if item:IsA("Tool") then
                data.Sword = item
                forcePrint("Found sword: " .. item.Name)
                return item
            end
        end
        
        -- Check backpack
        local backpack = LocalPlayer:FindFirstChild("Backpack")
        if backpack then
            for _, item in pairs(backpack:GetChildren()) do
                if item:IsA("Tool") then
                    -- Equip the tool
                    humanoid:EquipTool(item)
                    wait(0.2) -- Wait for equip to complete
                    data.Sword = character:FindFirstChild(item.Name) or item
                    forcePrint("Equipped sword: " .. item.Name)
                    return data.Sword
                end
            end
        end
        
        forcePrint("No sword found")
        return nil
    end
    
    -- Initial equip
    spawn(function()
        wait(CONFIG.EQUIP_DELAY)
        EquipSword()
    end)
    
    -- Player detection with forcefield check
    local function FindPlayersInRange()
        local playersInRange = {}
        local playersWithFF = {}
        local currentPos = rootPart.Position
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
                local targetHumanoid = player.Character:FindFirstChild("Humanoid")
                
                if targetRoot and targetHumanoid and targetHumanoid.Health > 0 then
                    local distance = (targetRoot.Position - currentPos).Magnitude
                    
                    if distance <= CONFIG.DETECTION_RANGE then
                        -- Check for forcefield
                        if player.Character:FindFirstChild("ForceField") then
                            playersWithFF[player] = true
                            forcePrint("Forcefield detected on: " .. player.Name)
                        else
                            table.insert(playersInRange, {
                                Player = player,
                                Distance = distance,
                                Position = targetRoot.Position,
                                Humanoid = targetHumanoid
                            })
                        end
                    end
                end
            end
        end
        
        data.PlayersWithForceField = playersWithFF
        
        -- Sort by distance
        table.sort(playersInRange, function(a, b)
            return a.Distance < b.Distance
        end)
        
        return playersInRange
    end
    
    -- Stuck detection (above players)
    local function CheckStuckAbovePlayer()
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
                if targetRoot then
                    local horizontalDist = (Vector3.new(rootPart.Position.X, 0, rootPart.Position.Z) - 
                                          Vector3.new(targetRoot.Position.X, 0, targetRoot.Position.Z)).Magnitude
                    local verticalDiff = rootPart.Position.Y - targetRoot.Position.Y
                    
                    if horizontalDist < CONFIG.STUCK_CHECK_DISTANCE and verticalDiff > 5 then
                        return true, player
                    end
                end
            end
        end
        return false, nil
    end
    
    -- Combat behaviors
    local combatBehaviors = {
        Defensive = function(targetPos, currentPos, distance)
            -- Stay back and wait for opportunities
            if distance > 10 then
                humanoid:MoveTo(targetPos)
            else
                -- Small strafing movements
                local lookVector = (targetPos - currentPos).Unit
                local strafeDir = lookVector:Cross(Vector3.new(0, 1, 0)).Unit
                humanoid:MoveTo(currentPos + strafeDir * 3)
            end
            return "Defensive"
        end,
        
        Offensive = function(targetPos, currentPos, distance)
            -- Aggressive approach
            humanoid:MoveTo(targetPos)
            return "Offensive"
        end
    }
    
    local lastBehaviorChange = 0
    local currentBehavior = "Defensive"
    
    local function SelectCombatBehavior(targetPos, currentPos, distance)
        -- Change behavior every 5 seconds
        if tick() - lastBehaviorChange > 5 then
            lastBehaviorChange = tick()
            currentBehavior = math.random() > 0.5 and "Defensive" or "Offensive"
            forcePrint("Switched to " .. currentBehavior .. " behavior")
        end
        
        return combatBehaviors[currentBehavior](targetPos, currentPos, distance)
    end
    
    -- Attack function
    local function ExecuteAttack()
        if not data.Sword or tick() - data.LastAttack < CONFIG.ATTACK_COOLDOWN then
            return
        end
        
        data.LastAttack = tick()
        
        spawn(function()
            for i = 1, 3 do
                pcall(function()
                    if data.Sword and data.Sword.Parent then
                        data.Sword:Activate()
                    end
                end)
                wait(0.1)
            end
        end)
    end
    
    -- Forcefield evasion
    local function HandleForceFieldEvasion()
        local closestFFPlayer = nil
        local closestDistance = math.huge
        
        for player, _ in pairs(data.PlayersWithForceField) do
            if player.Character then
                local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
                if targetRoot then
                    local distance = (targetRoot.Position - rootPart.Position).Magnitude
                    if distance < closestDistance then
                        closestDistance = distance
                        closestFFPlayer = player
                    end
                end
            end
        end
        
        if closestFFPlayer and closestDistance < CONFIG.FORCEFIELD_FLEE_DISTANCE then
            local fleeDir = (rootPart.Position - closestFFPlayer.Character.HumanoidRootPart.Position).Unit
            humanoid:MoveTo(rootPart.Position + fleeDir * 15)
            return true
        end
        
        return false
    end
    
    -- Main loop
    local connection
    connection = RunService.Heartbeat:Connect(function()
        -- Check if stuck above player first
        local isStuck, stuckPlayer = CheckStuckAbovePlayer()
        if isStuck then
            if data.GUI then 
                data.GUI.UpdateStatus("Unstucking")
                data.GUI.UpdateVoid("Stuck above player")
            end
            local moveDir = (rootPart.Position - stuckPlayer.Character.HumanoidRootPart.Position).Unit
            humanoid:MoveTo(rootPart.Position + moveDir * 8)
            return
        end
        
        -- Forcefield evasion
        if HandleForceFieldEvasion() then
            if data.GUI then 
                data.GUI.UpdateStatus("Evading ForceField")
                data.GUI.UpdateVoid("FF Evasion")
            end
            return
        end
        
        -- Find players
        local playersInRange = FindPlayersInRange()
        local currentTime = tick()
        
        -- Target selection
        if #playersInRange > 0 and (not data.CurrentTarget or 
           currentTime - data.LastRetarget > CONFIG.RETARGET_DELAY) then
            
            data.LastRetarget = currentTime
            data.CurrentTarget = playersInRange[1]
            
            if data.GUI then
                data.GUI.UpdateTarget(data.CurrentTarget.Player.Name)
            end
            forcePrint("New target: " .. data.CurrentTarget.Player.Name)
        end
        
        -- Target engagement
        if data.CurrentTarget then
            local targetData = data.CurrentTarget
            local targetChar = targetData.Player.Character
            
            if targetChar then
                local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
                local targetHumanoid = targetChar:FindFirstChild("Humanoid")
                
                if targetRoot and targetHumanoid and targetHumanoid.Health > 0 then
                    local distance = targetData.Distance
                    
                    if data.GUI then
                        data.GUI.UpdateDistance(math.floor(distance))
                    end
                    
                    -- VOID AVOIDANCE CHECK - THIS IS THE CRITICAL FIX
                    if data.VoidSystem.AvoidVoid(humanoid, rootPart.Position, targetRoot.Position, character, data.GUI) then
                        -- Void detected ahead, avoidance system is handling movement
                        if data.GUI then
                            data.GUI.UpdateStatus("Avoiding Void")
                        end
                        return -- Skip normal movement
                    end
                    
                    -- Face target properly
                    local lookVector = (targetRoot.Position - rootPart.Position).Unit
                    humanoid:MoveTo(rootPart.Position + lookVector * 0.5)
                    
                    -- Select and execute combat behavior (only if not avoiding void)
                    local behavior = SelectCombatBehavior(targetRoot.Position, rootPart.Position, distance)
                    
                    if data.GUI then
                        data.GUI.UpdateStatus(behavior)
                    end
                    
                    -- Attack if in range
                    if distance <= CONFIG.ATTACK_RANGE then
                        ExecuteAttack()
                    end
                else
                    data.CurrentTarget = nil
                    if data.GUI then
                        data.GUI.UpdateTarget("None")
                        data.GUI.UpdateStatus("Target Died")
                    end
                end
            else
                data.CurrentTarget = nil
                if data.GUI then
                    data.GUI.UpdateTarget("None")
                end
            end
        else
            data.CurrentTarget = nil
            if data.GUI then
                data.GUI.UpdateStatus("Searching")
                data.GUI.UpdateTarget("None")
                data.GUI.UpdateDistance("N/A")
                data.GUI.UpdateVoid("Safe")
            end
        end
    end)
    
    -- Handle character death
    humanoid.Died:Connect(function()
        forcePrint("Character died - cleaning up")
        if connection then
            connection:Disconnect()
        end
        if data.GUI then
            data.GUI.UpdateStatus("Dead")
        end
    end)
    
    if data.GUI then
        data.GUI.UpdateStatus("Active")
        data.GUI.UpdateVoid("Monitoring")
    end
    
    forcePrint("Void-aware AI system fully operational")
end

-- Respawn handling
LocalPlayer.CharacterAdded:Connect(function(character)
    forcePrint("Character respawned - reinitializing")
    wait(1.5) -- Wait for character to load
    InitializeAI()
end)

-- Start the AI
forcePrint("Starting AI in 3 seconds...")
wait(3)
InitializeAI()

forcePrint("Void-aware LinkedSwordAI fully loaded and running")
