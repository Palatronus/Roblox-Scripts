--[[
    Linked Sword AI Combat Script (Revised for External Executors)
    
    This script implements autonomous sword fighting AI for the Linked Sword tool in Roblox.
    Optimized specifically for external executor usage.
]]

-- Force print to output console immediately
local oldprint = print
print = function(...)
    oldprint(...)
    oldprint("") -- Force flush
end

-- Immediate console output
print("LinkedSwordAI: Script starting...")

-- Configuration
local CONFIG = {
    DETECTION_RADIUS = 100,        -- Increased from 15 to 100 for constant targeting
    ATTACK_RANGE = 15,             -- Start attacking when within this range
    ATTACK_COOLDOWN = 0.8,         -- Reduced from 1.2 for faster attacks
    LUNGE_DELAY = 0.1,             -- Delay between attacks for lunge combo
    STUCK_CHECK_DISTANCE = 1.5,    -- Distance to check if stuck on player
    STUCK_CHECK_TIME = 1.0,        -- Time to wait before considering stuck
    MAX_TARGET_DISTANCE = 150,     -- Increased from 20 to 150 for wider awareness
    MIN_HEALTH_CHECK = 0,
    RETARGET_CHECK_TIME = 1.0,     -- How often to check for closer targets
    VOID_CHECK_DISTANCE = 50,      -- Distance to check for void areas
    VOID_Y_THRESHOLD = -100,       -- Y position threshold for void detection
    FORCEFIELD_FLEE_DISTANCE = 30, -- Distance to flee from players with ForceField
    SWORD_CHECK_INTERVAL = 5       -- How often to check for sword (seconds)
}

-- Create status indicator GUI
local function CreateStatusGUI()
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "LinkedSwordAI_Status"
    
    -- Try different parent options that work with various executors
    local success = pcall(function()
        ScreenGui.Parent = game:GetService("CoreGui")
    end)
    
    if not success then
        success = pcall(function()
            ScreenGui.Parent = game:GetService("Players").LocalPlayer.PlayerGui
        end)
    end
    
    if not success then
        print("LinkedSwordAI: Failed to create status GUI")
        return nil
    end
    
    local Frame = Instance.new("Frame")
    Frame.Size = UDim2.new(0, 200, 0, 100)
    Frame.Position = UDim2.new(1, -220, 0, 20)
    Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Frame.BackgroundTransparency = 0.5
    Frame.BorderSizePixel = 2
    Frame.Parent = ScreenGui
    
    local Title = Instance.new("TextLabel")
    Title.Size = UDim2.new(1, 0, 0, 20)
    Title.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.Text = "Linked Sword AI"
    Title.Font = Enum.Font.SourceSansBold
    Title.TextSize = 14
    Title.Parent = Frame
    
    local Status = Instance.new("TextLabel")
    Status.Size = UDim2.new(1, 0, 1, -20)
    Status.Position = UDim2.new(0, 0, 0, 20)
    Status.BackgroundTransparency = 1
    Status.TextColor3 = Color3.fromRGB(255, 255, 255)
    Status.Text = "Initializing..."
    Status.Font = Enum.Font.SourceSans
    Status.TextSize = 14
    Status.TextXAlignment = Enum.TextXAlignment.Left
    Status.TextYAlignment = Enum.TextYAlignment.Top
    Status.Parent = Frame
    
    return {
        ScreenGui = ScreenGui,
        Frame = Frame,
        Status = Status,
        UpdateStatus = function(text)
            Status.Text = text
        end
    }
end

-- Variables that need to persist through respawns
local persistentData = {
    StatusGUI = nil,
    LinkedSword = nil,
    CurrentTarget = nil,
    LastAttackTime = 0,
    LastRetargetTime = 0,
    StuckStartTime = 0,
    IsStuck = false,
    AttackSequenceActive = false,
    SwordToolName = nil,         -- Store the sword's name for respawn persistence
    LastSwordCheckTime = 0,      -- Track when we last checked for the sword
    KnownVoidAreas = {},         -- Store coordinates of known void areas
    PlayersWithForceField = {}   -- Track players with ForceField
}

-- Main execution in protected call
local function InitializeAI()
    -- Services
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    
    -- Get player and character
    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        print("LinkedSwordAI: LocalPlayer not found")
        return false
    end
    
    print("LinkedSwordAI: LocalPlayer found - " .. LocalPlayer.Name)
    
    local Character = LocalPlayer.Character
    if not Character then
        print("LinkedSwordAI: Character not found")
        return false
    end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    
    if not Humanoid or not HumanoidRootPart then
        print("LinkedSwordAI: Humanoid or HumanoidRootPart not found")
        return false
    end
    
    print("LinkedSwordAI: Character components found")
    
    -- Create status GUI if it doesn't exist
    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
        if not persistentData.StatusGUI then
            print("LinkedSwordAI: Failed to create status GUI")
        else
            print("LinkedSwordAI: Status GUI created")
        end
    end
    
    -- Find the Linked Sword tool
    local function FindLinkedSword()
        -- First check if we have a stored sword name and try to find that specific sword
        if persistentData.SwordToolName then
            -- Check character for the specific sword
            local storedSword = Character:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found stored sword: " .. storedSword.Name) 
                end
                print("LinkedSwordAI: Found stored sword - " .. storedSword.Name)
                return storedSword
            end
            
            -- Check backpack for the specific sword
            storedSword = LocalPlayer.Backpack:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found stored sword in backpack: " .. storedSword.Name) 
                end
                print("LinkedSwordAI: Found stored sword in backpack - " .. storedSword.Name)
                return storedSword
            end
        end
        
        -- If we couldn't find the stored sword, look for any sword
        for _, tool in pairs(Character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                -- Store the sword name for future reference
                persistentData.SwordToolName = tool.Name
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found new sword: " .. tool.Name) 
                end
                print("LinkedSwordAI: Found new sword - " .. tool.Name)
                return tool
            end
        end
        
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                -- Store the sword name for future reference
                persistentData.SwordToolName = tool.Name
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found new sword in backpack: " .. tool.Name) 
                end
                print("LinkedSwordAI: Found new sword in backpack - " .. tool.Name)
                return tool
            end
        end
        
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("No sword found") end
        print("LinkedSwordAI: No sword found")
        return nil
    end
    
    -- Check for sword periodically
    local function CheckForSword()
        local currentTime = tick()
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword = FindLinkedSword()
            end
            persistentData.LastSwordCheckTime = currentTime
        end
    end
    
    -- Check if a position is in a void area
    local function IsVoidArea(position)
        -- Check if position is below the void threshold
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            return true
        end
        
        -- Check if position is in a known void area
        for _, voidArea in ipairs(persistentData.KnownVoidAreas) do
            local distance = (position - voidArea).Magnitude
            if distance < 10 then -- Within 10 studs of a known void area
                return true
            end
        end
        
        -- Cast a ray downward to check if there's ground below
        local rayOrigin = position
        local rayDirection = Vector3.new(0, -100, 0) -- Cast 100 studs down
        
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        raycastParams.FilterDescendantsInstances = {Character}
        
        local raycastResult = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)
        
        -- If no hit, it's likely a void
        if not raycastResult then
            -- Add to known void areas
            table.insert(persistentData.KnownVoidAreas, position)
            return true
        end
        
        return false
    end
    
    -- Find all valid players within range
    local function FindPlayersInRange()
        local playersInRange = {}
        persistentData.PlayersWithForceField = {} -- Reset ForceField tracking
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local distance = (player.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                    
                    if distance <= CONFIG.MAX_TARGET_DISTANCE then
                        -- Check for god mode
                        local playerHumanoid = player.Character:FindFirstChild("Humanoid")
                        if playerHumanoid and playerHumanoid.Health > CONFIG.MIN_HEALTH_CHECK then
                            -- Check for ForceField
                            local hasForceField = player.Character:FindFirstChild("ForceField") ~= nil
                            
                            if hasForceField then
                                -- Track players with ForceField
                                persistentData.PlayersWithForceField[player.Name] = player
                            end
                            
                            table.insert(playersInRange, {
                                player = player,
                                distance = distance,
                                hasForceField = hasForceField
                            })
                        end
                    end
                end
            end
        end
        
        -- Sort by distance
        table.sort(playersInRange, function(a, b)
            return a.distance < b.distance
        end)
        
        return playersInRange
    end
    
    -- Check if we're stuck on top of a player
    local function CheckIfStuck()
        if not persistentData.CurrentTarget or not persistentData.CurrentTarget.Character then
            return false
        end
        
        local targetHRP = persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        if not targetHRP then return false end
        
        -- Check if we're very close to the target and above them
        local horizontalDist = math.sqrt(
            (HumanoidRootPart.Position.X - targetHRP.Position.X)^2 + 
            (HumanoidRootPart.Position.Z - targetHRP.Position.Z)^2
        )
        
        local verticalDist = HumanoidRootPart.Position.Y - targetHRP.Position.Y
        
        if horizontalDist < CONFIG.STUCK_CHECK_DISTANCE and verticalDist > 1 then
            if persistentData.StuckStartTime == 0 then
                persistentData.StuckStartTime = tick()
            elseif tick() - persistentData.StuckStartTime > CONFIG.STUCK_CHECK_TIME then
                return true
            end
        else
            persistentData.StuckStartTime = 0
        end
        
        return false
    end
    
    -- Handle being stuck on a player
    local function HandleStuckOnPlayer()
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Stuck on player! Moving away...") end
        
        -- Move away from the target
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character then
            local targetHRP = persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
            if targetHRP then
                -- Move in the opposite direction
                local moveDir = (HumanoidRootPart.Position - targetHRP.Position).Unit
                local movePos = HumanoidRootPart.Position + moveDir * 10
                movePos = Vector3.new(movePos.X, targetHRP.Position.Y, movePos.Z)
                
                -- Check if the move position is safe (not a void)
                if not IsVoidArea(movePos) then
                    Humanoid:MoveTo(movePos)
                else
                    -- Find a safe direction to move
                    for angle = 0, 359, 45 do
                        local radians = math.rad(angle)
                        local direction = Vector3.new(math.cos(radians), 0, math.sin(radians))
                        local testPos = HumanoidRootPart.Position + direction * 10
                        
                        if not IsVoidArea(testPos) then
                            Humanoid:MoveTo(testPos)
                            break
                        end
                    end
                end
            end
        end
        
        persistentData.IsStuck = true
        return true
    end
    
    -- Handle fleeing from players with ForceField
    local function HandleFleeFromForceField()
        -- Find the closest player with ForceField
        local closestFFPlayer = nil
        local closestDistance = math.huge
        
        for _, player in pairs(persistentData.PlayersWithForceField) do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (player.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestFFPlayer = player
                end
            end
        end
        
        if closestFFPlayer and closestFFPlayer.Character then
            local ffHRP = closestFFPlayer.Character:FindFirstChild("HumanoidRootPart")
            if ffHRP then
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Fleeing from " .. closestFFPlayer.Name .. " (ForceField)") 
                end
                
                -- Move in the opposite direction
                local fleeDir = (HumanoidRootPart.Position - ffHRP.Position).Unit
                local fleePos = HumanoidRootPart.Position + fleeDir * CONFIG.FORCEFIELD_FLEE_DISTANCE
                
                -- Check if the flee position is safe (not a void)
                if not IsVoidArea(fleePos) then
                    Humanoid:MoveTo(fleePos)
                else
                    -- Find a safe direction to flee
                    for angle = 0, 359, 45 do
                        local radians = math.rad(angle)
                        local direction = Vector3.new(math.cos(radians), 0, math.sin(radians))
                        local testPos = HumanoidRootPart.Position + direction * CONFIG.FORCEFIELD_FLEE_DISTANCE
                        
                        if not IsVoidArea(testPos) then
                            Humanoid:MoveTo(testPos)
                            break
                        end
                    end
                end
                
                return true
            end
        end
        
        return false
    end
    
    -- Check if a path to target is safe (no voids)
    local function IsSafePath(targetPosition)
        -- Check if the target position itself is in a void
        if IsVoidArea(targetPosition) then
            return false
        end
        
        -- Check points along the path
        local direction = (targetPosition - HumanoidRootPart.Position)
        local distance = direction.Magnitude
        direction = direction.Unit
        
        -- Check several points along the path
        local checkPoints = math.min(5, math.floor(distance / 10))
        for i = 1, checkPoints do
            local checkPoint = HumanoidRootPart.Position + direction * (distance * (i / checkPoints))
            if IsVoidArea(checkPoint) then
                return false
            end
        end
        
        return true
    end
    
    -- Execute attack with the Linked Sword - now with lunge combo
    local function ExecuteAttack()
        if persistentData.AttackSequenceActive then return end
        
        CheckForSword() -- Make sure we have a sword
        
        if not persistentData.LinkedSword then
            return
        end
        
        -- Equip the sword if it's not already equipped
        if persistentData.LinkedSword.Parent ~= Character then
            persistentData.LinkedSword.Parent = Character
        end
        
        -- Start attack sequence
        persistentData.AttackSequenceActive = true
        
        -- First attack
        persistentData.LinkedSword:Activate()
        
        -- Schedule follow-up attacks for lunge combo
        spawn(function()
            wait(CONFIG.LUNGE_DELAY)
            if persistentData.LinkedSword and persistentData.LinkedSword.Parent == Character then
                persistentData.LinkedSword:Activate()
                
                wait(CONFIG.LUNGE_DELAY)
                if persistentData.LinkedSword and persistentData.LinkedSword.Parent == Character then
                    persistentData.LinkedSword:Activate()
                    
                    -- Reset attack sequence
                    persistentData.LastAttackTime = tick()
                    persistentData.AttackSequenceActive = false
                end
            end
        end)
        
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Attacking with combo!") end
    end
    
    -- Main update function
    local function Update()
        -- Check for sword periodically
        CheckForSword()
        
        -- Check if we need to find a new target or check for closer targets
        local currentTime = tick()
        local needNewTarget = not persistentData.CurrentTarget or 
                             not persistentData.CurrentTarget.Character or 
                             not persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        
        local checkForCloserTarget = currentTime - persistentData.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME
        
        if needNewTarget or checkForCloserTarget then
            local playersInRange = FindPlayersInRange()
            
            -- Check if we need to flee from any players with ForceField
            if next(persistentData.PlayersWithForceField) ~= nil then
                if HandleFleeFromForceField() then
                    return -- Skip the rest of the update if we're fleeing
                end
            end
            
            if #playersInRange > 0 then
                -- Filter out players with ForceField for targeting
                local validTargets = {}
                for _, playerInfo in ipairs(playersInRange) do
                    if not playerInfo.hasForceField then
                        table.insert(validTargets, playerInfo)
                    end
                end
                
                if #validTargets > 0 then
                    -- If we already have a target, check if there's someone closer
                    if persistentData.CurrentTarget and not needNewTarget then
                        local closestPlayer = validTargets[1].player
                        
                        if closestPlayer ~= persistentData.CurrentTarget then
                            if validTargets[1].distance < CONFIG.DETECTION_RADIUS then
                                persistentData.CurrentTarget = closestPlayer
                                if persistentData.StatusGUI then 
                                    persistentData.StatusGUI.UpdateStatus("New closer target: " .. persistentData.CurrentTarget.Name)
                                end
                                print("LinkedSwordAI: Switching to closer target - " .. persistentData.CurrentTarget.Name)
                            end
                        end
                    else
                        -- No current target, take the closest one
                        persistentData.CurrentTarget = validTargets[1].player
                        if persistentData.StatusGUI then 
                            persistentData.StatusGUI.UpdateStatus("Target: " .. persistentData.CurrentTarget.Name)
                        end
                        print("LinkedSwordAI: New target - " .. persistentData.CurrentTarget.Name)
                    end
                else
                    if persistentData.StatusGUI then 
                        persistentData.StatusGUI.UpdateStatus("No valid targets (all have ForceField)")
                    end
                    persistentData.CurrentTarget = nil
                end
            else
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("No targets in range")
                end
                persistentData.CurrentTarget = nil
            end
            
            persistentData.LastRetargetTime = currentTime
        end
        
        -- If we have a target, execute AI behavior
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetHRP = persistentData.CurrentTarget.Character.HumanoidRootPart
            local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
            
            -- Check if we're stuck on a player
            if CheckIfStuck() then
                HandleStuckOnPlayer()
                return
            else
                persistentData.IsStuck = false
            end
            
            -- Check if the path to the target is safe
            if IsSafePath(targetHRP.Position) then
                -- Move toward target
                Humanoid:MoveTo(targetHRP.Position)
                
                -- Face the target
                HumanoidRootPart.CFrame = CFrame.lookAt(
                    HumanoidRootPart.Position, 
                    Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
                )
                
                -- Attack if within range and cooldown expired
                if distance < CONFIG.ATTACK_RANGE and currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    ExecuteAttack()
                end
                
                -- Update status with distance
                if persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateStatus("Target: " .. persistentData.CurrentTarget.Name .. 
                                              "\nDistance: " .. math.floor(distance) .. 
                                              "\nStatus: " .. (persistentData.IsStuck and "Unstucking" or 
                                                             (persistentData.AttackSequenceActive and "Attacking" or "Chasing")))
                end
            else
                -- Path is not safe, find a different target
                if persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateStatus("Unsafe path to " .. persistentData.CurrentTarget.Name .. ", finding new target")
                end
                persistentData.CurrentTarget = nil
            end
        end
    end
    
    -- Initialize
    persistentData.LinkedSword = FindLinkedSword()
    persistentData.LastSwordCheckTime = tick()
    
    -- Connect update function
    local updateConnection
    updateConnection = RunService.Heartbeat:Connect(function()
        local success, error = pcall(Update)
        if not success then
            print("LinkedSwordAI: Error in update - " .. tostring(error))
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Error: " .. tostring(error)) end
        end
    end)
    
    -- Handle character respawn
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        print("LinkedSwordAI: Character respawned, reinitializing...")
        wait(1) -- Wait for character to fully load
        InitializeAI()
    end)
    
    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("AI Running") end
    print("LinkedSwordAI: Script initialized successfully")
    
    return true
end

-- Start the AI
local success, errorMsg = pcall(InitializeAI)

if not success then
    print("LinkedSwordAI: Critical error - " .. tostring(errorMsg))
end
