-- LinkedSwordAI_Optimized.lua
-- Optimized version with robust navigation and performance improvements

-- Force print function to ensure output is visible
local function forcePrint(...)
    local args = {...}
    local message = ""
    for i, v in ipairs(args) do
        message = message .. tostring(v) .. (i < #args and " " or "")
    end
    
    print(message)
    warn(message)
    pcall(function() rconsoleprint(message .. "\n") end)
end

forcePrint("LinkedSwordAI: Optimized script starting...")

-- Optimized Configuration
local CONFIG = {
    DETECTION_RADIUS = 100,
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.8,
    LUNGE_DELAY = 0.1,
    MAX_TARGET_DISTANCE = 150,
    RETARGET_CHECK_TIME = 1.0,
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -20, -- More conservative threshold
    FORCEFIELD_FLEE_DISTANCE = 30,
    SWORD_CHECK_INTERVAL = 5,
    EQUIP_DELAY = 1.0,
    PATH_REFRESH_RATE = 0.5, -- Reduced frequency for performance
    NAVIGATION_UPDATE_INTERVAL = 0.3,
    WAYPOINT_DISTANCE = 8,
    HILL_NAVIGATION_ANGLE = 35 -- Degrees for hill climbing
}

-- Lightweight status GUI
local function CreateStatusGUI()
    local success, ScreenGui = pcall(function()
        local gui = Instance.new("ScreenGui")
        gui.Name = "LinkedSwordAI_Optimized"
        gui.Parent = game:GetService("CoreGui")
        return gui
    end)
    
    if not success then return nil end
    
    local Frame = Instance.new("Frame")
    Frame.Size = UDim2.new(0, 200, 0, 80)
    Frame.Position = UDim2.new(0, 10, 0, 10)
    Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Frame.BackgroundTransparency = 0.5
    Frame.BorderSizePixel = 2
    Frame.Parent = ScreenGui
    
    local labels = {}
    local labelNames = {"Status", "Target", "Distance", "Navigation"}
    
    for i, name in ipairs(labelNames) do
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 0, 20)
        label.Position = UDim2.new(0, 0, 0, (i-1)*20)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(255, 255, 255)
        label.Text = name .. ": N/A"
        label.Font = Enum.Font.SourceSans
        label.TextSize = 12
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = Frame
        labels[name] = label
    end
    
    local statusInterface = {}
    for name, label in pairs(labels) do
        statusInterface["Update" .. name] = function(text)
            if label then
                label.Text = name .. ": " .. (text or "N/A")
            end
        end
    end
    
    return statusInterface
end

-- Robust navigation system for Heights map
local function CreateNavigationSystem()
    local nav = {}
    nav.LastNavigationUpdate = 0
    nav.CurrentWaypoint = nil
    nav.AlternativeRouteActive = false
    nav.KnownSafePaths = {}
    
    -- Performance-optimized void detection
    function nav.IsPositionSafe(position, character)
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            return false, "below threshold"
        end
        
        -- Quick ground check
        local rayOrigin = position + Vector3.new(0, 2, 0)
        local rayDirection = Vector3.new(0, -15, 0)
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {character}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        
        local result = workspace:Raycast(rayOrigin, rayDirection, rayParams)
        if not result then
            return false, "no ground"
        end
        
        return true, "safe"
    end
    
    -- Height map navigation for hill and bridge areas
    function nav.FindSafePathToTarget(startPos, targetPos, character)
        local direction = (targetPos - startPos).Unit
        local distance = (targetPos - startPos).Magnitude
        
        -- Check immediate path
        local immediateCheck = startPos + direction * math.min(10, distance)
        local isSafe, reason = nav.IsPositionSafe(immediateCheck, character)
        
        if not isSafe then
            -- Try alternative routes for Heights map
            return nav.FindAlternativeRoute(startPos, targetPos, character)
        end
        
        -- Check intermediate points (reduced frequency for performance)
        for i = 15, math.min(distance, 50), 15 do
            local checkPoint = startPos + direction * i
            isSafe, reason = nav.IsPositionSafe(checkPoint, character)
            
            if not isSafe then
                return nav.FindAlternativeRoute(startPos, targetPos, character)
            end
        end
        
        return targetPos, "direct"
    end
    
    -- Alternative route finding for Heights map
    function nav.FindAlternativeRoute(startPos, targetPos, character)
        local direction = (targetPos - startPos).Unit
        local distance = (targetPos - startPos).Magnitude
        
        -- Strategy 1: Hill navigation (go around through interior)
        local hillRoute = nav.AttemptHillNavigation(startPos, targetPos, character)
        if hillRoute then
            return hillRoute, "hill route"
        end
        
        -- Strategy 2: Bridge detection and navigation
        local bridgeRoute = nav.AttemptBridgeNavigation(startPos, targetPos, character)
        if bridgeRoute then
            return bridgeRoute, "bridge route"
        end
        
        -- Strategy 3: Conservative approach (don't fall)
        local safeRetreat = startPos - direction * 5
        if nav.IsPositionSafe(safeRetreat, character) then
            return safeRetreat, "safe retreat"
        end
        
        -- Last resort: Stay put
        return startPos, "no safe path"
    end
    
    -- Hill navigation for accessing bridge through interior
    function nav.AttemptHillNavigation(startPos, targetPos, character)
        local direction = (targetPos - startPos).Unit
        local horizontalDir = Vector3.new(direction.X, 0, direction.Z).Unit
        
        -- Try angled approach for hills
        local hillAngles = {30, -30, 45, -45} -- Degrees
        
        for _, angle in ipairs(hillAngles) do
            local radians = math.rad(angle)
            local hillDir = horizontalDir * math.cos(radians) + Vector3.new(0, math.sin(radians), 0)
            local testPos = startPos + hillDir * 12
            
            if nav.IsPositionSafe(testPos, character) then
                return testPos
            end
        end
        
        return nil
    end
    
    -- Bridge navigation detection
    function nav.AttemptBridgeNavigation(startPos, targetPos, character)
        local direction = (targetPos - startPos).Unit
        local horizontalDir = Vector3.new(direction.X, 0, direction.Z).Unit
        
        -- Check for bridge by testing elevated path
        local elevatedPos = startPos + Vector3.new(0, 5, 0) + horizontalDir * 15
        if nav.IsPositionSafe(elevatedPos, character) then
            return elevatedPos
        end
        
        -- Check side paths (common in Heights map)
        local sideDirs = {
            horizontalDir:Cross(Vector3.new(0, 1, 0)), -- Left
            horizontalDir:Cross(Vector3.new(0, -1, 0)) -- Right
        }
        
        for _, sideDir in ipairs(sideDirs) do
            local sidePos = startPos + sideDir * 8 + horizontalDir * 10
            if nav.IsPositionSafe(sidePos, character) then
                return sidePos
            end
        end
        
        return nil
    end
    
    -- Performance-optimized navigation update
    function nav.UpdateNavigation(humanoid, targetPos, currentPos, character, statusGUI)
        local currentTime = tick()
        
        -- Throttle navigation updates for performance
        if currentTime - nav.LastNavigationUpdate < CONFIG.NAVIGATION_UPDATE_INTERVAL then
            return nav.CurrentWaypoint or currentPos
        end
        
        nav.LastNavigationUpdate = currentTime
        
        local safeTarget, pathType = nav.FindSafePathToTarget(currentPos, targetPos, character)
        
        if statusGUI then
            statusGUI.UpdateNavigation(pathType)
        end
        
        nav.CurrentWaypoint = safeTarget
        return safeTarget
    end
    
    return nav
end

-- Optimized combat system
local function CreateCombatManager()
    local combat = {}
    combat.LastCombatUpdate = 0
    combat.CurrentMode = "Balanced"
    
    function combat.UpdateCombat(humanoid, targetPos, currentPos, distance, statusGUI)
        local currentTime = tick()
        
        -- Reduced update frequency for performance
        if currentTime - combat.LastCombatUpdate < 0.5 then
            return combat.CurrentMode
        end
        
        combat.LastCombatUpdate = currentTime
        
        -- Simple mode selection based on distance
        if distance > 20 then
            combat.CurrentMode = "Approaching"
        elseif distance > 8 then
            combat.CurrentMode = "Balanced"
        else
            combat.CurrentMode = "Aggressive"
        end
        
        if statusGUI then
            statusGUI.UpdateStatus(combat.CurrentMode)
        end
        
        return combat.CurrentMode
    end
    
    function combat.ExecuteCombatBehavior(humanoid, targetPos, currentPos, distance, mode)
        -- Face target
        local lookVector = (targetPos - currentPos).Unit
        humanoid:MoveTo(currentPos + lookVector * 0.1)
        
        -- Mode-based behavior
        if mode == "Approaching" then
            humanoid:MoveTo(targetPos)
        elseif mode == "Balanced" then
            -- Small strafing movements
            local strafeDir = lookVector:Cross(Vector3.new(0, 1, 0)).Unit * (tick() % 2 > 1 and 1 or -1)
            humanoid:MoveTo(currentPos + strafeDir * 2 + lookVector * 1)
        else -- Aggressive
            humanoid:MoveTo(targetPos)
        end
    end
    
    return combat
end

-- Main optimized execution
local function InitializeAI()
    forcePrint("LinkedSwordAI: Initializing optimized AI...")
    
    -- Minimal persistent data
    if not _G.LinkedSwordAIData then
        _G.LinkedSwordAIData = {
            StatusGUI = nil,
            LinkedSword = nil,
            CurrentTarget = nil,
            LastAttackTime = 0,
            LastRetargetTime = 0,
            Navigation = nil,
            Combat = nil,
            LastCleanup = tick()
        }
    end
    
    local data = _G.LinkedSwordAIData
    
    -- Initialize systems
    if not data.Navigation then
        data.Navigation = CreateNavigationSystem()
    end
    
    if not data.Combat then
        data.Combat = CreateCombatManager()
    end
    
    if not data.StatusGUI then
        data.StatusGUI = CreateStatusGUI()
    end
    
    if data.StatusGUI then
        data.StatusGUI.UpdateStatus("Initializing")
    end
    
    -- Get services
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local RunService = game:GetService("RunService")
    
    if not LocalPlayer then return end
    
    -- Wait for character
    local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    wait(0.5) -- Reduced wait time
    
    local Humanoid = Character:WaitForChild("Humanoid", 3)
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart", 3)
    
    if not Humanoid or not HumanoidRootPart then return end
    
    -- Optimized sword equipping
    local function EquipSword()
        local function FindSword()
            for _, item in pairs(Character:GetChildren()) do
                if item:IsA("Tool") then
                    data.LinkedSword = item
                    return item
                end
            end
            
            local Backpack = LocalPlayer:FindFirstChild("Backpack")
            if Backpack then
                for _, item in pairs(Backpack:GetChildren()) do
                    if item:IsA("Tool") then
                        pcall(function() Humanoid:EquipTool(item) end)
                        wait(0.2)
                        data.LinkedSword = Character:FindFirstChild(item.Name) or item
                        return data.LinkedSword
                    end
                end
            end
            
            return nil
        end
        
        wait(CONFIG.EQUIP_DELAY)
        return FindSword()
    end
    
    -- Initial equip
    spawn(EquipSword)
    
    -- Performance-optimized player finding
    local function FindPlayersInRange()
        local playersInRange = {}
        local currentPos = HumanoidRootPart.Position
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                local hum = player.Character:FindFirstChild("Humanoid")
                
                if hrp and hum and hum.Health > 0 then
                    local distance = (hrp.Position - currentPos).Magnitude
                    
                    if distance <= CONFIG.MAX_TARGET_DISTANCE then
                        -- Skip forcefield check for performance (assume no forcefield)
                        table.insert(playersInRange, {
                            Player = player,
                            Distance = distance,
                            Position = hrp.Position
                        })
                    end
                end
            end
        end
        
        table.sort(playersInRange, function(a, b)
            return a.Distance < b.Distance
        end)
        
        return playersInRange
    end
    
    -- Optimized attack function
    local function ExecuteAttack()
        if not data.LinkedSword or tick() - data.LastAttackTime < CONFIG.ATTACK_COOLDOWN then
            return
        end
        
        data.LastAttackTime = tick()
        
        spawn(function()
            for i = 1, 3 do
                pcall(function() 
                    if data.LinkedSword and data.LinkedSword.Parent then
                        data.LinkedSword:Activate()
                    end
                end)
                wait(CONFIG.LUNGE_DELAY)
            end
        end)
    end
    
    -- Performance-optimized cleanup
    local function PerformCleanup()
        local currentTime = tick()
        if currentTime - data.LastCleanup > 10 then -- Cleanup every 10 seconds
            data.LastCleanup = currentTime
            collectgarbage("step") -- Minimal garbage collection
        end
    end
    
    -- Main optimized update loop
    local lastUpdate = 0
    local updateConnection
    
    local function Update()
        local currentTime = tick()
        
        -- Throttle update frequency for performance
        if currentTime - lastUpdate < 0.1 then -- 10 FPS max
            return
        end
        lastUpdate = currentTime
        
        PerformCleanup()
        
        -- Find targets
        local playersInRange = FindPlayersInRange()
        
        -- Target selection
        if #playersInRange > 0 and (not data.CurrentTarget or 
           currentTime - data.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME) then
            
            data.LastRetargetTime = currentTime
            data.CurrentTarget = playersInRange[1].Player
            
            if data.StatusGUI then
                data.StatusGUI.UpdateTarget(data.CurrentTarget.Name)
            end
        end
        
        -- Target engagement
        if data.CurrentTarget and data.CurrentTarget.Character then
            local targetChar = data.CurrentTarget.Character
            local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
            local targetHum = targetChar:FindFirstChild("Humanoid")
            
            if targetHRP and targetHum and targetHum.Health > 0 then
                local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
                
                if data.StatusGUI then
                    data.StatusGUI.UpdateDistance(string.format("%.1f", distance))
                end
                
                -- Robust navigation to target
                local safePosition = data.Navigation.UpdateNavigation(
                    Humanoid,
                    targetHRP.Position,
                    HumanoidRootPart.Position,
                    Character,
                    data.StatusGUI
                )
                
                -- Combat behavior
                local combatMode = data.Combat.UpdateCombat(
                    Humanoid,
                    targetHRP.Position,
                    HumanoidRootPart.Position,
                    distance,
                    data.StatusGUI
                )
                
                data.Combat.ExecuteCombatBehavior(
                    Humanoid,
                    targetHRP.Position,
                    HumanoidRootPart.Position,
                    distance,
                    combatMode
                )
                
                -- Attack if in range
                if distance <= CONFIG.ATTACK_RANGE then
                    ExecuteAttack()
                end
            else
                data.CurrentTarget = nil
            end
        else
            data.CurrentTarget = nil
            if data.StatusGUI then
                data.StatusGUI.UpdateTarget("None")
                data.StatusGUI.UpdateStatus("Searching")
            end
        end
    end
    
    updateConnection = RunService.Heartbeat:Connect(Update)
    
    -- Cleanup on death
    Humanoid.Died:Connect(function()
        if updateConnection then
            updateConnection:Disconnect()
        end
    end)
    
    if data.StatusGUI then
        data.StatusGUI.UpdateStatus("Active")
    end
end

-- Optimized respawn handling
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

if LocalPlayer then
    LocalPlayer.CharacterAdded:Connect(function()
        wait(1)
        InitializeAI()
    end)
end

-- Start with delay
wait(2)
InitializeAI()

forcePrint("LinkedSwordAI: Optimized script loaded")
