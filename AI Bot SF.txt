-- LinkedSwordAI_Fixed.lua
-- Stable version with proper error handling and scope management

local LinkedSwordAI = {}
LinkedSwordAI.Version = "2.0"
LinkedSwordAI.IsRunning = false

-- Safe configuration with fallback values
local Config = {
    -- Targeting
    DetectionRadius = 100,
    MaxTargetDistance = 150,
    TargetRefreshRate = 0.5,
    
    -- Combat
    AttackRange = 16,
    AttackCooldown = 1.0,
    ComboAttacks = 3,
    ComboDelay = 0.1,
    
    -- Movement
    WaypointDistance = 8,
    NavigationUpdate = 0.4,
    StrafeDistance = 4,
    
    -- Safety
    VoidThreshold = -20,
    EdgeSafetyMargin = 2,
    
    -- Performance
    UpdateThrottle = 0.1, -- 10 FPS max
    CleanupInterval = 20
}

-- Safe service access
local function GetService(serviceName)
    return game:GetService(serviceName)
end

-- Debug output
local function DebugPrint(message)
    if _G.LinkedSwordAIDebug then
        print("[LinkedSwordAI]: " .. tostring(message))
    end
end

-- Safe wait function
local function SafeWait(seconds)
    local start = tick()
    while tick() - start < seconds do
        game:GetService("RunService").Heartbeat:Wait()
    end
end

-- Core AI functions
local function CreateStatusGUI()
    local success, result = pcall(function()
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "LinkedSwordAI_Status"
        screenGui.Parent = game:GetService("CoreGui")
        
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(0, 200, 0, 80)
        frame.Position = UDim2.new(0, 10, 0, 10)
        frame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        frame.BackgroundTransparency = 0.3
        frame.BorderSizePixel = 0
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = frame
        
        local labels = {}
        local labelData = {
            {"Status", "Initializing"},
            {"Target", "None"}, 
            {"Distance", "0.0"},
            {"Action", "Idle"}
        }
        
        for i, data in ipairs(labelData) do
            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, -10, 0, 20)
            label.Position = UDim2.new(0, 5, 0, (i-1)*20)
            label.BackgroundTransparency = 1
            label.TextColor3 = Color3.fromRGB(255, 255, 255)
            label.Text = data[1] .. ": " .. data[2]
            label.Font = Enum.Font.SourceSansSemibold
            label.TextSize = 12
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.Parent = frame
            labels[data[1]] = label
        end
        
        frame.Parent = screenGui
        
        return {
            Update = function(field, value)
                if labels[field] then
                    labels[field].Text = field .. ": " .. (value or "N/A")
                end
            end,
            Destroy = function()
                screenGui:Destroy()
            end
        }
    end)
    
    if not success then
        DebugPrint("Failed to create status GUI")
        return nil
    end
    
    return result
end

local function EquipSword(character, humanoid)
    if not character or not humanoid then return nil end
    
    -- Check character inventory first
    for _, item in pairs(character:GetChildren()) do
        if item:IsA("Tool") then
            return item
        end
    end
    
    -- Check backpack
    local player = game:GetService("Players").LocalPlayer
    local backpack = player:FindFirstChild("Backpack")
    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                pcall(function()
                    humanoid:EquipTool(item)
                    SafeWait(0.2)
                end)
                return character:FindFirstChild(item.Name) or item
            end
        end
    end
    
    return nil
end

local function FindBestTarget(localPlayer, localPosition)
    local players = game:GetService("Players"):GetPlayers()
    local bestTarget = nil
    local bestDistance = Config.MaxTargetDistance
    
    for _, player in pairs(players) do
        if player ~= localPlayer and player.Character then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
            
            if humanoid and humanoid.Health > 0 and rootPart then
                local distance = (rootPart.Position - localPosition).Magnitude
                
                if distance < bestDistance then
                    bestTarget = {
                        Player = player,
                        Humanoid = humanoid,
                        RootPart = rootPart,
                        Distance = distance
                    }
                    bestDistance = distance
                end
            end
        end
    end
    
    return bestTarget
end

local function IsPositionSafe(position, character)
    -- Void check
    if position.Y < Config.VoidThreshold then
        return false, "void"
    end
    
    -- Ground check
    local rayOrigin = position + Vector3.new(0, 3, 0)
    local rayDirection = Vector3.new(0, -25, 0)
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    
    if not result then
        return false, "no ground"
    end
    
    return true, "safe"
end

local function CalculateSafeMovement(currentPos, targetPos, character)
    local direction = (targetPos - currentPos).Unit
    local distance = (targetPos - currentPos).Magnitude
    local moveDistance = math.min(Config.WaypointDistance, distance)
    
    -- Test direct path first
    local testPos = currentPos + (direction * moveDistance)
    local isSafe, reason = IsPositionSafe(testPos, character)
    
    if isSafe then
        return testPos, "direct"
    end
    
    -- Try alternative paths
    local alternatives = {
        -- Elevated path
        currentPos + Vector3.new(0, 5, 0) + (direction * moveDistance),
        -- Left path
        currentPos + (direction:Cross(Vector3.new(0, 1, 0)) * 4) + (direction * moveDistance),
        -- Right path  
        currentPos + (direction:Cross(Vector3.new(0, -1, 0)) * 4) + (direction * moveDistance)
    }
    
    for i, altPos in ipairs(alternatives) do
        if IsPositionSafe(altPos, character) then
            return altPos, "alternative_" .. i
        end
    end
    
    -- Retreat if no safe path
    local retreatPos = currentPos - (direction * 3)
    if IsPositionSafe(retreatPos, character) then
        return retreatPos, "retreat"
    end
    
    -- Stay put as last resort
    return currentPos, "hold"
end

local function ExecuteAttack(sword, lastAttackTime)
    if not sword or tick() - lastAttackTime < Config.AttackCooldown then
        return lastAttackTime
    end
    
    local newAttackTime = tick()
    
    -- Combo attack
    for i = 1, Config.ComboAttacks do
        if sword and sword.Parent then
            pcall(function()
                sword:Activate()
            end)
        end
        if i < Config.ComboAttacks then
            SafeWait(Config.ComboDelay)
        end
    end
    
    return newAttackTime
end

-- Main AI Controller
function LinkedSwordAI.Start()
    if LinkedSwordAI.IsRunning then
        DebugPrint("AI is already running")
        return false
    end
    
    DebugPrint("Starting LinkedSwordAI...")
    
    local localPlayer = game:GetService("Players").LocalPlayer
    if not localPlayer then
        DebugPrint("No local player found")
        return false
    end
    
    -- Wait for character
    local character = localPlayer.Character
    if not character then
        DebugPrint("Waiting for character...")
        local charAdded = localPlayer.CharacterAdded:Wait()
        character = charAdded
        SafeWait(1) -- Allow character to load
    end
    
    -- Get character components
    local humanoid = character:WaitForChild("Humanoid", 5)
    local rootPart = character:WaitForChild("HumanoidRootPart", 5)
    
    if not humanoid or not rootPart then
        DebugPrint("Failed to find character components")
        return false
    end
    
    -- Set up AI state
    local AIState = {
        Character = character,
        Humanoid = humanoid,
        RootPart = rootPart,
        Sword = nil,
        Target = nil,
        StatusGUI = nil,
        LastAttack = 0,
        LastTargetUpdate = 0,
        LastNavigationUpdate = 0,
        LastCleanup = tick(),
        Connections = {},
        IsActive = true
    }
    
    -- Create status GUI
    AIState.StatusGUI = CreateStatusGUI()
    if AIState.StatusGUI then
        AIState.StatusGUI.Update("Status", "Active")
    end
    
    -- Equip sword
    AIState.Sword = EquipSword(character, humanoid)
    if AIState.Sword then
        DebugPrint("Sword equipped: " .. AIState.Sword.Name)
        if AIState.StatusGUI then
            AIState.StatusGUI.Update("Action", "Sword ready")
        end
    else
        DebugPrint("No sword found")
        if AIState.StatusGUI then
            AIState.StatusGUI.Update("Action", "No sword")
        end
    end
    
    -- Death handling
    AIState.Connections.death = humanoid.Died:Connect(function()
        DebugPrint("Character died - stopping AI")
        LinkedSwordAI.Stop()
    end)
    
    -- Main update loop
    AIState.Connections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
        if not AIState.IsActive or not AIState.RootPart then
            return
        end
        
        local currentTime = tick()
        
        -- Performance throttling
        if currentTime - AIState.LastUpdateTime < Config.UpdateThrottle then
            return
        end
        AIState.LastUpdateTime = currentTime
        
        -- Memory cleanup
        if currentTime - AIState.LastCleanup > Config.CleanupInterval then
            collectgarbage("step")
            AIState.LastCleanup = currentTime
        end
        
        -- Target acquisition
        if currentTime - AIState.LastTargetUpdate > Config.TargetRefreshRate then
            AIState.LastTargetUpdate = currentTime
            AIState.Target = FindBestTarget(localPlayer, AIState.RootPart.Position)
            
            if AIState.StatusGUI then
                if AIState.Target then
                    AIState.StatusGUI.Update("Target", AIState.Target.Player.Name)
                    AIState.StatusGUI.Update("Distance", string.format("%.1f", AIState.Target.Distance))
                else
                    AIState.StatusGUI.Update("Target", "None")
                    AIState.StatusGUI.Update("Distance", "0.0")
                    AIState.StatusGUI.Update("Action", "Searching")
                end
            end
        end
        
        -- Skip if no target
        if not AIState.Target or not AIState.Target.RootPart or not AIState.Target.Humanoid or AIState.Target.Humanoid.Health <= 0 then
            AIState.Target = nil
            return
        end
        
        -- Navigation
        if currentTime - AIState.LastNavigationUpdate > Config.NavigationUpdate then
            AIState.LastNavigationUpdate = currentTime
            
            local safePosition, pathType = CalculateSafeMovement(
                AIState.RootPart.Position,
                AIState.Target.RootPart.Position,
                AIState.Character
            )
            
            if AIState.StatusGUI then
                AIState.StatusGUI.Update("Action", "Moving: " .. pathType)
            end
            
            -- Move to safe position
            pcall(function()
                AIState.Humanoid:MoveTo(safePosition)
            end)
        end
        
        -- Face target
        local lookVector = (AIState.Target.RootPart.Position - AIState.RootPart.Position).Unit
        pcall(function()
            AIState.Humanoid:MoveTo(AIState.RootPart.Position + lookVector * 0.1)
        end)
        
        -- Attack if in range
        if AIState.Target.Distance <= Config.AttackRange then
            AIState.LastAttack = ExecuteAttack(AIState.Sword, AIState.LastAttack)
            if AIState.StatusGUI then
                AIState.StatusGUI.Update("Action", "Attacking")
            end
        end
    end)
    
    -- Store state for cleanup
    _G.LinkedSwordAIState = AIState
    LinkedSwordAI.IsRunning = true
    
    DebugPrint("LinkedSwordAI started successfully")
    return true
end

function LinkedSwordAI.Stop()
    if not LinkedSwordAI.IsRunning then
        return false
    end
    
    DebugPrint("Stopping LinkedSwordAI...")
    
    local AIState = _G.LinkedSwordAIState
    
    if AIState then
        AIState.IsActive = false
        
        -- Disconnect all connections
        for name, connection in pairs(AIState.Connections) do
            if connection then
                connection:Disconnect()
            end
        end
        
        -- Clean up GUI
        if AIState.StatusGUI then
            AIState.StatusGUI.Destroy()
        end
    end
    
    _G.LinkedSwordAIState = nil
    LinkedSwordAI.IsRunning = false
    
    DebugPrint("LinkedSwordAI stopped")
    return true
end

function LinkedSwordAI.Toggle()
    if LinkedSwordAI.IsRunning then
        return LinkedSwordAI.Stop()
    else
        return LinkedSwordAI.Start()
    end
end

function LinkedSwordAI.GetStatus()
    return LinkedSwordAI.IsRunning
end

-- Auto-initialization with error handling
local function SafeInitialize()
    local success, errorMsg = pcall(function()
        -- Wait for game to load
        if not game:IsLoaded() then
            game.Loaded:Wait()
        end
        
        -- Wait for player
        local players = game:GetService("Players")
        if not players.LocalPlayer then
            players.PlayerAdded:Wait()
        end
        
        -- Auto-start after delay
        SafeWait(3)
        LinkedSwordAI.Start()
        
        -- Auto-restart on respawn
        players.LocalPlayer.CharacterAdded:Connect(function()
            SafeWait(2)
            if LinkedSwordAI.IsRunning then
                LinkedSwordAI.Stop()
                SafeWait(1)
                LinkedSwordAI.Start()
            end
        end)
    end)
    
    if not success then
        warn("[LinkedSwordAI] Initialization error: " .. tostring(errorMsg))
    end
end

-- Start the AI
spawn(SafeInitialize)

-- Create control functions in global scope
_G.LinkedSwordAI_Start = LinkedSwordAI.Start
_G.LinkedSwordAI_Stop = LinkedSwordAI.Stop  
_G.LinkedSwordAI_Toggle = LinkedSwordAI.Toggle

DebugPrint("LinkedSwordAI loaded successfully - Version " .. LinkedSwordAI.Version)

return LinkedSwordAI
