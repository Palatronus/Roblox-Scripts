-- LinkedSwordAI_Optimized.lua
-- Improved version with optimized movement, reliable pathfinding, and enhanced combat

-- Force print function to ensure output is visible
local function forcePrint(...)
    local args = {...}
    local message = ""
    for i, v in ipairs(args) do
        message = message .. tostring(v) .. (i < #args and " " or "")
    end
    
    -- Try multiple output methods to ensure visibility
    print(message)
    warn(message)
    
    -- Also try rconsoleprint if available (for some executors)
    pcall(function() rconsoleprint(message .. "\n") end)
end

forcePrint("LinkedSwordAI: Optimized script starting...")

-- Enhanced Configuration
local CONFIG = {
    DETECTION_RADIUS = 100,
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.8,
    LUNGE_DELAY = 0.1,
    STUCK_CHECK_DISTANCE = 1.5,
    STUCK_CHECK_TIME = 1.0,
    MAX_TARGET_DISTANCE = 150,
    RETARGET_CHECK_TIME = 1.0,
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -10,
    FORCEFIELD_FLEE_DISTANCE = 30,
    SWORD_CHECK_INTERVAL = 5,
    -- New optimization settings
    MOVEMENT_SMOOTHING = 0.3,
    GAP_JUMP_THRESHOLD = 8,
    PATH_REFRESH_RATE = 0.2,
    EQUIP_DELAY = 1.0, -- Increased delay for equipment
    JUMP_COOLDOWN = 1.5,
    FORCEFIELD_RECHECK_DELAY = 0.5
}

-- Create a status GUI (unchanged)
local function CreateStatusGUI()
    forcePrint("LinkedSwordAI: Creating status GUI...")
    
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "LinkedSwordAI_Status"
    
    local success = false
    local parentMethods = {
        function() ScreenGui.Parent = game:GetService("CoreGui") end,
        function() ScreenGui.Parent = game.Players.LocalPlayer.PlayerGui end,
        function() ScreenGui.Parent = game.Players.LocalPlayer:FindFirstChildOfClass("PlayerGui") end
    }
    
    for _, method in ipairs(parentMethods) do
        success = pcall(method)
        if success then
            forcePrint("LinkedSwordAI: Successfully parented GUI")
            break
        end
    end
    
    if not success then
        forcePrint("LinkedSwordAI: WARNING - Could not create GUI, continuing without visual feedback")
        return nil
    end
    
    local Frame = Instance.new("Frame")
    Frame.Size = UDim2.new(0, 200, 0, 120)
    Frame.Position = UDim2.new(0, 10, 0, 10)
    Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Frame.BackgroundTransparency = 0.5
    Frame.BorderSizePixel = 2
    Frame.Parent = ScreenGui
    
    local Title = Instance.new("TextLabel")
    Title.Size = UDim2.new(1, 0, 0, 20)
    Title.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.Text = "LinkedSword AI (Optimized)"
    Title.Font = Enum.Font.SourceSansBold
    Title.TextSize = 14
    Title.Parent = Frame
    
    local Status = Instance.new("TextLabel")
    local Target = Instance.new("TextLabel")
    local Distance = Instance.new("TextLabel")
    
    Status.Size = UDim2.new(1, 0, 0, 20)
    Status.Position = UDim2.new(0, 0, 0, 20)
    Status.BackgroundTransparency = 1
    Status.TextColor3 = Color3.fromRGB(255, 255, 255)
    Status.Text = "Status: Initializing..."
    Status.Font = Enum.Font.SourceSans
    Status.TextSize = 14
    Status.TextXAlignment = Enum.TextXAlignment.Left
    Status.Parent = Frame
    
    Target.Size = UDim2.new(1, 0, 0, 20)
    Target.Position = UDim2.new(0, 0, 0, 40)
    Target.BackgroundTransparency = 1
    Target.TextColor3 = Color3.fromRGB(255, 255, 255)
    Target.Text = "Target: None"
    Target.Font = Enum.Font.SourceSans
    Target.TextSize = 14
    Target.TextXAlignment = Enum.TextXAlignment.Left
    Target.Parent = Frame
    
    Distance.Size = UDim2.new(1, 0, 0, 20)
    Distance.Position = UDim2.new(0, 0, 0, 60)
    Distance.BackgroundTransparency = 1
    Distance.TextColor3 = Color3.fromRGB(255, 255, 255)
    Distance.Text = "Distance: N/A"
    Distance.Font = Enum.Font.SourceSans
    Distance.TextSize = 14
    Distance.TextXAlignment = Enum.TextXAlignment.Left
    Distance.Parent = Frame
    
    local Debug = Instance.new("TextLabel")
    Debug.Size = UDim2.new(1, 0, 0, 20)
    Debug.Position = UDim2.new(0, 0, 0, 80)
    Debug.BackgroundTransparency = 1
    Debug.TextColor3 = Color3.fromRGB(255, 255, 0)
    Debug.Text = "Debug: Ready"
    Debug.Font = Enum.Font.SourceSans
    Debug.TextSize = 14
    Debug.TextXAlignment = Enum.TextXAlignment.Left
    Debug.Parent = Frame
    
    local statusInterface = {}
    
    function statusInterface.UpdateStatus(text)
        if Status then
            Status.Text = "Status: " .. text
        end
    end
    
    function statusInterface.UpdateTarget(text)
        if Target then
            Target.Text = "Target: " .. text
        end
    end
    
    function statusInterface.UpdateDistance(distance)
        if Distance then
            Distance.Text = "Distance: " .. (distance and string.format("%.1f", distance) or "N/A")
        end
    end
    
    function statusInterface.UpdateDebug(text)
        if Debug then
            Debug.Text = "Debug: " .. text
        end
    end
    
    return statusInterface
end

-- Main execution with optimizations
local function InitializeAI()
    forcePrint("LinkedSwordAI: Initializing optimized AI...")
    
    -- Persistent data across respawns with new fields
    if not _G.LinkedSwordAIPersistentData then
        _G.LinkedSwordAIPersistentData = {
            StatusGUI = nil,
            LinkedSword = nil,
            SwordToolName = nil,
            CurrentTarget = nil,
            LastAttackTime = 0,
            LastRetargetTime = 0,
            LastSwordCheckTime = 0,
            StuckStartTime = 0,
            IsStuck = false,
            AttackSequenceActive = false,
            KnownVoidAreas = {},
            PlayersWithForceField = {},
            -- New optimization fields
            LastJumpTime = 0,
            LastPathUpdate = 0,
            CurrentDestination = nil,
            IsEquipping = false,
            LastForceFieldCheck = 0,
            MovementSmoothing = 0
        }
    end
    
    local persistentData = _G.LinkedSwordAIPersistentData
    
    -- Create or reuse status GUI
    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
    end
    
    if persistentData.StatusGUI then
        persistentData.StatusGUI.UpdateStatus("Initializing...")
        persistentData.StatusGUI.UpdateDebug("Getting services...")
    end
    
    -- Get necessary services
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local RunService = game:GetService("RunService")
    
    if not LocalPlayer then
        forcePrint("LinkedSwordAI: ERROR - LocalPlayer not found")
        if persistentData.StatusGUI then
            persistentData.StatusGUI.UpdateStatus("ERROR: LocalPlayer not found")
            persistentData.StatusGUI.UpdateDebug("Check if game is loaded")
        end
        return
    end
    
    -- Wait for character to load with proper timing
    local Character = LocalPlayer.Character
    if not Character then
        forcePrint("LinkedSwordAI: Waiting for character to load...")
        Character = LocalPlayer.CharacterAdded:Wait()
        wait(0.5) -- Additional wait for character to fully initialize
    end
    
    if not Character then
        forcePrint("LinkedSwordAI: ERROR - Character not found")
        if persistentData.StatusGUI then
            persistentData.StatusGUI.UpdateStatus("ERROR: Character not found")
            persistentData.StatusGUI.UpdateDebug("Waiting for respawn...")
        end
        return
    end
    
    local Humanoid = Character:WaitForChild("Humanoid", 5)
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart", 5)
    
    if not Humanoid or not HumanoidRootPart then
        forcePrint("LinkedSwordAI: ERROR - Humanoid or HumanoidRootPart not found")
        if persistentData.StatusGUI then
            persistentData.StatusGUI.UpdateStatus("ERROR: Missing character parts")
            persistentData.StatusGUI.UpdateDebug("Waiting for respawn...")
        end
        return
    end
    
    if persistentData.StatusGUI then
        persistentData.StatusGUI.UpdateStatus("Waiting for equip...")
        persistentData.StatusGUI.UpdateDebug("Delaying equipment...")
    end
    
    -- Enhanced sword equipping with proper timing
    local function EquipLinkedSword()
        if persistentData.IsEquipping then
            return persistentData.LinkedSword
        end
        
        persistentData.IsEquipping = true
        forcePrint("LinkedSwordAI: Attempting to equip sword...")
        
        -- Wait for equipment delay
        wait(CONFIG.EQUIP_DELAY)
        
        local function FindLinkedSword()
            -- First try to find the sword by name if we've seen it before
            if persistentData.SwordToolName then
                local tool = Character:FindFirstChild(persistentData.SwordToolName)
                if tool and tool:IsA("Tool") then
                    forcePrint("LinkedSwordAI: Found previously identified sword: " .. tool.Name)
                    return tool
                end
            end
            
            -- Search character
            for _, item in pairs(Character:GetChildren()) do
                if item:IsA("Tool") then
                    forcePrint("LinkedSwordAI: Found sword in character: " .. item.Name)
                    persistentData.SwordToolName = item.Name
                    return item
                end
            end
            
            -- Check backpack with proper timing
            local Backpack = LocalPlayer:FindFirstChild("Backpack")
            if Backpack then
                for _, item in pairs(Backpack:GetChildren()) do
                    if item:IsA("Tool") then
                        forcePrint("LinkedSwordAI: Found sword in backpack: " .. item.Name)
                        persistentData.SwordToolName = item.Name
                        
                        -- Equip with error handling
                        local success = pcall(function()
                            Humanoid:EquipTool(item)
                        end)
                        
                        if success then
                            wait(0.2) -- Wait for equip to complete
                            -- Verify it's now in character
                            local equippedTool = Character:FindFirstChild(item.Name)
                            if equippedTool then
                                return equippedTool
                            end
                        end
                        return item
                    end
                end
            end
            
            forcePrint("LinkedSwordAI: No sword found")
            return nil
        end
        
        persistentData.LinkedSword = FindLinkedSword()
        persistentData.IsEquipping = false
        
        if persistentData.LinkedSword then
            forcePrint("LinkedSwordAI: Sword equipment completed: " .. persistentData.LinkedSword.Name)
        end
        
        return persistentData.LinkedSword
    end
    
    -- Check for sword periodically with enhanced logic
    local function CheckForSword()
        local currentTime = tick()
        
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            persistentData.LastSwordCheckTime = currentTime
            
            if not persistentData.LinkedSword or not persistentData.LinkedSword.Parent then
                return EquipLinkedSword()
            end
        end
        
        return persistentData.LinkedSword
    end
    
    -- Initial sword equip with delay
    spawn(function()
        wait(CONFIG.EQUIP_DELAY)
        EquipLinkedSword()
    end)
    
    -- Enhanced player detection with reliable forcefield checking
    local function FindPlayersInRange()
        local playersInRange = {}
        local playersWithFF = {}
        local currentTime = tick()
        
        -- Only update forcefield list periodically to reduce false positives
        local shouldUpdateFF = currentTime - persistentData.LastForceFieldCheck > CONFIG.FORCEFIELD_RECHECK_DELAY
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                local humanoid = player.Character:FindFirstChild("Humanoid")
                
                if humanoidRootPart and humanoid and humanoid.Health > 0 then
                    local distance = (humanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                    
                    if distance <= CONFIG.MAX_TARGET_DISTANCE then
                        -- Reliable forcefield detection with periodic updates
                        local hasForceField = false
                        if shouldUpdateFF then
                            hasForceField = player.Character:FindFirstChild("ForceField") ~= nil
                        else
                            -- Use cached value if not time to update yet
                            hasForceField = persistentData.PlayersWithForceField[player] == true
                        end
                        
                        if hasForceField then
                            playersWithFF[player] = true
                            if shouldUpdateFF then
                                forcePrint("LinkedSwordAI: Detected ForceField on " .. player.Name)
                            end
                        else
                            table.insert(playersInRange, {
                                Player = player,
                                Distance = distance,
                                HumanoidRootPart = humanoidRootPart
                            })
                        end
                    end
                end
            end
        end
        
        -- Update forcefield cache if it's time
        if shouldUpdateFF then
            persistentData.PlayersWithForceField = playersWithFF
            persistentData.LastForceFieldCheck = currentTime
        end
        
        -- Sort by distance
        table.sort(playersInRange, function(a, b)
            return a.Distance < b.Distance
        end)
        
        return playersInRange
    end
    
    -- Optimized void detection with gap jumping capability
    local function IsVoidArea(position)
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            return true
        end
        
        -- More reliable raycast with multiple rays for better coverage
        local rayOrigin = position + Vector3.new(0, 0.5, 0) -- Slightly above the position
        local rayDirection = Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0)
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {Character}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        
        local raycastResult = workspace:Raycast(rayOrigin, rayDirection, rayParams)
        return raycastResult == nil
    end
    
    -- Enhanced path safety check with gap assessment
    local function IsSafePath(targetPosition)
        local direction = (targetPosition - HumanoidRootPart.Position).Unit
        local distance = (targetPosition - HumanoidRootPart.Position).Magnitude
        
        -- Check immediate path ahead more thoroughly
        local immediateCheckPoint = HumanoidRootPart.Position + direction * math.min(5, distance)
        if IsVoidArea(immediateCheckPoint) then
            return false, "Immediate path blocked"
        end
        
        -- Check intermediate points with reduced frequency to prevent oscillation
        for i = 10, math.min(distance, 20), 8 do
            local checkPoint = HumanoidRootPart.Position + direction * i
            if IsVoidArea(checkPoint) then
                -- Check if this is a jumpable gap
                local gapWidth = i
                if gapWidth <= CONFIG.GAP_JUMP_THRESHOLD then
                    forcePrint("LinkedSwordAI: Jumpable gap detected, proceeding")
                    return true, "Jumpable gap"
                end
                return false, "Unsafe path at distance " .. i
            end
        end
        
        return true, "Path clear"
    end
    
    -- Smooth movement system to prevent oscillation
    local function SmoothMoveTo(position)
        local currentTime = tick()
        
        -- Only update path periodically to prevent rapid direction changes
        if currentTime - persistentData.LastPathUpdate < CONFIG.PATH_REFRESH_RATE then
            return
        end
        
        persistentData.LastPathUpdate = currentTime
        persistentData.CurrentDestination = position
        
        -- Apply movement smoothing
        persistentData.MovementSmoothing = math.min(persistentData.MovementSmoothing + 0.1, 1.0)
        
        Humanoid:MoveTo(position)
    end
    
    -- Enhanced gap jumping capability
    local function AttemptJump()
        local currentTime = tick()
        if currentTime - persistentData.LastJumpTime > CONFIG.JUMP_COOLDOWN then
            persistentData.LastJumpTime = currentTime
            Humanoid.Jump = true
            forcePrint("LinkedSwordAI: Jumping over gap")
            return true
        end
        return false
    end
    
    -- Optimized stuck detection and handling
    local function CheckIfStuck()
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local playerHRP = player.Character.HumanoidRootPart
                local horizontalDist = (Vector3.new(playerHRP.Position.X, 0, playerHRP.Position.Z) - 
                                       Vector3.new(HumanoidRootPart.Position.X, 0, HumanoidRootPart.Position.Z)).Magnitude
                
                if horizontalDist < CONFIG.STUCK_CHECK_DISTANCE then
                    return true, player
                end
            end
        end
        
        return false, nil
    end
    
    -- Streamlined combat system
    local function ExecuteAttack()
        if not persistentData.LinkedSword then
            return
        end
        
        if persistentData.AttackSequenceActive then
            return
        end
        
        persistentData.AttackSequenceActive = true
        persistentData.LastAttackTime = tick()
        
        if persistentData.StatusGUI then
            persistentData.StatusGUI.UpdateStatus("Attacking")
        end
        
        -- More efficient attack sequence
        local function PerformAttack(attackNumber)
            forcePrint("LinkedSwordAI: Attack " .. attackNumber)
            pcall(function() 
                if persistentData.LinkedSword and persistentData.LinkedSword.Parent then
                    persistentData.LinkedSword:Activate()
                end
            end)
        end
        
        spawn(function()
            PerformAttack(1)
            wait(CONFIG.LUNGE_DELAY)
            
            PerformAttack(2)
            wait(CONFIG.LUNGE_DELAY)
            
            PerformAttack(3)
            wait(0.1)
            
            persistentData.AttackSequenceActive = false
        end)
    end
    
    -- Enhanced forcefield handling
    local function HandleFleeFromForceField()
        local closestFFPlayer = nil
        local closestDistance = math.huge
        
        for player, _ in pairs(persistentData.PlayersWithForceField) do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (player.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestFFPlayer = player
                end
            end
        end
        
        if closestFFPlayer and closestFFPlayer.Character then
            local ffHRP = closestFFPlayer.Character.HumanoidRootPart
            if ffHRP and closestDistance < CONFIG.FORCEFIELD_FLEE_DISTANCE then
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Fleeing from FF")
                end
                
                -- Calculate flee direction
                local fleeDir = (HumanoidRootPart.Position - ffHRP.Position).Unit
                local fleePos = HumanoidRootPart.Position + fleeDir * 10 -- Shorter flee distance
                
                if not IsVoidArea(fleePos) then
                    SmoothMoveTo(fleePos)
                    AttemptJump() -- Jump while fleeing
                    return true
                end
            end
        end
        
        return false
    end
    
    -- Main optimized update loop
    local function Update()
        -- Check for sword
        CheckForSword()
        
        -- Handle forcefield players first
        if next(persistentData.PlayersWithForceField) ~= nil then
            if HandleFleeFromForceField() then
                return
            end
        end
        
        -- Find and update target
        local playersInRange = FindPlayersInRange()
        local currentTime = tick()
        
        -- Target selection logic
        if #playersInRange > 0 and (not persistentData.CurrentTarget or 
           currentTime - persistentData.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME) then
            
            persistentData.LastRetargetTime = currentTime
            
            for _, playerData in ipairs(playersInRange) do
                local targetPlayer = playerData.Player
                local targetHRP = playerData.HumanoidRootPart
                
                local isSafe, reason = IsSafePath(targetHRP.Position)
                
                if isSafe then
                    persistentData.CurrentTarget = targetPlayer
                    
                    if persistentData.StatusGUI then
                        persistentData.StatusGUI.UpdateTarget(targetPlayer.Name)
                    end
                    
                    forcePrint("LinkedSwordAI: New target - " .. targetPlayer.Name)
                    break
                else
                    forcePrint("LinkedSwordAI: Path unsafe - " .. reason)
                end
            end
        end
        
        -- Target engagement
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character then
            local targetChar = persistentData.CurrentTarget.Character
            local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
            local targetHumanoid = targetChar:FindFirstChild("Humanoid")
            
            if targetHRP and targetHumanoid and targetHumanoid.Health > 0 then
                local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
                
                if persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateDistance(distance)
                end
                
                -- Revalidate path safety
                local isSafe, reason = IsSafePath(targetHRP.Position)
                if not isSafe and reason ~= "Jumpable gap" then
                    forcePrint("LinkedSwordAI: Path to target became unsafe")
                    persistentData.CurrentTarget = nil
                    return
                end
                
                -- Combat logic
                if distance <= CONFIG.ATTACK_RANGE and persistentData.LinkedSword then
                    if currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        ExecuteAttack()
                    end
                    -- Stop moving when in attack range to prevent circling
                    Humanoid:MoveTo(HumanoidRootPart.Position)
                else
                    -- Movement towards target with path optimization
                    if persistentData.StatusGUI then
                        persistentData.StatusGUI.UpdateStatus("Chasing")
                    end
                    
                    SmoothMoveTo(targetHRP.Position)
                    
                    -- Attempt jump if approaching a gap
                    if reason == "Jumpable gap" then
                        AttemptJump()
                    end
                end
            else
                persistentData.CurrentTarget = nil
            end
        else
            persistentData.CurrentTarget = nil
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateTarget("None")
                persistentData.StatusGUI.UpdateStatus("Searching")
            end
        end
    end
    
    -- Main loop with error handling
    local updateConnection
    updateConnection = RunService.Heartbeat:Connect(function()
        local success, err = pcall(Update)
        if not success then
            forcePrint("LinkedSwordAI: Update error - " .. tostring(err))
        end
    end)
    
    -- Handle character death
    local function onDied()
        forcePrint("LinkedSwordAI: Character died")
        if updateConnection then
            updateConnection:Disconnect()
        end
    end
    
    Humanoid.Died:Connect(onDied)
    
    forcePrint("LinkedSwordAI: Optimized initialization complete")
    if persistentData.StatusGUI then
        persistentData.StatusGUI.UpdateStatus("Ready")
        persistentData.StatusGUI.UpdateDebug("Optimized AI active")
    end
end

-- Enhanced respawn handling
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

if LocalPlayer then
    LocalPlayer.CharacterAdded:Connect(function(character)
        forcePrint("LinkedSwordAI: Character respawned, waiting to initialize...")
        wait(1.5) -- Increased wait for full character load
        InitializeAI()
    end)
end

-- Start the AI
local success, err = pcall(function()
    wait(1) -- Initial delay
    InitializeAI()
end)

if not success then
    forcePrint("LinkedSwordAI: Failed to initialize - " .. tostring(err))
end

forcePrint("LinkedSwordAI: Optimized script execution complete")
