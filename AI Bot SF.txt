--[[
    Linked Sword AI Combat Script (Optimized Version)
    
    This script implements autonomous sword fighting AI for the Linked Sword tool in Roblox.
    Optimized for performance with reduced lag and improved efficiency.
]]

-- Force print to output console immediately
local function forcePrint(...)
    local message = table.concat({...}, " ")
    print(message)
    print("") -- Force flush
end

-- Debug function with timestamps
local function debugPrint(category, ...)
    local args = {...}
    local message = "[" .. category .. "] " .. table.concat(args, " ")
    local timestamp = os.date("%H:%M:%S")
    forcePrint(timestamp .. " - " .. message)
end

forcePrint("LinkedSwordAI: Script starting...")
debugPrint("INIT", "Debug logging enabled")

-- Global persistent data to maintain state across respawns
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {},
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        MovementHistory = {},
        FailedPaths = {},
        LastEquipAttempt = 0,
        EquipmentReady = false,
        KnownVoidAreas = {},
        PathCache = {},
        LastPathfindingTime = 0,
        PerformanceStats = {
            PathfindingTime = 0,
            CombatTime = 0,
            MovementTime = 0,
            LastOptimizationTime = 0
        },
        AlternativePaths = {},
        -- Performance optimization fields
        FrameCounter = 0,
        LastCleanupTime = 0,
        CachedPlayers = {},
        LastPlayerCacheUpdate = 0
    }
end

local persistentData = _G.LinkedSwordAIPersistentData

-- Configuration with performance optimizations
local CONFIG = {
    DETECTION_RADIUS = 200,
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.7,
    LUNGE_DELAY = 0.1,
    STUCK_CHECK_DISTANCE = 1.5,
    STUCK_CHECK_TIME = 1.0,
    MAX_TARGET_DISTANCE = 250,
    MIN_HEALTH_CHECK = 0,
    RETARGET_CHECK_TIME = 1.5,
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -100,
    FORCEFIELD_FLEE_DISTANCE = 0,
    SWORD_CHECK_INTERVAL = 7,
    RESPAWN_EQUIP_DELAY = 1.5,
    MOVEMENT_MEMORY_TIME = 0.7,
    SAFE_GAP_DISTANCE = 10,
    PATH_SMOOTHING_FACTOR = 0.7,
    MOVEMENT_RETRY_DELAY = 1.0,
    NARROW_PASSAGE_WIDTH = 3.5,
    PATHFINDING_STEPS = 10,
    COMBAT_BEHAVIOR_CHANGE_TIME = 4.0,
    COMBAT_DEFENSIVE_CHANCE = 0.25,
    COMBAT_OFFENSIVE_CHANCE = 0.45,
    STRAFE_DISTANCE = 4,
    BRIDGE_CHECK_DISTANCE = 25,
    PERFORMANCE_MODE = true,
    PATH_CACHE_TIME = 3.0,
    ALTERNATIVE_PATH_COUNT = 4,
    MIN_ATTACK_DISTANCE = 3,
    -- Performance optimization settings
    UPDATE_THROTTLE = 2, -- Process heavy operations every Nth frame
    MAX_PLAYER_CACHE_TIME = 1.0, -- Cache players for 1 second
    RAYCAST_BATCH_SIZE = 3, -- Process raycasts in smaller batches
    PATH_CACHE_MAX_SIZE = 15, -- Reduced from 20
    FAILED_PATHS_MAX_SIZE = 8, -- Reduced from 10
    VOID_AREAS_MAX_SIZE = 30, -- Reduced from 50
    GUI_UPDATE_INTERVAL = 10 -- Update GUI every 10 frames
}

-- Create status GUI
local function CreateStatusGUI()
    local gui = {}
    
    local parentOptions = {
        game:GetService("CoreGui"),
        game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui"),
        game:GetService("Players").LocalPlayer.Character
    }
    
    local screenGui
    for _, parent in ipairs(parentOptions) do
        if parent then
            local success, result = pcall(function()
                local newGui = Instance.new("ScreenGui")
                newGui.Name = "LinkedSwordAI_Status"
                newGui.Parent = parent
                return newGui
            end)
            
            if success then
                screenGui = result
                break
            end
        end
    end
    
    if not screenGui then
        forcePrint("LinkedSwordAI: Failed to create GUI - No valid parent found")
        return nil
    end
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 120)
    frame.Position = UDim2.new(0.8, 0, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.5
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    frame.Parent = screenGui
    
    local status = Instance.new("TextLabel")
    status.Size = UDim2.new(1, -10, 0, 20)
    status.Position = UDim2.new(0, 5, 0, 5)
    status.BackgroundTransparency = 1
    status.TextColor3 = Color3.fromRGB(255, 255, 255)
    status.Text = "Status: Initializing..."
    status.Font = Enum.Font.SourceSans
    status.TextSize = 14
    status.TextXAlignment = Enum.TextXAlignment.Left
    status.Parent = frame
    
    local target = Instance.new("TextLabel")
    target.Size = UDim2.new(1, -10, 0, 20)
    target.Position = UDim2.new(0, 5, 0, 30)
    target.BackgroundTransparency = 1
    target.TextColor3 = Color3.fromRGB(255, 150, 150)
    target.Text = "Target: None"
    target.Font = Enum.Font.SourceSans
    target.TextSize = 14
    target.TextXAlignment = Enum.TextXAlignment.Left
    target.Parent = frame
    
    local distance = Instance.new("TextLabel")
    distance.Size = UDim2.new(1, -10, 0, 20)
    distance.Position = UDim2.new(0, 5, 0, 55)
    distance.BackgroundTransparency = 1
    distance.TextColor3 = Color3.fromRGB(150, 255, 150)
    distance.Text = "Distance: N/A"
    distance.Font = Enum.Font.SourceSans
    distance.TextSize = 14
    distance.TextXAlignment = Enum.TextXAlignment.Left
    distance.Parent = frame
    
    local debug = Instance.new("TextLabel")
    debug.Size = UDim2.new(1, -10, 0, 20)
    debug.Position = UDim2.new(0, 5, 0, 80)
    debug.BackgroundTransparency = 1
    debug.TextColor3 = Color3.fromRGB(255, 255, 0)
    debug.Text = "Debug: Starting..."
    debug.Font = Enum.Font.SourceSans
    debug.TextSize = 14
    debug.TextXAlignment = Enum.TextXAlignment.Left
    debug.Parent = frame
    
    function gui.UpdateStatus(text)
        if status then
            status.Text = "Status: " .. text
        end
    end
    
    function gui.UpdateTarget(text)
        if target then
            target.Text = "Target: " .. text
        end
    end
    
    function gui.UpdateDistance(dist)
        if distance then
            distance.Text = "Distance: " .. (dist and string.format("%.1f", dist) or "N/A")
        end
    end
    
    function gui.UpdateDebug(text)
        if debug then
            debug.Text = "Debug: " .. text
        end
    end
    
    return gui
end

-- Main execution in protected call
local function InitializeAI()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    
    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        forcePrint("LinkedSwordAI: LocalPlayer not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: LocalPlayer found - " .. LocalPlayer.Name)
    
    local Character = LocalPlayer.Character
    if not Character then
        forcePrint("LinkedSwordAI: Character not found")
        return false
    end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    
    if not Humanoid or not HumanoidRootPart then
        forcePrint("LinkedSwordAI: Humanoid or HumanoidRootPart not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: Character components found")
    
    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
        if persistentData.StatusGUI then
            forcePrint("LinkedSwordAI: Status GUI created")
        end
    end
    
    -- Find the Linked Sword tool (optimized)
    local function FindLinkedSword()
        if persistentData.SwordToolName then
            local storedSword = Character:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                return storedSword
            end
            
            storedSword = LocalPlayer.Backpack:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                return storedSword
            end
        end
        
        for _, tool in pairs(Character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        
        return nil
    end
    
    -- Check for sword periodically (optimized)
    local function CheckForSword()
        local currentTime = tick()
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword = FindLinkedSword()
            end
            persistentData.LastSwordCheckTime = currentTime
        end
    end
    
    -- Cache players for better performance
    local function UpdatePlayerCache()
        local currentTime = tick()
        if currentTime - persistentData.LastPlayerCacheUpdate < CONFIG.MAX_PLAYER_CACHE_TIME then
            return persistentData.CachedPlayers
        end
        
        persistentData.CachedPlayers = {}
        local players = Players:GetPlayers()
        
        for i = 1, #players do
            local player = players[i]
            if player ~= LocalPlayer and player.Character then
                persistentData.CachedPlayers[#persistentData.CachedPlayers + 1] = player
            end
        end
        
        persistentData.LastPlayerCacheUpdate = currentTime
        return persistentData.CachedPlayers
    end
    
    -- Find players in range (optimized)
    local function FindPlayersInRange()
        local playersInRange = {}
        local cachedPlayers = UpdatePlayerCache()
        local myPosition = HumanoidRootPart.Position
        
        for i = 1, #cachedPlayers do
            local player = cachedPlayers[i]
            if player.Character then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                
                if humanoid and hrp and humanoid.Health > CONFIG.MIN_HEALTH_CHECK then
                    local distance = (hrp.Position - myPosition).Magnitude
                    
                    if distance <= CONFIG.DETECTION_RADIUS then
                        local hasForceField = false
                        local children = player.Character:GetChildren()
                        for j = 1, #children do
                            if children[j]:IsA("ForceField") then
                                hasForceField = true
                                persistentData.PlayersWithForceField[player.Name] = player
                                break
                            end
                        end
                        
                        if not hasForceField and persistentData.PlayersWithForceField[player.Name] then
                            persistentData.PlayersWithForceField[player.Name] = nil
                        end
                        
                        playersInRange[#playersInRange + 1] = {
                            player = player,
                            distance = distance,
                            hasForceField = hasForceField
                        }
                    end
                end
            end
        end
        
        table.sort(playersInRange, function(a, b)
            return a.distance < b.distance
        end)
        
        return playersInRange
    end
    
    -- Check if a position is in a void area (optimized)
    local function IsVoidArea(position)
        for i = 1, #persistentData.KnownVoidAreas do
            if (position - persistentData.KnownVoidAreas[i]).Magnitude < 5 then
                return true
            end
        end
        
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            if #persistentData.KnownVoidAreas < CONFIG.VOID_AREAS_MAX_SIZE then
                persistentData.KnownVoidAreas[#persistentData.KnownVoidAreas + 1] = position
            else
                table.remove(persistentData.KnownVoidAreas, 1)
                persistentData.KnownVoidAreas[#persistentData.KnownVoidAreas + 1] = position
            end
            return true
        end
        
        local ray = Ray.new(position, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
        local hit = Workspace:FindPartOnRay(ray, Character)
        
        if not hit then
            if #persistentData.KnownVoidAreas < CONFIG.VOID_AREAS_MAX_SIZE then
                persistentData.KnownVoidAreas[#persistentData.KnownVoidAreas + 1] = position
            else
                table.remove(persistentData.KnownVoidAreas, 1)
                persistentData.KnownVoidAreas[#persistentData.KnownVoidAreas + 1] = position
            end
            return true
        end
        
        return false
    end
    
    -- Check if a gap between two points is safe to traverse (optimized)
    local function IsSafeGap(startPos, endPos)
        local distance = (endPos - startPos).Magnitude
        
        if distance < 3 then
            return not IsVoidArea(endPos)
        end
        
        if distance < CONFIG.SAFE_GAP_DISTANCE then
            local ray = Ray.new(endPos, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
            return Workspace:FindPartOnRay(ray, Character) ~= nil
        end
        
        local direction = (endPos - startPos).Unit
        local checkCount = math.ceil(distance / 2)
        
        for i = 1, checkCount do
            local checkPoint = startPos + direction * (i * 2)
            local ray = Ray.new(checkPoint, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
            if not Workspace:FindPartOnRay(ray, Character) then
                return false
            end
        end
        
        return true
    end
    
    -- Check if a passage is narrow (optimized)
    local function IsNarrowPassage(position, direction)
        local leftRay = Ray.new(position, direction:Cross(Vector3.new(0, 1, 0)).Unit * CONFIG.NARROW_PASSAGE_WIDTH)
        local rightRay = Ray.new(position, direction:Cross(Vector3.new(0, 1, 0)).Unit * -CONFIG.NARROW_PASSAGE_WIDTH)
        
        return Workspace:FindPartOnRay(leftRay, Character) and Workspace:FindPartOnRay(rightRay, Character)
    end
    
    -- Find bridge path (optimized)
    local function FindBridgePath(startPos, endPos)
        local direction = (endPos - startPos).Unit
        local distance = (endPos - startPos).Magnitude
        
        for dist = 5, math.min(CONFIG.BRIDGE_CHECK_DISTANCE, distance), 5 do
            local checkPoint = startPos + direction * dist
            
            for y = 0, -20, -2 do
                local bridgeCheckPoint = checkPoint + Vector3.new(0, y, 0)
                local ray = Ray.new(bridgeCheckPoint, Vector3.new(0, -5, 0))
                local hit, hitPos = Workspace:FindPartOnRay(ray, Character)
                
                if hit then
                    local bridgePath = hitPos + Vector3.new(0, 3, 0)
                    if IsSafeGap(startPos, bridgePath) then
                        return bridgePath
                    end
                end
            end
        end
        
        return nil
    end
    
    -- Check if path to target is safe (optimized)
    local function IsSafePath(targetPosition)
        if CONFIG.PERFORMANCE_MODE then
            local currentTime = tick()
            for cachedPath, data in pairs(persistentData.PathCache) do
                if (Vector3.new(cachedPath.x, cachedPath.y, cachedPath.z) - targetPosition).Magnitude < 5 and 
                   currentTime - data.time < CONFIG.PATH_CACHE_TIME then
                    return data.safe, data.bridgePath, data.alternativePath
                end
            end
        end
        
        local startTime = tick()
        
        for i = 1, #persistentData.FailedPaths do
            local failedPath = persistentData.FailedPaths[i]
            if (targetPosition - failedPath.position).Magnitude < 5 and 
               tick() - failedPath.time < 10 then
                return false
            end
        end
        
        local startPos = HumanoidRootPart.Position
        local direction = (targetPosition - startPos).Unit
        local distance = (targetPosition - startPos).Magnitude
        
        local isNarrow = IsNarrowPassage(startPos, direction)
        
        if isNarrow then
            local narrowIncrement = math.min(2, distance / 8)
            
            for i = narrowIncrement, distance, narrowIncrement do
                local checkPos = startPos + direction * i
                
                if not IsNarrowPassage(checkPos, direction) then
                    if IsVoidArea(checkPos) then
                        if #persistentData.FailedPaths >= CONFIG.FAILED_PATHS_MAX_SIZE then
                            table.remove(persistentData.FailedPaths, 1)
                        end
                        persistentData.FailedPaths[#persistentData.FailedPaths + 1] = {
                            position = targetPosition,
                            time = tick()
                        }
                        
                        if CONFIG.PERFORMANCE_MODE then
                            persistentData.PathCache[targetPosition] = {
                                safe = false,
                                time = tick(),
                                bridgePath = nil
                            }
                            
                            local cacheSize = 0
                            for _ in pairs(persistentData.PathCache) do cacheSize = cacheSize + 1 end
                            if cacheSize > CONFIG.PATH_CACHE_MAX_SIZE then
                                local oldestTime = math.huge
                                local oldestKey = nil
                                for k, v in pairs(persistentData.PathCache) do
                                    if v.time < oldestTime then
                                        oldestTime = v.time
                                        oldestKey = k
                                    end
                                end
                                if oldestKey then persistentData.PathCache[oldestKey] = nil end
                            end
                        end
                        
                        return false
                    end
                    break
                end
            end
        else
            local increment = math.min(5, distance / 5)
            
            for i = increment, distance, increment do
                local checkPos = startPos + direction * i
                if IsVoidArea(checkPos) then
                    local bridgePath = FindBridgePath(startPos, targetPosition)
                    if bridgePath then
                        if CONFIG.PERFORMANCE_MODE then
                            persistentData.PathCache[targetPosition] = {
                                safe = true,
                                time = tick(),
                                bridgePath = bridgePath
                            }
                            persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                        end
                        return true, bridgePath
                    end
                    
                    for altIndex = 1, CONFIG.ALTERNATIVE_PATH_COUNT do
                        local angle = (altIndex / CONFIG.ALTERNATIVE_PATH_COUNT) * math.pi
                        local altDirection = CFrame.fromAxisAngle(Vector3.new(0, 1, 0), angle) * direction
                        local altTargetPos = startPos + altDirection * (distance * 0.5)
                        
                        local altSafe = true
                        for j = increment, distance * 0.5, increment do
                            local altCheckPos = startPos + altDirection * j
                            if IsVoidArea(altCheckPos) then
                                altSafe = false
                                break
                            end
                        end
                        
                        if altSafe then
                            persistentData.AlternativePaths[targetPosition] = altTargetPos
                            
                            if CONFIG.PERFORMANCE_MODE then
                                persistentData.PathCache[targetPosition] = {
                                    safe = false,
                                    time = tick(),
                                    bridgePath = nil,
                                    alternativePath = altTargetPos
                                }
                                persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                            end
                            
                            return false, nil, altTargetPos
                        end
                    end
                    
                    if #persistentData.FailedPaths >= CONFIG.FAILED_PATHS_MAX_SIZE then
                        table.remove(persistentData.FailedPaths, 1)
                    end
                    persistentData.FailedPaths[#persistentData.FailedPaths + 1] = {
                        position = targetPosition,
                        time = tick()
                    }
                    
                    if CONFIG.PERFORMANCE_MODE then
                        persistentData.PathCache[targetPosition] = {
                            safe = false,
                            time = tick(),
                            bridgePath = nil
                        }
                        persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                    end
                    
                    return false
                end
            end
        end
        
        if IsVoidArea(targetPosition) then
            if #persistentData.FailedPaths >= CONFIG.FAILED_PATHS_MAX_SIZE then
                table.remove(persistentData.FailedPaths, 1)
            end
            persistentData.FailedPaths[#persistentData.FailedPaths + 1] = {
                position = targetPosition,
                time = tick()
            }
            
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PathCache[targetPosition] = {
                    safe = false,
                    time = tick(),
                    bridgePath = nil
                }
                persistentData.PerformanceStats.PathfindingTime = tick() - startTime
            end
            
            return false
        end
        
        if CONFIG.PERFORMANCE_MODE then
            persistentData.PathCache[targetPosition] = {
                safe = true,
                time = tick(),
                bridgePath = nil
            }
            persistentData.PerformanceStats.PathfindingTime = tick() - startTime
        end
        
        return true
    end
    
    -- Check if we're stuck on a player (optimized)
    local function CheckIfStuck()
        if not persistentData.LastStuckPosition then
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = tick()
            return false
        end
        
        local currentTime = tick()
        local timeDiff = currentTime - persistentData.LastStuckTime
        
        if timeDiff > CONFIG.STUCK_CHECK_TIME then
            local distance = (HumanoidRootPart.Position - persistentData.LastStuckPosition).Magnitude
            
            if distance < CONFIG.STUCK_CHECK_DISTANCE then
                persistentData.IsStuck = true
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Stuck detected") end
                return true
            end
            
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = currentTime
        end
        
        return false
    end
    
    -- Handle being stuck on a player (optimized)
    local function HandleStuckOnPlayer()
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Unstucking from player") end
        
        local directions = {
            Vector3.new(1, 0, 0), Vector3.new(-1, 0, 0), Vector3.new(0, 0, 1), Vector3.new(0, 0, -1),
            Vector3.new(1, 0, 1).Unit, Vector3.new(-1, 0, 1).Unit, Vector3.new(1, 0, -1).Unit, Vector3.new(-1, 0, -1).Unit
        }
        
        for i = 1, #directions do
            local targetPosition = HumanoidRootPart.Position + directions[i] * 5
            if IsSafePath(targetPosition) then
                Humanoid:MoveTo(targetPosition)
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Moving to unstuck") end
                return true
            end
        end
        
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("No safe path to unstuck") end
        return false
    end
    
    -- Smooth movement function (optimized)
    local function MoveTo(targetPosition, bridgePath, alternativePath)
        local startTime = tick()
        
        if bridgePath then
            targetPosition = bridgePath
        end
        
        if alternativePath then
            targetPosition = alternativePath
        end
        
        local currentDirection = (targetPosition - HumanoidRootPart.Position).Unit
        local currentTime = tick()
        
        local smoothedDirection = currentDirection
        if persistentData.LastMovementDirection and 
           currentTime - persistentData.LastMovementTime < CONFIG.MOVEMENT_MEMORY_TIME then
            smoothedDirection = (persistentData.LastMovementDirection * CONFIG.PATH_SMOOTHING_FACTOR + 
                               currentDirection * (1 - CONFIG.PATH_SMOOTHING_FACTOR)).Unit
        end
        
        local smoothedTarget = HumanoidRootPart.Position + smoothedDirection * 
                              math.min(5, (targetPosition - HumanoidRootPart.Position).Magnitude)
        
        local isNarrow = IsNarrowPassage(HumanoidRootPart.Position, smoothedDirection)
        
        if isNarrow then
            smoothedDirection = currentDirection
            smoothedTarget = HumanoidRootPart.Position + smoothedDirection * 
                           math.min(2, (targetPosition - HumanoidRootPart.Position).Magnitude)
        end
        
        if IsSafeGap(HumanoidRootPart.Position, smoothedTarget) then
            persistentData.LastMovementDirection = smoothedDirection
            persistentData.LastMovementTime = currentTime
            Humanoid:MoveTo(smoothedTarget)
            
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PerformanceStats.MovementTime = tick() - startTime
            end
            
            return true
        else
            return false
        end
    end
    
    -- Execute attack (optimized)
    local function ExecuteAttack()
        if not persistentData.LinkedSword or persistentData.AttackSequenceActive then
            return
        end
        
        persistentData.AttackSequenceActive = true
        persistentData.LastAttackTime = tick()
        
        if not persistentData.CurrentCombatBehavior or 
           tick() - persistentData.LastBehaviorChangeTime > CONFIG.COMBAT_BEHAVIOR_CHANGE_TIME then
            
            local rand = math.random()
            if rand < CONFIG.COMBAT_DEFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "defensive"
            elseif rand < CONFIG.COMBAT_DEFENSIVE_CHANCE + CONFIG.COMBAT_OFFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "offensive"
            else
                persistentData.CurrentCombatBehavior = "offensive-defensive"
            end
            
            persistentData.LastBehaviorChangeTime = tick()
        end
        
        if persistentData.CurrentTarget and 
           persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
            HumanoidRootPart.CFrame = CFrame.new(
                HumanoidRootPart.Position,
                Vector3.new(targetPos.X, HumanoidRootPart.Position.Y, targetPos.Z)
            )
        end
        
        spawn(function()
            if persistentData.CurrentCombatBehavior == "defensive" then
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.2)
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.5)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (HumanoidRootPart.Position - targetPos).Unit
                    local backPos = HumanoidRootPart.Position + moveDir * 2
                    MoveTo(backPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            elseif persistentData.CurrentCombatBehavior == "offensive" then
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.6)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local forwardPos = HumanoidRootPart.Position + moveDir * 3
                    MoveTo(forwardPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.7)
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            else
                pcall(function() persistentData.LinkedSword:Activate() end)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local strafeDir = moveDir:Cross(Vector3.new(0, 1, 0)).Unit
                    
                    if math.random() > 0.5 then
                        strafeDir = -strafeDir
                    end
                    
                    local strafePos = HumanoidRootPart.Position + strafeDir * CONFIG.STRAFE_DISTANCE
                    MoveTo(strafePos)
                end
                
                wait(CONFIG.LUNGE_DELAY)
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local approachPos = HumanoidRootPart.Position + moveDir * 2
                    MoveTo(approachPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
            end
            
            wait(0.2)
            persistentData.AttackSequenceActive = false
        end)
    end
    
    -- Optimized memory cleanup
    local function PerformMemoryCleanup()
        local currentTime = tick()
        
        -- Clean up path cache
        local oldestTime = math.huge
        local oldestKey = nil
        local cacheCount = 0
        
        for k, v in pairs(persistentData.PathCache) do
            cacheCount = cacheCount + 1
            if v.time < oldestTime then
                oldestTime = v.time
                oldestKey = k
            end
        end
        
        if cacheCount > CONFIG.PATH_CACHE_MAX_SIZE then
            persistentData.PathCache[oldestKey] = nil
        end
        
        -- Clean up failed paths
        for i = #persistentData.FailedPaths, 1, -1 do
            if currentTime - persistentData.FailedPaths[i].time > 20 then
                table.remove(persistentData.FailedPaths, i)
            end
        end
        
        -- Clean up void areas
        if #persistentData.KnownVoidAreas > CONFIG.VOID_AREAS_MAX_SIZE then
            local removeCount = #persistentData.KnownVoidAreas - CONFIG.VOID_AREAS_MAX_SIZE
            for i = 1, removeCount do
                table.remove(persistentData.KnownVoidAreas, 1)
            end
        end
        
        persistentData.PerformanceStats.LastOptimizationTime = currentTime
    end
    
    -- Main update function with frame throttling
    local function Update()
        persistentData.FrameCounter = persistentData.FrameCounter + 1
        
        -- Only process heavy operations every Nth frame
        local shouldProcessHeavy = (persistentData.FrameCounter % CONFIG.UPDATE_THROTTLE == 0)
        
        if shouldProcessHeavy then
            PerformMemoryCleanup()
            CheckForSword()
        end
        
        local currentTime = tick()
        local needNewTarget = not persistentData.CurrentTarget or 
                             not persistentData.CurrentTarget.Character or 
                             not persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        
        local checkForCloserTarget = currentTime - persistentData.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME
        
        if (needNewTarget or checkForCloserTarget) and shouldProcessHeavy then
            local playersInRange = FindPlayersInRange()
            
            if #playersInRange > 0 then
                local newTarget = playersInRange[1].player
                
                if newTarget ~= persistentData.CurrentTarget then
                    persistentData.CurrentTarget = newTarget
                    if persistentData.StatusGUI then 
                        persistentData.StatusGUI.UpdateTarget(newTarget.Name)
                    end
                end
            else
                persistentData.CurrentTarget = nil
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateTarget("None")
                end
            end
            
            persistentData.LastRetargetTime = currentTime
        end
        
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetHRP = persistentData.CurrentTarget.Character.HumanoidRootPart
            local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
            
            -- Update GUI less frequently
            if persistentData.StatusGUI and (persistentData.FrameCounter % CONFIG.GUI_UPDATE_INTERVAL == 0) then
                persistentData.StatusGUI.UpdateDistance(distance)
            end
            
            if CheckIfStuck() then
                if shouldProcessHeavy then
                    HandleStuckOnPlayer()
                end
                return
            else
                persistentData.IsStuck = false
            end
            
            if shouldProcessHeavy then
                local isSafe, bridgePath, alternativePath = IsSafePath(targetHRP.Position)
                
                if CONFIG.PERFORMANCE_MODE then
                    persistentData.PerformanceStats.PathfindingTime = tick() - currentTime
                end
                
                if isSafe then
                    MoveTo(targetHRP.Position, bridgePath)
                    HumanoidRootPart.CFrame = CFrame.lookAt(
                        HumanoidRootPart.Position, 
                        Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
                    )
                    
                    if distance <= CONFIG.ATTACK_RANGE and 
                       persistentData.LinkedSword and 
                       currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        ExecuteAttack()
                    elseif distance <= CONFIG.MIN_ATTACK_DISTANCE and 
                           persistentData.LinkedSword and 
                           currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        persistentData.CurrentCombatBehavior = "offensive"
                        ExecuteAttack()
                    end
                elseif alternativePath then
                    MoveTo(alternativePath)
                    HumanoidRootPart.CFrame = CFrame.lookAt(
                        HumanoidRootPart.Position, 
                        Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
                    )
                    
                    if distance <= CONFIG.ATTACK_RANGE and 
                       persistentData.LinkedSword and 
                       currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        ExecuteAttack()
                    end
                else
                    local bridgePath = FindBridgePath(HumanoidRootPart.Position, targetHRP.Position)
                    if bridgePath then
                        MoveTo(bridgePath)
                        return
                    end
                    
                    local alternativeDirections = {
                        Vector3.new(1, 0, 0), Vector3.new(-1, 0, 0), Vector3.new(0, 0, 1), Vector3.new(0, 0, -1),
                        Vector3.new(1, 0, 1).Unit, Vector3.new(-1, 0, 1).Unit, Vector3.new(1, 0, -1).Unit, Vector3.new(-1, 0, -1).Unit
                    }
                    
                    for i = 1, #alternativeDirections do
                        local alternativeTarget = HumanoidRootPart.Position + alternativeDirections[i] * 10
                        local altSafe, altBridgePath = IsSafePath(alternativeTarget)
                        
                        if altSafe then
                            MoveTo(alternativeTarget, altBridgePath)
                            break
                        end
                    end
                end
            else
                -- Light processing: just face target and basic movement
                if persistentData.LastMovementDirection then
                    Humanoid:Move(persistentData.LastMovementDirection)
                end
                
                HumanoidRootPart.CFrame = CFrame.lookAt(
                    HumanoidRootPart.Position, 
                    Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
                )
                
                -- Quick attack check even in light frames
                if distance <= CONFIG.ATTACK_RANGE and 
                   persistentData.LinkedSword and 
                   currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    ExecuteAttack()
                end
            end
        else
            if persistentData.StatusGUI and shouldProcessHeavy then
                persistentData.StatusGUI.UpdateStatus("Idle")
            end
        end
    end
    
    -- Handle sword equipping on respawn
    spawn(function()
        wait(CONFIG.RESPAWN_EQUIP_DELAY)
        
        persistentData.LinkedSword = FindLinkedSword()
        if persistentData.LinkedSword then
            if persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword.Parent = Character
                wait(0.5)
                
                if persistentData.LinkedSword.Parent == Character then
                    persistentData.EquipmentReady = true
                else
                    wait(0.5)
                    if persistentData.LinkedSword then
                        persistentData.LinkedSword.Parent = Character
                        wait(0.5)
                        persistentData.EquipmentReady = true
                    end
                end
            else
                persistentData.EquipmentReady = true
            end
        end
    end)
    
    -- Initialize
    persistentData.LinkedSword = FindLinkedSword()
    persistentData.LastSwordCheckTime = tick()
    persistentData.FrameCounter = 0
    
    -- Connect optimized update function
    local updateConnection
    updateConnection = RunService.Heartbeat:Connect(function()
        local success, error = pcall(Update)
        if not success then
            forcePrint("LinkedSwordAI: Error in update - " .. tostring(error))
        end
    end)
    
    -- Handle character respawn
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        forcePrint("LinkedSwordAI: Character respawned, reinitializing...")
        wait(1)
        InitializeAI()
    end)
    
    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("AI Running (Optimized)") end
    forcePrint("LinkedSwordAI: Optimized script initialized successfully")
    
    return true
end

-- Start the AI
local success, errorMsg = pcall(InitializeAI)

if not success then
    forcePrint("LinkedSwordAI: Critical error - " .. tostring(errorMsg))
end
