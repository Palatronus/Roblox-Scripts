-- LinkedSwordAI_Fixed.lua
-- Fixed version based on the working third previous script

local function forcePrint(...)
    local args = {...}
    local message = table.concat(args, " ")
    print("LinkedSwordAI: " .. message)
end

forcePrint("Loading fixed version...")

-- Configuration
local CONFIG = {
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.8,
    DETECTION_RANGE = 100,
    VOID_Y_LEVEL = -20,
    EQUIP_DELAY = 0.5,
    RETARGET_DELAY = 1,
    FORCEFIELD_FLEE_DISTANCE = 25
}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

if not LocalPlayer then
    forcePrint("Error: No local player")
    return
end

-- Main AI function
local function StartAI()
    forcePrint("Initializing AI...")
    
    -- Wait for character
    local character = LocalPlayer.Character
    if not character then
        character = LocalPlayer.CharacterAdded:Wait()
        wait(1)
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    
    forcePrint("Character loaded")
    
    -- Find sword
    local sword = nil
    for _, item in pairs(character:GetChildren()) do
        if item:IsA("Tool") then
            sword = item
            forcePrint("Found sword: " .. sword.Name)
            break
        end
    end
    
    if not sword then
        local backpack = LocalPlayer:FindFirstChild("Backpack")
        if backpack then
            for _, item in pairs(backpack:GetChildren()) do
                if item:IsA("Tool") then
                    sword = item
                    humanoid:EquipTool(sword)
                    wait(0.2)
                    forcePrint("Equipped sword: " .. sword.Name)
                    break
                end
            end
        end
    end

    -- Enhanced void detection that actually prevents falling
    local function CheckVoidSafety(position)
        if position.Y < CONFIG.VOID_Y_LEVEL then
            return false
        end
        
        -- Raycast down to check for ground
        local rayOrigin = position + Vector3.new(0, 2, 0)
        local rayDirection = Vector3.new(0, -10, 0)
        local raycastResult = workspace:Raycast(rayOrigin, rayDirection)
        
        return raycastResult ~= nil
    end

    -- Check path to target for voids
    local function IsPathSafe(startPos, targetPos)
        local direction = (targetPos - startPos).Unit
        local distance = (targetPos - startPos).Magnitude
        
        -- Check points along the path
        for i = 5, math.min(distance, 20), 5 do
            local checkPoint = startPos + direction * i
            if not CheckVoidSafety(checkPoint) then
                return false, checkPoint
            end
        end
        
        return true, nil
    end

    -- Self-correction when above player
    local function CheckStuckAbovePlayer()
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
                if targetRoot then
                    local horizontalDist = (Vector3.new(rootPart.Position.X, 0, rootPart.Position.Z) - 
                                          Vector3.new(targetRoot.Position.X, 0, targetRoot.Position.Z)).Magnitude
                    local verticalDiff = rootPart.Position.Y - targetRoot.Position.Y
                    
                    if horizontalDist < 3 and verticalDiff > 5 then
                        return true, player
                    end
                end
            end
        end
        return false, nil
    end

    -- Main loop
    local lastAttack = 0
    local currentTarget = nil
    local lastRetarget = 0
    
    local connection
    connection = RunService.Heartbeat:Connect(function()
        -- Check if stuck above player first (highest priority)
        local isStuck, stuckPlayer = CheckStuckAbovePlayer()
        if isStuck then
            forcePrint("Stuck above player, moving away")
            local moveDir = (rootPart.Position - stuckPlayer.Character.HumanoidRootPart.Position).Unit
            humanoid:MoveTo(rootPart.Position + moveDir * 8)
            return
        end
        
        -- Check current position safety
        if not CheckVoidSafety(rootPart.Position) then
            forcePrint("In void! Moving to safety")
            humanoid:MoveTo(rootPart.Position + Vector3.new(10, 10, 10))
            return
        end
        
        -- Find closest player
        local closestPlayer = nil
        local closestDistance = CONFIG.DETECTION_RANGE
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
                local targetHumanoid = player.Character:FindFirstChild("Humanoid")
                
                if targetRoot and targetHumanoid and targetHumanoid.Health > 0 then
                    -- Skip players with forcefields
                    if player.Character:FindFirstChild("ForceField") then
                        -- Move away from forcefield players
                        if (targetRoot.Position - rootPart.Position).Magnitude < CONFIG.FORCEFIELD_FLEE_DISTANCE then
                            local fleeDir = (rootPart.Position - targetRoot.Position).Unit
                            humanoid:MoveTo(rootPart.Position + fleeDir * 15)
                            forcePrint("Fleeing from forcefield")
                            return
                        end
                    else
                        local distance = (targetRoot.Position - rootPart.Position).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestPlayer = player
                        end
                    end
                end
            end
        end
        
        -- Target selection
        if closestPlayer and (not currentTarget or tick() - lastRetarget > CONFIG.RETARGET_DELAY) then
            currentTarget = closestPlayer
            lastRetarget = tick()
            forcePrint("New target: " .. closestPlayer.Name)
        end
        
        -- Target engagement
        if currentTarget and currentTarget.Character then
            local targetRoot = currentTarget.Character.HumanoidRootPart
            local targetHumanoid = currentTarget.Character.Humanoid
            
            if targetRoot and targetHumanoid and targetHumanoid.Health > 0 then
                local distance = (targetRoot.Position - rootPart.Position).Magnitude
                
                -- Check if path to target is safe
                local pathSafe, unsafePoint = IsPathSafe(rootPart.Position, targetRoot.Position)
                
                if pathSafe then
                    -- Move to target
                    humanoid:MoveTo(targetRoot.Position)
                    
                    -- Face target
                    local lookDir = (targetRoot.Position - rootPart.Position).Unit
                    humanoid:MoveTo(rootPart.Position + lookDir * 0.5)
                    
                    -- Attack if in range
                    if distance <= CONFIG.ATTACK_RANGE and sword then
                        if tick() - lastAttack > CONFIG.ATTACK_COOLDOWN then
                            lastAttack = tick()
                            -- Execute attack combo
                            for i = 1, 3 do
                                if sword and sword.Parent then
                                    sword:Activate()
                                end
                                wait(0.1)
                            end
                            forcePrint("Attacking " .. currentTarget.Name)
                        end
                    end
                else
                    forcePrint("Unsafe path detected, avoiding void")
                    -- Move away from unsafe point
                    local safeDir = (rootPart.Position - unsafePoint).Unit
                    humanoid:MoveTo(rootPart.Position + safeDir * 5)
                end
            else
                currentTarget = nil
            end
        else
            currentTarget = nil
            -- Wander behavior when no target
            if math.random(1, 100) < 20 then
                local wanderPos = rootPart.Position + Vector3.new(math.random(-10, 10), 0, math.random(-10, 10))
                if CheckVoidSafety(wanderPos) then
                    humanoid:MoveTo(wanderPos)
                end
            end
        end
    end)
    
    -- Handle character death
    humanoid.Died:Connect(function()
        forcePrint("Character died")
        if connection then
            connection:Disconnect()
        end
    end)
    
    forcePrint("AI started successfully")
    return connection
end

-- Respawn handling
LocalPlayer.CharacterAdded:Connect(function(character)
    forcePrint("Character respawned")
    wait(2)
    StartAI()
end)

-- Start the AI
wait(3)
StartAI()

forcePrint("Script loaded successfully")
