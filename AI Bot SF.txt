-- Map terrain connectivity for more efficient pathfinding
    local function UpdateTerrainConnectivityMap(position)
        -- Only update occasionally to save performance
        if not persistentData.LastTerrainMapUpdate or 
           tick() - persistentData.LastTerrainMapUpdate > 5 then
            
            -- Create grid position key
            local gridX = math.floor(position.X / CONFIG.TERRAIN_GRID_SIZE)
            local gridZ = math.floor(position.Z / CONFIG.TERRAIN_GRID_SIZE)
            local gridKey = gridX .. "," .. gridZ
            
            -- Skip if we already mapped this area recently
            if persistentData.TerrainConnectivityMap[gridKey] and 
               tick() - persistentData.TerrainConnectivityMap[gridKey].timestamp < 30 then
                return
            end
            
            -- Map connected terrain in a radius
            local connectedPoints = {}
            local radius = CONFIG.TERRAIN_CONNECTIVITY_RADIUS
            local step = CONFIG.TERRAIN_GRID_SIZE
            
            -- Scan grid points in the area
            for x = -radius, radius, step do
                for z = -radius, radius, step do
                    -- Skip points too far away (circular radius)
                    if x*x + z*z > radius*radius then
                        continue
                    end
                    
                    -- Check if this point is safe terrain
                    local checkPos = Vector3.new(
                        position.X + x,
                        position.Y,
                        position.Z + z
                    )
                    
                    -- Apply throttling to reduce raycast count
                    if math.random() <= CONFIG.RAYCAST_THROTTLE_FACTOR then
                        local isVoid = IsVoidArea(checkPos, false)
                        if not isVoid then
                            -- This is safe terrain, add to connected points
                            table.insert(connectedPoints, {
                                position = checkPos,
                                gridX = math.floor(checkPos.X / CONFIG.TERRAIN_GRID_SIZE),
                                gridZ = math.floor(checkPos.Z / CONFIG.TERRAIN_GRID_SIZE)
                            })
                        end
                    end
                end
            end
            
            -- Store the connectivity map
            persistentData.TerrainConnectivityMap[gridKey] = {
                center = position,
                points = connectedPoints,
                timestamp = tick()
            }
            
            persistentData.LastTerrainMapUpdate = tick()
            debugPrint("TERRAIN", "Updated terrain connectivity map with " .. #connectedPoints .. " safe points")
        end
    end
    
    -- Check if path to target is safe (no voids)
    local function IsSafePath(targetPosition)
        -- Apply path calculation throttling to reduce CPU usage
        if CONFIG.PATH_CALCULATION_THROTTLE < 1 and math.random() > CONFIG.PATH_CALCULATION_THROTTLE then
            -- Use last known result or default to safe for throttled calculations
            local lastResult = persistentData.LastPathResult or {safe = true, bridgePath = nil, alternativePath = nil}
            return lastResult.safe, lastResult.bridgePath, lastResult.alternativePath
        end
        
        -- Performance optimization: Check cache first using hash-based lookup
        if CONFIG.PERFORMANCE_MODE then
            local currentTime = tick()
            -- Create a hash key for faster lookup (rounded to nearest unit)
            local hashKey = math.floor(targetPosition.X) .. "," .. 
                           math.floor(targetPosition.Y) .. "," .. 
                           math.floor(targetPosition.Z)
            
            local data = persistentData.PathCache[hashKey]
            if data and currentTime - data.time < CONFIG.PATH_CACHE_TIME then
                debugPrint("PATH", "Using cached path result: " .. (data.safe and "SAFE" or "UNSAFE"))
                persistentData.LastPathResult = data
                return data.safe, data.bridgePath, data.alternativePath
            end
        end
        
        -- Check if target is in a known safe terrain area from connectivity map
         local gridX = math.floor(targetPosition.X / CONFIG.TERRAIN_GRID_SIZE)
         local gridZ = math.floor(targetPosition.Z / CONFIG.TERRAIN_GRID_SIZE)
         local gridKey = gridX .. "," .. gridZ
         
         if persistentData.TerrainConnectivityMap[gridKey] then
             local mapData = persistentData.TerrainConnectivityMap[gridKey]
             -- If map is recent and has connected points, check if target is in a safe area
             if tick() - mapData.timestamp < 30 and #mapData.points > 0 then
                 -- Find closest point in connectivity map
                 local minDist = math.huge
                 local isSafe = false
                 
                 for _, point in ipairs(mapData.points) do
                     local dist = (point.position - targetPosition).Magnitude
                     if dist < minDist then
                         minDist = dist
                         -- If point is very close, consider it safe
                         if dist < CONFIG.TERRAIN_GRID_SIZE * 1.5 then
                             isSafe = true
                             break
                         end
                     end
                 end
                 
                 if isSafe then
                     debugPrint("PATH", "Target in known safe terrain area")
                     -- Cache this result
                     if CONFIG.PERFORMANCE_MODE then
                         local hashKey = math.floor(targetPosition.X) .. "," .. 
                                        math.floor(targetPosition.Y) .. "," .. 
                                        math.floor(targetPosition.Z)
                         
                         persistentData.PathCache[hashKey] = {
                             safe = true,
                             time = tick(),
                             bridgePath = nil,
                             alternativePath = nil
                         }
                         persistentData.LastPathResult = persistentData.PathCache[hashKey]
                     end
                     return true, nil, nil
                 end
             end
         end
         
         -- Start performance tracking
         local startTime = tick()
         
         -- Check if this path has failed recently using a more efficient approach
         local failedPathsCount = #persistentData.FailedPaths
         if failedPathsCount > 0 then
             -- Check most recent failed paths first (more likely to be relevant)
             for i = failedPathsCount, math.max(1, failedPathsCount - 3), -1 do
                 local failedPath = persistentData.FailedPaths[i]
                 if failedPath and (targetPosition - failedPath.position).Magnitude < 5 and 
                    tick() - failedPath.time < 10 then
                     -- Store this result for throttled calculations
                     persistentData.LastPathResult = {safe = false, bridgePath = nil, alternativePath = nil}
                     return false
                 end
             end
         end
         
         local startPos = HumanoidRootPart.Position
         local direction = (targetPosition - startPos).Unit
         local distance = (targetPosition - startPos).Magnitude
         
         -- Update terrain connectivity map for current position
         -- This helps build a map of safe terrain for future pathfinding
         UpdateTerrainConnectivityMap(startPos)
         
         -- Check if we're in a narrow passage
         local isNarrow = IsNarrowPassage(startPos, direction)
         
         -- If in narrow passage, use more careful pathfinding
         if isNarrow then
             -- Use smaller increments for narrow passages
             local narrowIncrement = math.min(2, distance / 8)
             
             for i = narrowIncrement, distance, narrowIncrement do
                 local checkPos = startPos + direction * i
                 
                 -- Check for walls on both sides
                 if not IsNarrowPassage(checkPos, direction) then
                     -- We've exited the narrow passage, check if it's safe
                     if IsVoidArea(checkPos) then
                         if #persistentData.FailedPaths >= 10 then
                             table.remove(persistentData.FailedPaths, 1)
                         end
                         table.insert(persistentData.FailedPaths, {
                             position = targetPosition,
                             time = tick()
                         })
                         
                         -- Cache the result with hash key
                         if CONFIG.PERFORMANCE_MODE then
                             local hashKey = math.floor(targetPosition.X) .. "," .. 
                                            math.floor(targetPosition.Y) .. "," .. 
                                            math.floor(targetPosition.Z)
                             
                             persistentData.PathCache[hashKey] = {
                                 safe = false,
                                 time = tick(),
                                 bridgePath = nil
                             }
                             persistentData.LastPathResult = persistentData.PathCache[hashKey]
                             
                             -- Limit cache size more efficiently
                             persistentData.PathCacheCount = (persistentData.PathCacheCount or 0) + 1
                             if persistentData.PathCacheCount > 20 then
                                 -- Clear oldest 25% of cache when limit reached
                                 local cacheEntries = {}
                                 for k, v in pairs(persistentData.PathCache) do
                                     table.insert(cacheEntries, {key = k, time = v.time})
                                 end
                                 
                                 -- Sort by time (oldest first)
                                 table.sort(cacheEntries, function(a, b) return a.time < b.time end)
                                 
                                 -- Remove oldest 25%
                                 local removeCount = math.floor(persistentData.PathCacheCount * 0.25)
                                 for i = 1, removeCount do
                                     if cacheEntries[i] then
                                         persistentData.PathCache[cacheEntries[i].key] = nil
                                     end
                                 end
                                 persistentData.PathCacheCount = persistentData.PathCacheCount - removeCount
                             end
                         end
                         
                         return false
                     end
                     
                     -- We've found a safe exit from the narrow passage
                     break
                 end
             end
         else
             -- Standard path checking with optimized increments
             for i = increment, distance, increment do
                 local checkPos = startPos + direction * i
                 
                 -- Use hash-based lookup for known void areas first
                 local posHash = math.floor(checkPos.X) .. "," .. 
                               math.floor(checkPos.Y) .. "," .. 
                               math.floor(checkPos.Z)
                               
                 if persistentData.VoidAreaHashes[posHash] then
                     -- Known void area, no need for expensive raycast
                     if #persistentData.FailedPaths >= 10 then
                         table.remove(persistentData.FailedPaths, 1)
                     end
                     table.insert(persistentData.FailedPaths, {
                         position = targetPosition,
                         time = tick()
                     })
                     
                     -- Cache the result with hash key
                     if CONFIG.PERFORMANCE_MODE then
                         local hashKey = math.floor(targetPosition.X) .. "," .. 
                                        math.floor(targetPosition.Y) .. "," .. 
                                        math.floor(targetPosition.Z)
                         
                         persistentData.PathCache[hashKey] = {
                             safe = false,
                             time = tick(),
                             bridgePath = nil
                         }
                         persistentData.LastPathResult = persistentData.PathCache[hashKey]
                     end
                     
                     -- Try to find a bridge path or alternative path immediately
                     local bridgePath = FindBridgePath(startPos, targetPosition)
                     if bridgePath then
                         return false, bridgePath, nil
                     end
                     
                     local alternativePath = FindAlternativePath(startPos, targetPosition)
                     if alternativePath then
                         return false, nil, alternativePath
                     end
                     
                     return false
                 end
                 
                 -- Check if position is in known safe area
                 if persistentData.SafeAreaHashes[posHash] then
                     -- Known safe area, skip expensive checks
                     continue
                 end
                 
                 -- Only perform expensive void check if not in known areas
                 if IsVoidArea(checkPos) then
                     if #persistentData.FailedPaths >= 10 then
                         table.remove(persistentData.FailedPaths, 1)
                     end
                     table.insert(persistentData.FailedPaths, {
                         position = targetPosition,
                         time = tick()
                     })
                     
                     -- Cache the result with hash key
                     if CONFIG.PERFORMANCE_MODE then
                         local hashKey = math.floor(targetPosition.X) .. "," .. 
                                        math.floor(targetPosition.Y) .. "," .. 
                                        math.floor(targetPosition.Z)
                         
                         persistentData.PathCache[hashKey] = {
                             safe = false,
                             time = tick(),
                             bridgePath = nil
                         }
                         persistentData.LastPathResult = persistentData.PathCache[hashKey]
                     end
                     
                     -- Try to find a bridge path immediately
                     local bridgePath = FindBridgePath(startPos, targetPosition)
                     if bridgePath then
                         return false, bridgePath, nil
                     end
                     
                     -- Try to find an alternative path immediately
                     local alternativePath = FindAlternativePath(startPos, targetPosition)
                     if alternativePath then
                         return false, nil, alternativePath
                     end
                     
                     return false
                 end
             end
             
             -- Path is safe
             -- Cache the result with hash key
             if CONFIG.PERFORMANCE_MODE then
                 local hashKey = math.floor(targetPosition.X) .. "," .. 
                               math.floor(targetPosition.Y) .. "," .. 
                               math.floor(targetPosition.Z)
                 
                 persistentData.PathCache[hashKey] = {
                     safe = true,
                     time = tick(),
                     bridgePath = nil,
                     alternativePath = nil
                 }
                 persistentData.LastPathResult = persistentData.PathCache[hashKey]
             end
             
             -- Track performance
             local endTime = tick()
             local elapsedTime = endTime - startTime
             persistentData.PathfindingStats = persistentData.PathfindingStats or {
                 totalTime = 0,
                 callCount = 0,
                 maxTime = 0
             }
             persistentData.PathfindingStats.totalTime = persistentData.PathfindingStats.totalTime + elapsedTime
             persistentData.PathfindingStats.callCount = persistentData.PathfindingStats.callCount + 1
             persistentData.PathfindingStats.maxTime = math.max(persistentData.PathfindingStats.maxTime, elapsedTime)
             
             return true, nil, nil
         end
         end
