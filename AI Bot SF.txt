--[[
    Linked Sword AI Combat Script (Advanced Optimization)
    
    This script implements autonomous sword fighting AI for the Linked Sword tool in Roblox.
    Advanced performance optimizations with expanded pathfinding and improved void avoidance.
]]

-- Force print to output console immediately
local function forcePrint(...)
    local message = table.concat({...}, " ")
    print(message)
    print("") -- Force flush
end

-- Debug function with timestamps
local function debugPrint(category, ...)
    local args = {...}
    local message = "[" .. category .. "] " .. table.concat(args, " ")
    local timestamp = os.date("%H:%M:%S")
    forcePrint(timestamp .. " - " .. message)
end

forcePrint("LinkedSwordAI: Script starting...")
debugPrint("INIT", "Debug logging enabled")

-- Global persistent data to maintain state across respawns
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {},
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        MovementHistory = {},
        FailedPaths = {},
        LastEquipAttempt = 0,
        EquipmentReady = false,
        KnownVoidAreas = {},
        PathCache = {},
        LastPathfindingTime = 0,
        PerformanceStats = {
            PathfindingTime = 0,
            CombatTime = 0,
            MovementTime = 0,
            LastOptimizationTime = 0
        },
        -- Enhanced performance optimization fields
        FrameCounter = 0,
        LastCleanupTime = 0,
        CachedPlayers = {},
        LastPlayerCacheUpdate = 0,
        SafeTerrainCache = {}, -- NEW: Cache for safe terrain areas
        LastTerrainScan = 0,   -- NEW: Track last terrain scan
        PathfindingQueue = {}, -- NEW: Queue for pathfinding operations
        ImmediateSafeDirections = {} -- NEW: Pre-calculated safe directions
    }
end

local persistentData = _G.LinkedSwordAIPersistentData

-- Configuration with enhanced performance optimizations
local CONFIG = {
    DETECTION_RADIUS = 200,
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.7,
    LUNGE_DELAY = 0.1,
    STUCK_CHECK_DISTANCE = 1.5,
    STUCK_CHECK_TIME = 1.0,
    MAX_TARGET_DISTANCE = 250,
    MIN_HEALTH_CHECK = 0,
    RETARGET_CHECK_TIME = 1.5,
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -100,
    FORCEFIELD_FLEE_DISTANCE = 0,
    SWORD_CHECK_INTERVAL = 7,
    RESPAWN_EQUIP_DELAY = 1.5,
    MOVEMENT_MEMORY_TIME = 0.7,
    SAFE_GAP_DISTANCE = 10,
    PATH_SMOOTHING_FACTOR = 0.7,
    MOVEMENT_RETRY_DELAY = 1.0,
    NARROW_PASSAGE_WIDTH = 3.5,
    PATHFINDING_STEPS = 10,
    COMBAT_BEHAVIOR_CHANGE_TIME = 4.0,
    COMBAT_DEFENSIVE_CHANCE = 0.25,
    COMBAT_OFFENSIVE_CHANCE = 0.45,
    STRAFE_DISTANCE = 4,
    BRIDGE_CHECK_DISTANCE = 25,
    PERFORMANCE_MODE = true,
    PATH_CACHE_TIME = 3.0,
    MIN_ATTACK_DISTANCE = 3,
    -- Enhanced performance optimization settings
    UPDATE_THROTTLE = 2,
    MAX_PLAYER_CACHE_TIME = 1.0,
    PATH_CACHE_MAX_SIZE = 12, -- Further reduced
    FAILED_PATHS_MAX_SIZE = 6, -- Further reduced
    VOID_AREAS_MAX_SIZE = 25, -- Further reduced
    GUI_UPDATE_INTERVAL = 15, -- Less frequent GUI updates
    -- NEW: Enhanced pathfinding and navigation
    EXPANDED_DIRECTIONS = 16, -- Increased from 7 to 16 directions
    TERRAIN_SCAN_INTERVAL = 0.5, -- Scan nearby terrain every 0.5 seconds
    IMMEDIATE_REROUTE_DISTANCE = 8, -- Distance for immediate rerouting
    PROXIMITY_CHECK_RADIUS = 12, -- Radius for proximity safety checks
    CONNECTED_GROUND_DEPTH = 5, -- Depth to check for connected ground
    QUICK_SAFETY_CHECKS = 4, -- Number of quick safety checks per frame
    PATHFINDING_BATCH_SIZE = 2 -- Process pathfinding in smaller batches
}

-- Create status GUI
local function CreateStatusGUI()
    local gui = {}
    
    local parentOptions = {
        game:GetService("CoreGui"),
        game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui"),
        game:GetService("Players").LocalPlayer.Character
    }
    
    local screenGui
    for _, parent in ipairs(parentOptions) do
        if parent then
            local success, result = pcall(function()
                local newGui = Instance.new("ScreenGui")
                newGui.Name = "LinkedSwordAI_Status"
                newGui.Parent = parent
                return newGui
            end)
            
            if success then
                screenGui = result
                break
            end
        end
    end
    
    if not screenGui then
        forcePrint("LinkedSwordAI: Failed to create GUI - No valid parent found")
        return nil
    end
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 120)
    frame.Position = UDim2.new(0.8, 0, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.5
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    frame.Parent = screenGui
    
    local status = Instance.new("TextLabel")
    status.Size = UDim2.new(1, -10, 0, 20)
    status.Position = UDim2.new(0, 5, 0, 5)
    status.BackgroundTransparency = 1
    status.TextColor3 = Color3.fromRGB(255, 255, 255)
    status.Text = "Status: Initializing..."
    status.Font = Enum.Font.SourceSans
    status.TextSize = 14
    status.TextXAlignment = Enum.TextXAlignment.Left
    status.Parent = frame
    
    local target = Instance.new("TextLabel")
    target.Size = UDim2.new(1, -10, 0, 20)
    target.Position = UDim2.new(0, 5, 0, 30)
    target.BackgroundTransparency = 1
    target.TextColor3 = Color3.fromRGB(255, 150, 150)
    target.Text = "Target: None"
    target.Font = Enum.Font.SourceSans
    target.TextSize = 14
    target.TextXAlignment = Enum.TextXAlignment.Left
    target.Parent = frame
    
    local distance = Instance.new("TextLabel")
    distance.Size = UDim2.new(1, -10, 0, 20)
    distance.Position = UDim2.new(0, 5, 0, 55)
    distance.BackgroundTransparency = 1
    distance.TextColor3 = Color3.fromRGB(150, 255, 150)
    distance.Text = "Distance: N/A"
    distance.Font = Enum.Font.SourceSans
    distance.TextSize = 14
    distance.TextXAlignment = Enum.TextXAlignment.Left
    distance.Parent = frame
    
    local debug = Instance.new("TextLabel")
    debug.Size = UDim2.new(1, -10, 0, 20)
    debug.Position = UDim2.new(0, 5, 0, 80)
    debug.BackgroundTransparency = 1
    debug.TextColor3 = Color3.fromRGB(255, 255, 0)
    debug.Text = "Debug: Starting..."
    debug.Font = Enum.Font.SourceSans
    debug.TextSize = 14
    debug.TextXAlignment = Enum.TextXAlignment.Left
    debug.Parent = frame
    
    function gui.UpdateStatus(text)
        if status then
            status.Text = "Status: " .. text
        end
    end
    
    function gui.UpdateTarget(text)
        if target then
            target.Text = "Target: " .. text
        end
    end
    
    function gui.UpdateDistance(dist)
        if distance then
            distance.Text = "Distance: " .. (dist and string.format("%.1f", dist) or "N/A")
        end
    end
    
    function gui.UpdateDebug(text)
        if debug then
            debug.Text = "Debug: " .. text
        end
    end
    
    return gui
end

-- Main execution in protected call
local function InitializeAI()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    
    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        forcePrint("LinkedSwordAI: LocalPlayer not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: LocalPlayer found - " .. LocalPlayer.Name)
    
    local Character = LocalPlayer.Character
    if not Character then
        forcePrint("LinkedSwordAI: Character not found")
        return false
    end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    
    if not Humanoid or not HumanoidRootPart then
        forcePrint("LinkedSwordAI: Humanoid or HumanoidRootPart not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: Character components found")
    
    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
        if persistentData.StatusGUI then
            forcePrint("LinkedSwordAI: Status GUI created")
        end
    end
    
    -- Find the Linked Sword tool (optimized)
    local function FindLinkedSword()
        if persistentData.SwordToolName then
            local storedSword = Character:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                return storedSword
            end
            
            storedSword = LocalPlayer.Backpack:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                return storedSword
            end
        end
        
        for _, tool in pairs(Character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        
        return nil
    end
    
    -- Check for sword periodically (optimized)
    local function CheckForSword()
        local currentTime = tick()
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword = FindLinkedSword()
            end
            persistentData.LastSwordCheckTime = currentTime
        end
    end
    
    -- Cache players for better performance
    local function UpdatePlayerCache()
        local currentTime = tick()
        if currentTime - persistentData.LastPlayerCacheUpdate < CONFIG.MAX_PLAYER_CACHE_TIME then
            return persistentData.CachedPlayers
        end
        
        persistentData.CachedPlayers = {}
        local players = Players:GetPlayers()
        
        for i = 1, #players do
            local player = players[i]
            if player ~= LocalPlayer and player.Character then
                persistentData.CachedPlayers[#persistentData.CachedPlayers + 1] = player
            end
        end
        
        persistentData.LastPlayerCacheUpdate = currentTime
        return persistentData.CachedPlayers
    end
    
    -- Find players in range (optimized)
    local function FindPlayersInRange()
        local playersInRange = {}
        local cachedPlayers = UpdatePlayerCache()
        local myPosition = HumanoidRootPart.Position
        
        for i = 1, #cachedPlayers do
            local player = cachedPlayers[i]
            if player.Character then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                
                if humanoid and hrp and humanoid.Health > CONFIG.MIN_HEALTH_CHECK then
                    local distance = (hrp.Position - myPosition).Magnitude
                    
                    if distance <= CONFIG.DETECTION_RADIUS then
                        local hasForceField = false
                        local children = player.Character:GetChildren()
                        for j = 1, #children do
                            if children[j]:IsA("ForceField") then
                                hasForceField = true
                                persistentData.PlayersWithForceField[player.Name] = player
                                break
                            end
                        end
                        
                        if not hasForceField and persistentData.PlayersWithForceField[player.Name] then
                            persistentData.PlayersWithForceField[player.Name] = nil
                        end
                        
                        playersInRange[#playersInRange + 1] = {
                            player = player,
                            distance = distance,
                            hasForceField = hasForceField
                        }
                    end
                end
            end
        end
        
        table.sort(playersInRange, function(a, b)
            return a.distance < b.distance
        end)
        
        return playersInRange
    end
    
    -- NEW: Quick safety check for immediate positions
    local function QuickSafetyCheck(position)
        -- Fast Y-check first
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            return false
        end
        
        -- Quick raycast check
        local ray = Ray.new(position, Vector3.new(0, -5, 0))
        return Workspace:FindPartOnRay(ray, Character) ~= nil
    end
    
    -- NEW: Scan nearby terrain for safe areas
    local function ScanNearbyTerrain()
        local currentTime = tick()
        if currentTime - persistentData.LastTerrainScan < CONFIG.TERRAIN_SCAN_INTERVAL then
            return persistentData.SafeTerrainCache
        end
        
        persistentData.SafeTerrainCache = {}
        local basePos = HumanoidRootPart.Position
        
        -- Generate expanded directions (16 instead of 7)
        local directions = {}
        for i = 0, CONFIG.EXPANDED_DIRECTIONS - 1 do
            local angle = (i / CONFIG.EXPANDED_DIRECTIONS) * 2 * math.pi
            local dir = Vector3.new(math.cos(angle), 0, math.sin(angle))
            directions[#directions + 1] = dir
        end
        
        -- Check each direction for safe terrain
        for i = 1, #directions do
            local dir = directions[i]
            local checkPos = basePos + dir * CONFIG.PROXIMITY_CHECK_RADIUS
            
            if QuickSafetyCheck(checkPos) then
                -- Check if this area is connected to current position
                local connected = true
                local stepPos = basePos
                local steps = math.ceil(CONFIG.PROXIMITY_CHECK_RADIUS / 2)
                
                for step = 1, steps do
                    stepPos = stepPos + dir * 2
                    if not QuickSafetyCheck(stepPos) then
                        connected = false
                        break
                    end
                end
                
                if connected then
                    persistentData.SafeTerrainCache[#persistentData.SafeTerrainCache + 1] = {
                        position = checkPos,
                        direction = dir,
                        distance = CONFIG.PROXIMITY_CHECK_RADIUS
                    }
                end
            end
        end
        
        persistentData.LastTerrainScan = currentTime
        return persistentData.SafeTerrainCache
    end
    
    -- NEW: Get immediate safe directions for instant rerouting
    local function GetImmediateSafeDirections(targetPosition)
        local safeDirs = ScanNearbyTerrain()
        local basePos = HumanoidRootPart.Position
        local targetDir = (targetPosition - basePos).Unit
        
        -- Score each safe direction by how close it is to target direction
        local scoredDirections = {}
        
        for i = 1, #safeDirs do
            local safeDir = safeDirs[i]
            local dotProduct = safeDir.direction:Dot(targetDir)
            local distanceScore = 1 - (safeDir.distance / CONFIG.PROXIMITY_CHECK_RADIUS)
            local totalScore = (dotProduct + 1) * 0.5 * 0.7 + distanceScore * 0.3 -- Weighted scoring
            
            scoredDirections[#scoredDirections + 1] = {
                position = safeDir.position,
                direction = safeDir.direction,
                score = totalScore
            }
        end
        
        -- Sort by score (highest first)
        table.sort(scoredDirections, function(a, b)
            return a.score > b.score
        end)
        
        return scoredDirections
    end
    
    -- Optimized void area check using pre-scanned terrain
    local function IsVoidArea(position)
        -- Quick check against known void areas
        for i = 1, math.min(#persistentData.KnownVoidAreas, 10) do
            if (position - persistentData.KnownVoidAreas[i]).Magnitude < 5 then
                return true
            end
        end
        
        -- Use pre-scanned terrain data when available
        local safeTerrain = persistentData.SafeTerrainCache
        for i = 1, #safeTerrain do
            if (position - safeTerrain[i].position).Magnitude < 3 then
                return false -- Position is in known safe area
            end
        end
        
        -- Fallback to standard checks
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            if #persistentData.KnownVoidAreas < CONFIG.VOID_AREAS_MAX_SIZE then
                persistentData.KnownVoidAreas[#persistentData.KnownVoidAreas + 1] = position
            else
                table.remove(persistentData.KnownVoidAreas, 1)
                persistentData.KnownVoidAreas[#persistentData.KnownVoidAreas + 1] = position
            end
            return true
        end
        
        local ray = Ray.new(position, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
        local hit = Workspace:FindPartOnRay(ray, Character)
        
        if not hit then
            if #persistentData.KnownVoidAreas < CONFIG.VOID_AREAS_MAX_SIZE then
                persistentData.KnownVoidAreas[#persistentData.KnownVoidAreas + 1] = position
            else
                table.remove(persistentData.KnownVoidAreas, 1)
                persistentData.KnownVoidAreas[#persistentData.KnownVoidAreas + 1] = position
            end
            return true
        end
        
        return false
    end
    
    -- Optimized safe gap check
    local function IsSafeGap(startPos, endPos)
        local distance = (endPos - startPos).Magnitude
        
        if distance < 3 then
            return not IsVoidArea(endPos)
        end
        
        if distance < CONFIG.SAFE_GAP_DISTANCE then
            return QuickSafetyCheck(endPos)
        end
        
        local direction = (endPos - startPos).Unit
        local checkCount = math.ceil(distance / 3) -- Reduced check frequency
        
        for i = 1, checkCount do
            local checkPoint = startPos + direction * (i * 3)
            if not QuickSafetyCheck(checkPoint) then
                return false
            end
        end
        
        return true
    end
    
    -- Check if a passage is narrow (optimized)
    local function IsNarrowPassage(position, direction)
        local leftRay = Ray.new(position, direction:Cross(Vector3.new(0, 1, 0)).Unit * CONFIG.NARROW_PASSAGE_WIDTH)
        local rightRay = Ray.new(position, direction:Cross(Vector3.new(0, 1, 0)).Unit * -CONFIG.NARROW_PASSAGE_WIDTH)
        
        return Workspace:FindPartOnRay(leftRay, Character) and Workspace:FindPartOnRay(rightRay, Character)
    end
    
    -- Find bridge path (optimized)
    local function FindBridgePath(startPos, endPos)
        local direction = (endPos - startPos).Unit
        local distance = (endPos - startPos).Magnitude
        
        -- Reduced check frequency for performance
        for dist = 5, math.min(CONFIG.BRIDGE_CHECK_DISTANCE, distance), 8 do
            local checkPoint = startPos + direction * dist
            
            for y = 0, -20, -4 do -- Reduced y-check frequency
                local bridgeCheckPoint = checkPoint + Vector3.new(0, y, 0)
                local ray = Ray.new(bridgeCheckPoint, Vector3.new(0, -5, 0))
                local hit, hitPos = Workspace:FindPartOnRay(ray, Character)
                
                if hit then
                    local bridgePath = hitPos + Vector3.new(0, 3, 0)
                    if IsSafeGap(startPos, bridgePath) then
                        return bridgePath
                    end
                end
            end
        end
        
        return nil
    end
    
    -- NEW: Fast path safety check using pre-computed data
    local function FastPathSafetyCheck(targetPosition)
        local startPos = HumanoidRootPart.Position
        local distance = (targetPosition - startPos).Magnitude
        
        -- Use immediate safe directions for quick rerouting
        if distance < CONFIG.IMMEDIATE_REROUTE_DISTANCE then
            local safeDirs = GetImmediateSafeDirections(targetPosition)
            if #safeDirs > 0 then
                return true, nil, safeDirs[1].position
            end
        end
        
        -- Standard path checking for longer distances
        local direction = (targetPosition - startPos).Unit
        local increment = math.min(6, distance / 4) -- Reduced check frequency
        
        for i = increment, distance, increment do
            local checkPos = startPos + direction * i
            if IsVoidArea(checkPos) then
                return false
            end
        end
        
        return not IsVoidArea(targetPosition)
    end
    
    -- Check if path to target is safe (highly optimized)
    local function IsSafePath(targetPosition)
        if CONFIG.PERFORMANCE_MODE then
            local currentTime = tick()
            for cachedPath, data in pairs(persistentData.PathCache) do
                if (Vector3.new(cachedPath.x, cachedPath.y, cachedPath.z) - targetPosition).Magnitude < 5 and 
                   currentTime - data.time < CONFIG.PATH_CACHE_TIME then
                    return data.safe, data.bridgePath
                end
            end
        end
        
        local startTime = tick()
        
        -- Check failed paths
        for i = 1, #persistentData.FailedPaths do
            local failedPath = persistentData.FailedPaths[i]
            if (targetPosition - failedPath.position).Magnitude < 5 and 
               tick() - failedPath.time < 10 then
                return false
            end
        end
        
        -- Use fast safety check first
        local isSafe, bridgePath, alternativePath = FastPathSafetyCheck(targetPosition)
        
        if isSafe and alternativePath then
            -- We have an immediate safe alternative
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PathCache[targetPosition] = {
                    safe = false,
                    time = tick(),
                    bridgePath = nil
                }
                persistentData.PerformanceStats.PathfindingTime = tick() - startTime
            end
            return false, nil, alternativePath
        elseif isSafe then
            -- Path is safe
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PathCache[targetPosition] = {
                    safe = true,
                    time = tick(),
                    bridgePath = nil
                }
                persistentData.PerformanceStats.PathfindingTime = tick() - startTime
            end
            return true
        end
        
        -- Path is unsafe, try bridge finding
        local bridgePath = FindBridgePath(HumanoidRootPart.Position, targetPosition)
        if bridgePath then
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PathCache[targetPosition] = {
                    safe = true,
                    time = tick(),
                    bridgePath = bridgePath
                }
                persistentData.PerformanceStats.PathfindingTime = tick() - startTime
            end
            return true, bridgePath
        end
        
        -- Remember failed path
        if #persistentData.FailedPaths >= CONFIG.FAILED_PATHS_MAX_SIZE then
            table.remove(persistentData.FailedPaths, 1)
        end
        persistentData.FailedPaths[#persistentData.FailedPaths + 1] = {
            position = targetPosition,
            time = tick()
        }
        
        if CONFIG.PERFORMANCE_MODE then
            persistentData.PathCache[targetPosition] = {
                safe = false,
                time = tick(),
                bridgePath = nil
            }
            persistentData.PerformanceStats.PathfindingTime = tick() - startTime
        end
        
        return false
    end
    
    -- Check if we're stuck on a player (optimized)
    local function CheckIfStuck()
        if not persistentData.LastStuckPosition then
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = tick()
            return false
        end
        
        local currentTime = tick()
        local timeDiff = currentTime - persistentData.LastStuckTime
        
        if timeDiff > CONFIG.STUCK_CHECK_TIME then
            local distance = (HumanoidRootPart.Position - persistentData.LastStuckPosition).Magnitude
            
            if distance < CONFIG.STUCK_CHECK_DISTANCE then
                persistentData.IsStuck = true
                return true
            end
            
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = currentTime
        end
        
        return false
    end
    
    -- Handle being stuck on a player (optimized)
    local function HandleStuckOnPlayer()
        local directions = {}
        for i = 0, CONFIG.EXPANDED_DIRECTIONS - 1 do
            local angle = (i / CONFIG.EXPANDED_DIRECTIONS) * 2 * math.pi
            local dir = Vector3.new(math.cos(angle), 0, math.sin(angle))
            directions[#directions + 1] = dir
        end
        
        for i = 1, #directions do
            local targetPosition = HumanoidRootPart.Position + directions[i] * 5
            if FastPathSafetyCheck(targetPosition) then
                Humanoid:MoveTo(targetPosition)
                return true
            end
        end
        
        return false
    end
    
    -- NEW: Immediate movement without pauses
    local function ImmediateMoveTo(targetPosition, bridgePath, alternativePath)
        if bridgePath then
            targetPosition = bridgePath
        end
        
        if alternativePath then
            targetPosition = alternativePath
        end
        
        local currentDirection = (targetPosition - HumanoidRootPart.Position).Unit
        local currentTime = tick()
        
        -- Apply smoothing
        local smoothedDirection = currentDirection
        if persistentData.LastMovementDirection and 
           currentTime - persistentData.LastMovementTime < CONFIG.MOVEMENT_MEMORY_TIME then
            smoothedDirection = (persistentData.LastMovementDirection * CONFIG.PATH_SMOOTHING_FACTOR + 
                               currentDirection * (1 - CONFIG.PATH_SMOOTHING_FACTOR)).Unit
        end
        
        -- Use pre-scanned safe terrain for immediate movement
        local safeDirs = GetImmediateSafeDirections(targetPosition)
        if #safeDirs > 0 then
            -- Choose the best safe direction that's close to our desired direction
            local bestDir = safeDirs[1].direction
            local dotWithDesired = bestDir:Dot(smoothedDirection)
            
            if dotWithDesired > 0.3 then -- Only use if reasonably aligned
                smoothedDirection = bestDir
            end
        end
        
        local moveDistance = math.min(4, (targetPosition - HumanoidRootPart.Position).Magnitude)
        local smoothedTarget = HumanoidRootPart.Position + smoothedDirection * moveDistance
        
        -- Quick safety check for immediate movement
        if QuickSafetyCheck(smoothedTarget) then
            persistentData.LastMovementDirection = smoothedDirection
            persistentData.LastMovementTime = currentTime
            Humanoid:MoveTo(smoothedTarget)
            return true
        else
            -- Immediate reroute using safe directions
            for i = 1, math.min(#safeDirs, 3) do
                local safeTarget = HumanoidRootPart.Position + safeDirs[i].direction * 3
                if QuickSafetyCheck(safeTarget) then
                    Humanoid:MoveTo(safeTarget)
                    return true
                end
            end
        end
        
        return false
    end
    
    -- Execute attack (optimized)
    local function ExecuteAttack()
        if not persistentData.LinkedSword or persistentData.AttackSequenceActive then
            return
        end
        
        persistentData.AttackSequenceActive = true
        persistentData.LastAttackTime = tick()
        
        if not persistentData.CurrentCombatBehavior or 
           tick() - persistentData.LastBehaviorChangeTime > CONFIG.COMBAT_BEHAVIOR_CHANGE_TIME then
            
            local rand = math.random()
            if rand < CONFIG.COMBAT_DEFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "defensive"
            elseif rand < CONFIG.COMBAT_DEFENSIVE_CHANCE + CONFIG.COMBAT_OFFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "offensive"
            else
                persistentData.CurrentCombatBehavior = "offensive-defensive"
            end
            
            persistentData.LastBehaviorChangeTime = tick()
        end
        
        if persistentData.CurrentTarget and 
           persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
            HumanoidRootPart.CFrame = CFrame.new(
                HumanoidRootPart.Position,
                Vector3.new(targetPos.X, HumanoidRootPart.Position.Y, targetPos.Z)
            )
        end
        
        spawn(function()
            if persistentData.CurrentCombatBehavior == "defensive" then
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.2)
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.5)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (HumanoidRootPart.Position - targetPos).Unit
                    local backPos = HumanoidRootPart.Position + moveDir * 2
                    ImmediateMoveTo(backPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            elseif persistentData.CurrentCombatBehavior == "offensive" then
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.6)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local forwardPos = HumanoidRootPart.Position + moveDir * 3
                    ImmediateMoveTo(forwardPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.7)
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            else
                pcall(function() persistentData.LinkedSword:Activate() end)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local strafeDir = moveDir:Cross(Vector3.new(0, 1, 0)).Unit
                    
                    if math.random() > 0.5 then
                        strafeDir = -strafeDir
                    end
                    
                    local strafePos = HumanoidRootPart.Position + strafeDir * CONFIG.STRAFE_DISTANCE
                    ImmediateMoveTo(strafePos)
                end
                
                wait(CONFIG.LUNGE_DELAY)
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local approachPos = HumanoidRootPart.Position + moveDir * 2
                    ImmediateMoveTo(approachPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
            end
            
            wait(0.2)
            persistentData.AttackSequenceActive = false
        end)
    end
    
    -- Optimized memory cleanup
    local function PerformMemoryCleanup()
        local currentTime = tick()
        
        -- Clean up path cache
        local cacheCount = 0
        local oldestTime = math.huge
        local oldestKey = nil
        
        for k, v in pairs(persistentData.PathCache) do
            cacheCount = cacheCount + 1
            if v.time < oldestTime then
                oldestTime = v.time
                oldestKey = k
            end
        end
        
        if cacheCount > CONFIG.PATH_CACHE_MAX_SIZE then
            persistentData.PathCache[oldestKey] = nil
        end
        
        -- Clean up failed paths
        for i = #persistentData.FailedPaths, 1, -1 do
            if currentTime - persistentData.FailedPaths[i].time > 15 then -- Reduced from 20
                table.remove(persistentData.FailedPaths, i)
            end
        end
        
        -- Clean up void areas
        if #persistentData.KnownVoidAreas > CONFIG.VOID_AREAS_MAX_SIZE then
            local removeCount = #persistentData.KnownVoidAreas - CONFIG.VOID_AREAS_MAX_SIZE
            for i = 1, removeCount do
                table.remove(persistentData.KnownVoidAreas, 1)
            end
        end
        
        -- Clean up safe terrain cache (keep it fresh)
        if #persistentData.SafeTerrainCache > 20 then
            persistentData.SafeTerrainCache = {}
        end
        
        persistentData.PerformanceStats.LastOptimizationTime = currentTime
    end
    
    -- Main update function with enhanced performance
    local function Update()
        persistentData.FrameCounter = persistentData.FrameCounter + 1
        
        -- Process heavy operations in smaller batches
        local shouldProcessHeavy = (persistentData.FrameCounter % CONFIG.UPDATE_THROTTLE == 0)
        local shouldProcessPathfinding = (persistentData.FrameCounter % CONFIG.PATHFINDING_BATCH_SIZE == 0)
        
        if shouldProcessHeavy then
            PerformMemoryCleanup()
            CheckForSword()
        end
        
        local currentTime = tick()
        local needNewTarget = not persistentData.CurrentTarget or 
                             not persistentData.CurrentTarget.Character or 
                             not persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        
        local checkForCloserTarget = currentTime - persistentData.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME
        
        if (needNewTarget or checkForCloserTarget) and shouldProcessHeavy then
            local playersInRange = FindPlayersInRange()
            
            if #playersInRange > 0 then
                local newTarget = playersInRange[1].player
                
                if newTarget ~= persistentData.CurrentTarget then
                    persistentData.CurrentTarget = newTarget
                    if persistentData.StatusGUI and (persistentData.FrameCounter % CONFIG.GUI_UPDATE_INTERVAL == 0) then
                        persistentData.StatusGUI.UpdateTarget(newTarget.Name)
                    end
                end
            else
                persistentData.CurrentTarget = nil
                if persistentData.StatusGUI and (persistentData.FrameCounter % CONFIG.GUI_UPDATE_INTERVAL == 0) then
                    persistentData.StatusGUI.UpdateTarget("None")
                end
            end
            
            persistentData.LastRetargetTime = currentTime
        end
        
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetHRP = persistentData.CurrentTarget.Character.HumanoidRootPart
            local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
            
            if persistentData.StatusGUI and (persistentData.FrameCounter % CONFIG.GUI_UPDATE_INTERVAL == 0) then
                persistentData.StatusGUI.UpdateDistance(distance)
            end
            
            if CheckIfStuck() then
                if shouldProcessHeavy then
                    HandleStuckOnPlayer()
                end
                return
            else
                persistentData.IsStuck = false
            end
            
            -- Always face the target for responsive combat
            HumanoidRootPart.CFrame = CFrame.lookAt(
                HumanoidRootPart.Position, 
                Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
            )
            
            if shouldProcessPathfinding then
                local isSafe, bridgePath, alternativePath = IsSafePath(targetHRP.Position)
                
                if isSafe then
                    ImmediateMoveTo(targetHRP.Position, bridgePath)
                    
                    if distance <= CONFIG.ATTACK_RANGE and 
                       persistentData.LinkedSword and 
                       currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        ExecuteAttack()
                    elseif distance <= CONFIG.MIN_ATTACK_DISTANCE and 
                           persistentData.LinkedSword and 
                           currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        persistentData.CurrentCombatBehavior = "offensive"
                        ExecuteAttack()
                    end
                elseif alternativePath then
                    ImmediateMoveTo(alternativePath)
                    
                    if distance <= CONFIG.ATTACK_RANGE and 
                       persistentData.LinkedSword and 
                       currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        ExecuteAttack()
                    end
                else
                    -- Use immediate safe directions for instant rerouting
                    local safeDirs = GetImmediateSafeDirections(targetHRP.Position)
                    if #safeDirs > 0 then
                        ImmediateMoveTo(safeDirs[1].position)
                    end
                end
            else
                -- Light frame: just maintain movement and face target
                if persistentData.LastMovementDirection then
                    Humanoid:Move(persistentData.LastMovementDirection)
                end
                
                -- Quick attack check even in light frames
                if distance <= CONFIG.ATTACK_RANGE and 
                   persistentData.LinkedSword and 
                   currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    ExecuteAttack()
                end
            end
        else
            if persistentData.StatusGUI and shouldProcessHeavy then
                persistentData.StatusGUI.UpdateStatus("Idle")
            end
        end
    end
    
    -- Handle sword equipping on respawn
    spawn(function()
        wait(CONFIG.RESPAWN_EQUIP_DELAY)
        
        persistentData.LinkedSword = FindLinkedSword()
        if persistentData.LinkedSword then
            if persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword.Parent = Character
                wait(0.5)
                
                if persistentData.LinkedSword.Parent == Character then
                    persistentData.EquipmentReady = true
                else
                    wait(0.5)
                    if persistentData.LinkedSword then
                        persistentData.LinkedSword.Parent = Character
                        wait(0.5)
                        persistentData.EquipmentReady = true
                    end
                end
            else
                persistentData.EquipmentReady = true
            end
        end
    end)
    
    -- Initialize
    persistentData.LinkedSword = FindLinkedSword()
    persistentData.LastSwordCheckTime = tick()
    persistentData.FrameCounter = 0
    
    -- Connect optimized update function
    local updateConnection
    updateConnection = RunService.Heartbeat:Connect(function()
        local success, error = pcall(Update)
        if not success then
            forcePrint("LinkedSwordAI: Error in update - " .. tostring(error))
        end
    end)
    
    -- Handle character respawn
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        forcePrint("LinkedSwordAI: Character respawned, reinitializing...")
        wait(1)
        InitializeAI()
    end)
    
    if persistentData.StatusGUI then 
        persistentData.StatusGUI.UpdateStatus("AI Running (Advanced Opt)")
    end
    forcePrint("LinkedSwordAI: Advanced optimized script initialized successfully")
    
    return true
end

-- Start the AI
local success, errorMsg = pcall(InitializeAI)

if not success then
    forcePrint("LinkedSwordAI: Critical error - " .. tostring(errorMsg))
end
