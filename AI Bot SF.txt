--[[
    Linked Sword AI Combat Script (Fixed Version)
    
    This script implements autonomous sword fighting AI for the Linked Sword tool in Roblox.
    Optimized specifically for external executor usage with improved error handling and debugging.
]]

-- Force print to output console immediately
local function forcePrint(...)
    local message = table.concat({...}, " ")
    print(message)
    print("") -- Force flush
end

forcePrint("LinkedSwordAI: Script starting...")

-- Global persistent data to maintain state across respawns
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {},
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        MovementHistory = {},
        FailedPaths = {},
        LastEquipAttempt = 0,
        EquipmentReady = false,
        KnownVoidAreas = {}
    }
end

local persistentData = _G.LinkedSwordAIPersistentData

-- Configuration
local CONFIG = {
    DETECTION_RADIUS = 100,        -- Stud radius for detecting players
    ATTACK_RANGE = 15,             -- Start attacking when within this range
    ATTACK_COOLDOWN = 0.8,         -- Time between attacks in seconds
    LUNGE_DELAY = 0.1,             -- Delay between attacks for lunge combo
    STUCK_CHECK_DISTANCE = 1.5,    -- Distance to check if stuck on player
    STUCK_CHECK_TIME = 1.0,        -- Time to wait before considering stuck
    MAX_TARGET_DISTANCE = 150,     -- Maximum effective reach in studs
    MIN_HEALTH_CHECK = 0,          -- Minimum health to consider player valid
    RETARGET_CHECK_TIME = 1.0,     -- How often to check for closer targets
    VOID_CHECK_DISTANCE = 50,      -- Distance to check for void areas
    VOID_Y_THRESHOLD = -100,       -- Y position threshold for void detection
    FORCEFIELD_FLEE_DISTANCE = 0,  -- FIXED: Set to 0 to prevent fleeing from ForceField players
    SWORD_CHECK_INTERVAL = 5,      -- How often to check for sword (seconds)
    RESPAWN_EQUIP_DELAY = 1.5,     -- Delay before equipping sword after respawn
    MOVEMENT_MEMORY_TIME = 0.5,    -- Time to remember previous movement direction
    SAFE_GAP_DISTANCE = 8,         -- Maximum safe gap distance to traverse
    PATH_SMOOTHING_FACTOR = 0.6,   -- Factor for smoothing movement (0-1)
    MOVEMENT_RETRY_DELAY = 0.5,    -- Delay before retrying failed movement
    NARROW_PASSAGE_WIDTH = 3,      -- Width to consider a passage as narrow
    PATHFINDING_STEPS = 8,         -- Number of steps to check when pathfinding
    COMBAT_BEHAVIOR_CHANGE_TIME = 3.0, -- Time between combat behavior changes
    COMBAT_DEFENSIVE_CHANCE = 0.33, -- Chance to use defensive behavior
    COMBAT_OFFENSIVE_CHANCE = 0.33, -- Chance to use offensive behavior
    STRAFE_DISTANCE = 3,           -- Distance to strafe during combat
    BRIDGE_CHECK_DISTANCE = 20     -- Distance to check for bridges
}

-- Create status GUI
local function CreateStatusGUI()
    local gui = {}
    
    -- Try different parent options for compatibility
    local parentOptions = {
        game:GetService("CoreGui"),
        game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui"),
        game:GetService("Players").LocalPlayer.Character
    }
    
    local screenGui
    for _, parent in ipairs(parentOptions) do
        if parent then
            local success, result = pcall(function()
                local newGui = Instance.new("ScreenGui")
                newGui.Name = "LinkedSwordAI_Status"
                newGui.Parent = parent
                return newGui
            end)
            
            if success then
                screenGui = result
                break
            end
        end
    end
    
    if not screenGui then
        forcePrint("LinkedSwordAI: Failed to create GUI - No valid parent found")
        return nil
    end
    
    -- Create frame
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 120)
    frame.Position = UDim2.new(0.8, 0, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.5
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    frame.Parent = screenGui
    
    -- Status text
    local status = Instance.new("TextLabel")
    status.Size = UDim2.new(1, -10, 0, 20)
    status.Position = UDim2.new(0, 5, 0, 5)
    status.BackgroundTransparency = 1
    status.TextColor3 = Color3.fromRGB(255, 255, 255)
    status.Text = "Status: Initializing..."
    status.Font = Enum.Font.SourceSans
    status.TextSize = 14
    status.TextXAlignment = Enum.TextXAlignment.Left
    status.Parent = frame
    
    -- Target text
    local target = Instance.new("TextLabel")
    target.Size = UDim2.new(1, -10, 0, 20)
    target.Position = UDim2.new(0, 5, 0, 30)
    target.BackgroundTransparency = 1
    target.TextColor3 = Color3.fromRGB(255, 150, 150)
    target.Text = "Target: None"
    target.Font = Enum.Font.SourceSans
    target.TextSize = 14
    target.TextXAlignment = Enum.TextXAlignment.Left
    target.Parent = frame
    
    -- Distance text
    local distance = Instance.new("TextLabel")
    distance.Size = UDim2.new(1, -10, 0, 20)
    distance.Position = UDim2.new(0, 5, 0, 55)
    distance.BackgroundTransparency = 1
    distance.TextColor3 = Color3.fromRGB(150, 255, 150)
    distance.Text = "Distance: N/A"
    distance.Font = Enum.Font.SourceSans
    distance.TextSize = 14
    distance.TextXAlignment = Enum.TextXAlignment.Left
    distance.Parent = frame
    
    -- Debug text
    local debug = Instance.new("TextLabel")
    debug.Size = UDim2.new(1, -10, 0, 20)
    debug.Position = UDim2.new(0, 5, 0, 80)
    debug.BackgroundTransparency = 1
    debug.TextColor3 = Color3.fromRGB(255, 255, 0)
    debug.Text = "Debug: Starting..."
    debug.Font = Enum.Font.SourceSans
    debug.TextSize = 14
    debug.TextXAlignment = Enum.TextXAlignment.Left
    debug.Parent = frame
    
    -- GUI functions
    function gui.UpdateStatus(text)
        if status then
            status.Text = "Status: " .. text
        end
    end
    
    function gui.UpdateTarget(text)
        if target then
            target.Text = "Target: " .. text
        end
    end
    
    function gui.UpdateDistance(dist)
        if distance then
            distance.Text = "Distance: " .. (dist and string.format("%.1f", dist) or "N/A")
        end
    end
    
    function gui.UpdateDebug(text)
        if debug then
            debug.Text = "Debug: " .. text
        end
    end
    
    return gui
end

-- Main execution in protected call
local function InitializeAI()
    -- Services
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    
    -- Get player and character
    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        forcePrint("LinkedSwordAI: LocalPlayer not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: LocalPlayer found - " .. LocalPlayer.Name)
    
    local Character = LocalPlayer.Character
    if not Character then
        forcePrint("LinkedSwordAI: Character not found")
        return false
    end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    
    if not Humanoid or not HumanoidRootPart then
        forcePrint("LinkedSwordAI: Humanoid or HumanoidRootPart not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: Character components found")
    
    -- Create status GUI if it doesn't exist
    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
        if not persistentData.StatusGUI then
            forcePrint("LinkedSwordAI: Failed to create status GUI")
        else
            forcePrint("LinkedSwordAI: Status GUI created")
        end
    end
    
    -- Find the Linked Sword tool
    local function FindLinkedSword()
        -- First check if we have a stored sword name and try to find that specific sword
        if persistentData.SwordToolName then
            -- Check character for the specific sword
            local storedSword = Character:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found stored sword: " .. storedSword.Name) 
                end
                forcePrint("LinkedSwordAI: Found stored sword - " .. storedSword.Name)
                return storedSword
            end
            
            -- Check backpack for the specific sword
            storedSword = LocalPlayer.Backpack:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found stored sword in backpack: " .. storedSword.Name) 
                end
                forcePrint("LinkedSwordAI: Found stored sword in backpack - " .. storedSword.Name)
                return storedSword
            end
        end
        
        -- If we couldn't find the stored sword, look for any sword
        for _, tool in pairs(Character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found sword: " .. tool.Name) 
                end
                forcePrint("LinkedSwordAI: Found sword - " .. tool.Name)
                return tool
            end
        end
        
        -- Check backpack if not found in character
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Found sword in backpack: " .. tool.Name) 
                end
                forcePrint("LinkedSwordAI: Found sword in backpack - " .. tool.Name)
                return tool
            end
        end
        
        if persistentData.StatusGUI then 
            persistentData.StatusGUI.UpdateStatus("No sword found") 
        end
        forcePrint("LinkedSwordAI: No sword found")
        return nil
    end
    
    -- Check for sword periodically
    local function CheckForSword()
        local currentTime = tick()
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword = FindLinkedSword()
            end
            persistentData.LastSwordCheckTime = currentTime
        end
    end
    
    -- Find players in range
    local function FindPlayersInRange()
        local playersInRange = {}
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and 
               player.Character:FindFirstChild("HumanoidRootPart") and
               player.Character:FindFirstChild("Humanoid") and
               player.Character.Humanoid.Health > CONFIG.MIN_HEALTH_CHECK then
                
                local playerHRP = player.Character.HumanoidRootPart
                local distance = (playerHRP.Position - HumanoidRootPart.Position).Magnitude
                
                if distance <= CONFIG.DETECTION_RADIUS then
                    -- Check if player has ForceField
                    local hasForceField = false
                    for _, child in pairs(player.Character:GetChildren()) do
                        if child:IsA("ForceField") then
                            hasForceField = true
                            persistentData.PlayersWithForceField[player.Name] = player
                            break
                        end
                    end
                    
                    if not hasForceField and persistentData.PlayersWithForceField[player.Name] then
                        persistentData.PlayersWithForceField[player.Name] = nil
                    end
                    
                    table.insert(playersInRange, {
                        player = player,
                        distance = distance,
                        hasForceField = hasForceField
                    })
                end
            end
        end
        
        -- Sort by distance
        table.sort(playersInRange, function(a, b)
            return a.distance < b.distance
        end)
        
        return playersInRange
    end
    
    -- Check if a position is in a void area
    local function IsVoidArea(position)
        -- Check against known void areas first
        for i, voidPos in ipairs(persistentData.KnownVoidAreas) do
            if (position - voidPos).Magnitude < 5 then
                return true
            end
        end
        
        -- Basic Y-threshold check
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            -- Add to known void areas if not too many stored
            if #persistentData.KnownVoidAreas < 50 then
                table.insert(persistentData.KnownVoidAreas, position)
            else
                -- Replace oldest entry
                table.remove(persistentData.KnownVoidAreas, 1)
                table.insert(persistentData.KnownVoidAreas, position)
            end
            return true
        end
        
        -- Raycast to check for ground
        local ray = Ray.new(position, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
        local hit, _ = Workspace:FindPartOnRay(ray, Character)
        
        if not hit then
            -- Add to known void areas if not too many stored
            if #persistentData.KnownVoidAreas < 50 then
                table.insert(persistentData.KnownVoidAreas, position)
            else
                -- Replace oldest entry
                table.remove(persistentData.KnownVoidAreas, 1)
                table.insert(persistentData.KnownVoidAreas, position)
            end
            return true
        end
        
        return false
    end
    
    -- Check if a gap between two points is safe to traverse
    local function IsSafeGap(startPos, endPos)
        local distance = (endPos - startPos).Magnitude
        
        -- For small gaps, just check the end position
        if distance < 3 then
            return not IsVoidArea(endPos)
        end
        
        -- For medium gaps, check for ground on the other side
        if distance < CONFIG.SAFE_GAP_DISTANCE then
            local ray = Ray.new(endPos, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
            local hit, _ = Workspace:FindPartOnRay(ray, Character)
            return hit ~= nil
        end
        
        -- For larger gaps, check multiple points along the path
        local direction = (endPos - startPos).Unit
        local checkCount = math.ceil(distance / 2) -- Check every 2 studs
        
        for i = 1, checkCount do
            local checkPoint = startPos + direction * (i * 2)
            local ray = Ray.new(checkPoint, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
            local hit, _ = Workspace:FindPartOnRay(ray, Character)
            
            if not hit then
                return false
            end
        end
        
        return true
    end
    
    -- Check if a passage is narrow and requires special handling
    local function IsNarrowPassage(position, direction)
        local leftRay = Ray.new(position, direction:Cross(Vector3.new(0, 1, 0)).Unit * CONFIG.NARROW_PASSAGE_WIDTH)
        local rightRay = Ray.new(position, direction:Cross(Vector3.new(0, 1, 0)).Unit * -CONFIG.NARROW_PASSAGE_WIDTH)
        
        local leftHit, _ = Workspace:FindPartOnRay(leftRay, Character)
        local rightHit, _ = Workspace:FindPartOnRay(rightRay, Character)
        
        return leftHit and rightHit
    end
    
    -- Check if there's a bridge or platform that can be used to reach the target
    local function FindBridgePath(startPos, endPos)
        local direction = (endPos - startPos).Unit
        local distance = (endPos - startPos).Magnitude
        
        -- Check for bridges at different distances
        for dist = 5, math.min(CONFIG.BRIDGE_CHECK_DISTANCE, distance), 5 do
            local checkPoint = startPos + direction * dist
            
            -- Check below for bridge
            for y = 0, -20, -2 do
                local bridgeCheckPoint = checkPoint + Vector3.new(0, y, 0)
                local ray = Ray.new(bridgeCheckPoint, Vector3.new(0, -5, 0))
                local hit, hitPos = Workspace:FindPartOnRay(ray, Character)
                
                if hit then
                    -- Found potential bridge, check if it leads to target
                    local bridgePath = hitPos + Vector3.new(0, 3, 0) -- Position above the bridge
                    
                    -- Check if we can reach the bridge and if it's safe
                    if IsSafeGap(startPos, bridgePath) then
                        return bridgePath
                    end
                end}
            end
        end
        
        return nil
    end
    
    -- Check if path to target is safe (no voids)
    local function IsSafePath(targetPosition)
        -- Check if this path has failed recently
        for _, failedPath in ipairs(persistentData.FailedPaths) do
            if (targetPosition - failedPath.position).Magnitude < 5 and 
               tick() - failedPath.time < 10 then
                return false
            end
        end
        
        local startPos = HumanoidRootPart.Position
        local direction = (targetPosition - startPos).Unit
        local distance = (targetPosition - startPos).Magnitude
        
        -- Check if we're in a narrow passage
        local isNarrow = IsNarrowPassage(startPos, direction)
        
        -- If in narrow passage, use more careful pathfinding
        if isNarrow then
            -- Use smaller increments for narrow passages
            local narrowIncrement = math.min(2, distance / 8)
            
            for i = narrowIncrement, distance, narrowIncrement do
                local checkPos = startPos + direction * i
                
                -- Check for walls on both sides
                if not IsNarrowPassage(checkPos, direction) then
                    -- We've exited the narrow passage, check if it's safe
                    if IsVoidArea(checkPos) then
                        if #persistentData.FailedPaths >= 10 then
                            table.remove(persistentData.FailedPaths, 1)
                        end
                        table.insert(persistentData.FailedPaths, {
                            position = targetPosition,
                            time = tick()
                        })
                        return false
                    end
                    
                    -- We've found a safe exit from the narrow passage
                    break
                end
            end
        else
            -- Standard path checking for open areas
            -- Adjust increment based on distance
            local increment = math.min(5, distance / 5)
            
            for i = increment, distance, increment do
                local checkPos = startPos + direction * i
                if IsVoidArea(checkPos) then
                    -- Try to find a bridge path if direct path is unsafe
                    local bridgePath = FindBridgePath(startPos, targetPosition)
                    if bridgePath then
                        -- We found a bridge path, use it instead
                        return true, bridgePath
                    end
                    
                    -- Remember this failed path
                    if #persistentData.FailedPaths >= 10 then
                        table.remove(persistentData.FailedPaths, 1)
                    end
                    table.insert(persistentData.FailedPaths, {
                        position = targetPosition,
                        time = tick()
                    })
                    return false
                end
            end
        end
        
        -- Final check at target position
        if IsVoidArea(targetPosition) then
            -- Remember this failed path
            if #persistentData.FailedPaths >= 10 then
                table.remove(persistentData.FailedPaths, 1)
            end
            table.insert(persistentData.FailedPaths, {
                position = targetPosition,
                time = tick()
            })
            return false
        end
        
        return true
    end
    
    -- Check if we're stuck on a player
    local function CheckIfStuck()
        if not persistentData.LastStuckPosition then
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = tick()
            return false
        end
        
        local currentTime = tick()
        local timeDiff = currentTime - persistentData.LastStuckTime
        
        if timeDiff > CONFIG.STUCK_CHECK_TIME then
            local distance = (HumanoidRootPart.Position - persistentData.LastStuckPosition).Magnitude
            
            if distance < CONFIG.STUCK_CHECK_DISTANCE then
                -- We haven't moved much in the check time
                persistentData.IsStuck = true
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Stuck detected") end
                return true
            end
            
            -- Update position and time for next check
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = currentTime
        end
        
        return false
    end
    
    -- Handle being stuck on a player
    local function HandleStuckOnPlayer()
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Unstucking from player") end
        
        -- Find a safe direction to move
        local directions = {
            Vector3.new(1, 0, 0),
            Vector3.new(-1, 0, 0),
            Vector3.new(0, 0, 1),
            Vector3.new(0, 0, -1),
            Vector3.new(1, 0, 1).Unit,
            Vector3.new(-1, 0, 1).Unit,
            Vector3.new(1, 0, -1).Unit,
            Vector3.new(-1, 0, -1).Unit
        }
        
        for _, direction in ipairs(directions) do
            local targetPosition = HumanoidRootPart.Position + direction * 5
            
            if IsSafePath(targetPosition) then
                Humanoid:MoveTo(targetPosition)
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Moving to unstuck") end
                return true
            end
        end
        
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("No safe path to unstuck") end
        return false
    end
    
    -- Handle fleeing from players with ForceField
    local function HandleFleeFromForceField()
        -- FIXED: Don't flee from ForceField players
        if CONFIG.FORCEFIELD_FLEE_DISTANCE <= 0 then
            return false
        end
        
        local nearestFFPlayer = nil
        local nearestDistance = math.huge
        
        for _, ffPlayer in pairs(persistentData.PlayersWithForceField) do
            if ffPlayer and ffPlayer.Character and ffPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (ffPlayer.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                
                if distance < nearestDistance then
                    nearestFFPlayer = ffPlayer
                    nearestDistance = distance
                end
            end
        end
        
        if nearestFFPlayer and nearestDistance < CONFIG.FORCEFIELD_FLEE_DISTANCE then
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateStatus("Fleeing from " .. nearestFFPlayer.Name .. " (ForceField)")
                persistentData.StatusGUI.UpdateDebug("ForceField detected at " .. string.format("%.1f", nearestDistance) .. " studs")
            end
            
            -- Calculate flee direction (away from ForceField player)
            local fleeDirection = (HumanoidRootPart.Position - nearestFFPlayer.Character.HumanoidRootPart.Position).Unit
            local fleeTarget = HumanoidRootPart.Position + fleeDirection * CONFIG.FORCEFIELD_FLEE_DISTANCE
            
            -- Check if flee path is safe
            if IsSafePath(fleeTarget) then
                Humanoid:MoveTo(fleeTarget)
                return true
            else
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Warning: No safe path to flee") end
                
                -- Try alternative directions
                local alternativeDirections = {
                    (fleeDirection + Vector3.new(0.3, 0, 0.3)).Unit,
                    (fleeDirection + Vector3.new(-0.3, 0, 0.3)).Unit,
                    (fleeDirection + Vector3.new(0.3, 0, -0.3)).Unit,
                    (fleeDirection + Vector3.new(-0.3, 0, -0.3)).Unit
                }
                
                for _, altDir in ipairs(alternativeDirections) do
                    local altTarget = HumanoidRootPart.Position + altDir * CONFIG.FORCEFIELD_FLEE_DISTANCE
                    if IsSafePath(altTarget) then
                        Humanoid:MoveTo(altTarget)
                        return true
                    end
                end
                
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Warning: All flee paths unsafe") end
            end
        end
        
        return false
    end
    
    -- Smooth movement function with improved bridge and narrow passage handling
    local function MoveTo(targetPosition, bridgePath)
        -- If we have a bridge path, use that instead
        if bridgePath then
            targetPosition = bridgePath
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Using bridge path")
            end
        end
        
        -- Calculate direction to target
        local currentDirection = (targetPosition - HumanoidRootPart.Position).Unit
        local currentTime = tick()
        
        -- Apply path smoothing if we have previous movement data
        local smoothedDirection = currentDirection
        if persistentData.LastMovementDirection and 
           currentTime - persistentData.LastMovementTime < CONFIG.MOVEMENT_MEMORY_TIME then
            -- Blend previous and current directions
            smoothedDirection = (persistentData.LastMovementDirection * CONFIG.PATH_SMOOTHING_FACTOR + 
                               currentDirection * (1 - CONFIG.PATH_SMOOTHING_FACTOR)).Unit
        end
        
        -- Calculate smoothed target position
        local smoothedTarget = HumanoidRootPart.Position + smoothedDirection * 
                              math.min(5, (targetPosition - HumanoidRootPart.Position).Magnitude)
        
        -- Check if we're in a narrow passage
        local isNarrow = IsNarrowPassage(HumanoidRootPart.Position, smoothedDirection)
        
        -- If in narrow passage, use more careful movement
        if isNarrow then
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Navigating narrow passage")
            end
            
            -- Use the exact direction in narrow passages (no smoothing)
            smoothedDirection = currentDirection
            smoothedTarget = HumanoidRootPart.Position + smoothedDirection * 
                           math.min(2, (targetPosition - HumanoidRootPart.Position).Magnitude)
        end
        
        -- Check if the smoothed path is safe
        if IsSafeGap(HumanoidRootPart.Position, smoothedTarget) then
            -- Update movement history
            persistentData.LastMovementDirection = smoothedDirection
            persistentData.LastMovementTime = currentTime
            
            -- Execute movement
            Humanoid:MoveTo(smoothedTarget)
            
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Moving: " .. 
                    string.format("(%.1f, %.1f, %.1f)", 
                    smoothedDirection.X, smoothedDirection.Y, smoothedDirection.Z))
            end
            return true
        else
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateDebug("Unsafe path detected")
            end
            return false
        end
    end
    
    -- Execute attack with improved combat behaviors
    local function ExecuteAttack()
        if not persistentData.LinkedSword then
            forcePrint("LinkedSwordAI: Cannot attack - No sword equipped")
            return
        end
        
        if persistentData.AttackSequenceActive then
            return
        end
        
        persistentData.AttackSequenceActive = true
        persistentData.LastAttackTime = tick()
        
        -- Select combat behavior if needed
        if not persistentData.CurrentCombatBehavior or 
           tick() - persistentData.LastBehaviorChangeTime > CONFIG.COMBAT_BEHAVIOR_CHANGE_TIME then
            
            -- Randomly select a combat behavior
            local rand = math.random()
            if rand < CONFIG.COMBAT_DEFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "defensive"
            elseif rand < CONFIG.COMBAT_DEFENSIVE_CHANCE + CONFIG.COMBAT_OFFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "offensive"
            else
                persistentData.CurrentCombatBehavior = "offensive-defensive"
            end
            
            persistentData.LastBehaviorChangeTime = tick()
            
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateStatus("Combat: " .. persistentData.CurrentCombatBehavior)
            end
        end
        
        -- Face target more accurately before attacking
        if persistentData.CurrentTarget and 
           persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
            local lookVector = (targetPos - HumanoidRootPart.Position).Unit
            
            -- Set character to face target
            HumanoidRootPart.CFrame = CFrame.new(
                HumanoidRootPart.Position,
                Vector3.new(targetPos.X, HumanoidRootPart.Position.Y, targetPos.Z)
            )
        end
        
        if persistentData.StatusGUI then
            persistentData.StatusGUI.UpdateDebug("Executing " .. persistentData.CurrentCombatBehavior .. " attack")
        end
        
        -- Execute attack based on selected behavior
        spawn(function()
            if persistentData.CurrentCombatBehavior == "defensive" then
                -- Defensive behavior - wait for player to approach, attack from distance
                forcePrint("LinkedSwordAI: Defensive attack")
                
                -- First activation
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.2)
                
                -- Second activation
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.5)
                
                -- Third activation with slight backstep
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (HumanoidRootPart.Position - targetPos).Unit
                    local backPos = HumanoidRootPart.Position + moveDir * 2
                    
                    -- Move slightly back while attacking
                    MoveTo(backPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            elseif persistentData.CurrentCombatBehavior == "offensive" then
                -- Offensive behavior - aggressive approach and quick attacks
                forcePrint("LinkedSwordAI: Offensive attack")
                
                -- Quick first activation
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.6)
                
                -- Move toward target while attacking
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local forwardPos = HumanoidRootPart.Position + moveDir * 3
                    
                    -- Move toward target
                    MoveTo(forwardPos)
                end
                
                -- Quick second activation
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.7)
                
                -- Third activation with follow-through
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            else -- offensive-defensive
                -- Offensive-defensive behavior - strafe and attack
                forcePrint("LinkedSwordAI: Offensive-defensive attack")
                
                -- First activation
                pcall(function() persistentData.LinkedSword:Activate() end)
                
                -- Strafe to the side
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local strafeDir = moveDir:Cross(Vector3.new(0, 1, 0)).Unit
                    
                    -- Randomly choose left or right strafe
                    if math.random() > 0.5 then
                        strafeDir = -strafeDir
                    end
                    
                    local strafePos = HumanoidRootPart.Position + strafeDir * CONFIG.STRAFE_DISTANCE
                    
                    -- Strafe while attacking
                    MoveTo(strafePos)
                end
                
                wait(CONFIG.LUNGE_DELAY)
                
                -- Second activation
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY)
                
                -- Third activation with approach
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local approachPos = HumanoidRootPart.Position + moveDir * 2
                    
                    -- Approach target for final attack
                    MoveTo(approachPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
            end
            
            -- Shorter cooldown before allowing next attack sequence
            wait(0.2)
            persistentData.AttackSequenceActive = false
        end)
    end
    
    -- Main update function
    local function Update()
        -- Check for sword periodically
        CheckForSword()
        
        -- Check if we need to find a new target or check for closer targets
        local currentTime = tick()
        local needNewTarget = not persistentData.CurrentTarget or 
                             not persistentData.CurrentTarget.Character or 
                             not persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        
        local checkForCloserTarget = currentTime - persistentData.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME
        
        if needNewTarget or checkForCloserTarget then
            local playersInRange = FindPlayersInRange()
            
            -- FIXED: Don't flee from ForceField players, but still track them
            -- We'll keep the tracking code but disable the fleeing behavior
            
            if #playersInRange > 0 then
                -- Target any player regardless of ForceField status
                local validTargets = playersInRange
                
                if #validTargets > 0 then
                    -- Select the closest target
                    local newTarget = validTargets[1].player
                    
                    -- Update target if it's different
                    if newTarget ~= persistentData.CurrentTarget then
                        persistentData.CurrentTarget = newTarget
                        if persistentData.StatusGUI then 
                            persistentData.StatusGUI.UpdateTarget(newTarget.Name)
                            persistentData.StatusGUI.UpdateStatus("Targeting " .. newTarget.Name)
                        end
                        forcePrint("LinkedSwordAI: New target - " .. newTarget.Name)
                    end
                else
                    if persistentData.StatusGUI then 
                        persistentData.StatusGUI.UpdateTarget("None")
                        persistentData.StatusGUI.UpdateStatus("No valid targets")
                    end
                    persistentData.CurrentTarget = nil
                end
            else
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("No targets in range")
                    persistentData.StatusGUI.UpdateTarget("None")
                end
                persistentData.CurrentTarget = nil
            end
            
            persistentData.LastRetargetTime = currentTime
        end
        
        -- If we have a target, execute AI behavior
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetHRP = persistentData.CurrentTarget.Character.HumanoidRootPart
            local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
            
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateDistance(distance)
            end
            
            -- Check if we're stuck on a player
            if CheckIfStuck() then
                HandleStuckOnPlayer()
                return
            else
                persistentData.IsStuck = false
            end
            
            -- Check if the path to the target is safe
            local isSafe, bridgePath = IsSafePath(targetHRP.Position)
            if isSafe then
                -- Move toward target using smooth movement with bridge path if available
                MoveTo(targetHRP.Position, bridgePath)
                
                -- Face the target
                HumanoidRootPart.CFrame = CFrame.lookAt(
                    HumanoidRootPart.Position, 
                    Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
                )
                
                -- Attack if in range and cooldown is ready
                if distance <= CONFIG.ATTACK_RANGE and 
                   persistentData.LinkedSword and 
                   currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    ExecuteAttack()
                end
            else
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateStatus("Finding safe path")
                    persistentData.StatusGUI.UpdateDebug("Checking bridge paths")
                end
                
                -- First try to find a bridge path
                local bridgePath = FindBridgePath(HumanoidRootPart.Position, targetHRP.Position)
                if bridgePath then
                    if persistentData.StatusGUI then 
                        persistentData.StatusGUI.UpdateDebug("Using bridge path")
                    end
                    MoveTo(bridgePath)
                    return
                end
                
                -- Try to find an alternative path
                local alternativeDirections = {
                    Vector3.new(1, 0, 0),
                    Vector3.new(-1, 0, 0),
                    Vector3.new(0, 0, 1),
                    Vector3.new(0, 0, -1),
                    Vector3.new(1, 0, 1).Unit,
                    Vector3.new(-1, 0, 1).Unit,
                    Vector3.new(1, 0, -1).Unit,
                    Vector3.new(-1, 0, -1).Unit
                }
                
                local foundSafePath = false
                for _, dir in ipairs(alternativeDirections) do
                    local alternativeTarget = HumanoidRootPart.Position + dir * 10
                    local altSafe, altBridgePath = IsSafePath(alternativeTarget)
                    
                    if altSafe then
                        if persistentData.StatusGUI then 
                            persistentData.StatusGUI.UpdateDebug("Found alternative path")
                        end
                        MoveTo(alternativeTarget, altBridgePath)
                        foundSafePath = true
                        break
                    end
                end
                
                if not foundSafePath and persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateDebug("No safe path found")
                end
            end
        else
            -- No target, just idle
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateStatus("Idle")
            end
        end
    end
                    if IsSafePath(alternativeTarget) then
                        MoveTo(alternativeTarget)
                        break
                    end
                end
            end
        else
            if persistentData.StatusGUI then 
                persistentData.StatusGUI.UpdateDistance(nil)
            end
        end
    end
    
    -- Handle proper sword equipping on respawn
    spawn(function()
        -- Wait for character to fully load
        wait(CONFIG.RESPAWN_EQUIP_DELAY)
        
        persistentData.LinkedSword = FindLinkedSword()
        if persistentData.LinkedSword then
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateStatus("Sword found: " .. persistentData.LinkedSword.Name)
            end
            
            -- Equip the sword
            if persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword.Parent = Character
                wait(0.5)
                
                -- Verify equipment was successful
                if persistentData.LinkedSword.Parent == Character then
                    persistentData.EquipmentReady = true
                    if persistentData.StatusGUI then
                        persistentData.StatusGUI.UpdateStatus("Sword equipped successfully")
                    end
                else
                    -- Retry equipping
                    wait(0.5)
                    if persistentData.LinkedSword then
                        persistentData.LinkedSword.Parent = Character
                        wait(0.5)
                        persistentData.EquipmentReady = true
                        if persistentData.StatusGUI then
                            persistentData.StatusGUI.UpdateStatus("Sword equipped on retry")
                        end
                    end
                end
            else
                persistentData.EquipmentReady = true
                if persistentData.StatusGUI then
                    persistentData.StatusGUI.UpdateStatus("Sword already equipped")
                end
            end
        else
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdateStatus("No sword found to equip")
            end
        end
    end)
    
    -- Initialize
    persistentData.LinkedSword = FindLinkedSword()
    persistentData.LastSwordCheckTime = tick()
    
    -- Connect update function
    local updateConnection
    updateConnection = RunService.Heartbeat:Connect(function()
        local success, error = pcall(Update)
        if not success then
            forcePrint("LinkedSwordAI: Error in update - " .. tostring(error))
            if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Error: " .. tostring(error)) end
        end
    end)
    
    -- Handle character respawn
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        forcePrint("LinkedSwordAI: Character respawned, reinitializing...")
        wait(1) -- Wait for character to fully load
        InitializeAI()
    end)
    
    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("AI Running") end
    forcePrint("LinkedSwordAI: Script initialized successfully")
    
    return true
end

-- Start the AI
local success, errorMsg = pcall(InitializeAI)

if not success then
    forcePrint("LinkedSwordAI: Critical error - " .. tostring(errorMsg))
end
