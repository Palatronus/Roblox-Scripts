-- LinkedSwordAI_DeadTargetFix.lua
-- Fixed dead target detection and improved target validation

local LinkedSwordAI = {}
LinkedSwordAI.Version = "4.1"
LinkedSwordAI.IsRunning = false

-- Optimized Configuration
local Config = {
    -- Targeting (Increased ranges)
    DetectionRadius = 200,
    MaxTargetDistance = 250,
    TargetRefreshRate = 0.4, -- Slightly faster for better dead target detection
    
    -- Combat (More aggressive)
    AttackRange = 18,
    LungeRange = 14,
    AttackCooldown = 0.7,
    ComboAttacks = 4,
    ComboDelay = 0.08,
    
    -- Movement & Pathfinding
    WaypointDistance = 12,
    NavigationUpdate = 0.3,
    StrafeDistance = 5,
    MoveSpeedMultiplier = 1.3,
    
    -- Safety
    VoidThreshold = -25,
    
    -- Performance Optimizations
    UpdateThrottle = 0.15,
    CleanupInterval = 30,
    MaxTargetsToTrack = 3,
    RaycastBudget = 5,
    PathfindingSteps = 6,
    
    -- Target Validation
    TargetHealthThreshold = 1, -- Ignore players with health below this
    MaxDeadTargetTime = 2.0, -- How long to remember a dead target before dropping
    TargetValidationInterval = 0.2 -- How often to validate current target
}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- Performance counters
local Performance = {
    RaycastsThisFrame = 0,
    LastRaycastReset = tick(),
    UpdateCount = 0,
    AverageUpdateTime = 0
}

-- Optimized debug output
local function DebugPrint(message)
    if _G.LinkedSwordAIDebug then
        print("[LinkedSwordAI]: " .. tostring(message))
    end
end

-- Performance-optimized wait
local function SafeWait(seconds)
    local start = tick()
    while tick() - start < seconds do
        RunService.Heartbeat:Wait()
    end
end

-- Initialize persistent AI state with improved target tracking
local function InitializeAIState()
    if not _G.LinkedSwordAIData then
        _G.LinkedSwordAIData = {
            IsActive = false,
            StatusGUI = nil,
            CurrentTarget = nil,
            LastAttackTime = 0,
            LastTargetUpdate = 0,
            LastNavigationUpdate = 0,
            LastCleanup = tick(),
            LastHealthUpdate = 0,
            LastTargetValidation = 0,
            Connections = {},
            StrafingDirection = 1,
            CombatMode = "Aggressive",
            KnownTargets = {},
            DeadTargets = {}, -- Track recently dead targets
            PerformanceStats = {
                FrameTime = 0,
                UpdatesPerSecond = 0,
                TargetSwitches = 0,
                DeadTargetsSkipped = 0
            },
            PathMemory = {},
            FailedPaths = {},
            LastPathRecalculation = 0
        }
    end
    return _G.LinkedSwordAIData
end

-- Lightweight Status GUI
local function CreateStatusGUI()
    local success, screenGui = pcall(function()
        local gui = Instance.new("ScreenGui")
        gui.Name = "LinkedSwordAI_Optimized"
        gui.Parent = game:GetService("CoreGui")
        return gui
    end)
    
    if not success then return nil end
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 240, 0, 120)
    frame.Position = UDim2.new(0, 10, 0, 10)
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    frame.BackgroundTransparency = 0.1
    frame.BorderSizePixel = 0
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame
    
    local labels = {}
    local labelInfo = {
        {"Status", "Initializing"},
        {"Target", "None"},
        {"Distance", "0.0"},
        {"Mode", "Idle"},
        {"Health", "100%"},
        {"Performance", "0ms"}
    }
    
    for i, info in ipairs(labelInfo) do
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, -10, 0, 20)
        label.Position = UDim2.new(0, 5, 0, (i-1)*20)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(220, 220, 220)
        label.Text = info[1] .. ": " .. info[2]
        label.Font = Enum.Font.SourceSansSemibold
        label.TextSize = 11
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = frame
        labels[info[1]] = label
    end
    
    frame.Parent = screenGui
    
    return {
        Update = function(field, value)
            if labels[field] then
                labels[field].Text = field .. ": " .. (value or "N/A")
            end
        end,
        Destroy = function()
            pcall(function() screenGui:Destroy() end)
        end
    }
end

-- Improved target validation function
local function IsTargetValid(target, data)
    if not target then return false end
    if not target.Player then return false end
    if not target.Player.Character then return false end
    
    -- Check if target is in dead targets list
    if data.DeadTargets[target.Player] then
        local timeSinceDeath = tick() - data.DeadTargets[target.Player]
        if timeSinceDeath < Config.MaxDeadTargetTime then
            return false -- Target is recently dead
        else
            data.DeadTargets[target.Player] = nil -- Clean up old entry
        end
    end
    
    local humanoid = target.Player.Character:FindFirstChildOfClass("Humanoid")
    local rootPart = target.Player.Character:FindFirstChild("HumanoidRootPart")
    
    if not humanoid or not rootPart then
        return false
    end
    
    -- Critical fix: Check if health is below threshold (dead or dying)
    if humanoid.Health < Config.TargetHealthThreshold then
        -- Add to dead targets list
        data.DeadTargets[target.Player] = tick()
        data.PerformanceStats.DeadTargetsSkipped = (data.PerformanceStats.DeadTargetsSkipped or 0) + 1
        return false
    end
    
    return true
end

-- Optimized sword equipping
local function EquipSword(character, humanoid)
    if not character or not humanoid then return nil end
    
    for _, item in ipairs(character:GetChildren()) do
        if item:IsA("Tool") and (item.Name:lower():find("sword") or item.Name:lower():find("blade")) then
            return item
        end
    end
    
    local player = Players.LocalPlayer
    local backpack = player:FindFirstChild("Backpack")
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") and (item.Name:lower():find("sword") or item.Name:lower():find("blade")) then
                pcall(function()
                    humanoid:EquipTool(item)
                    SafeWait(0.2)
                end)
                return character:FindFirstChild(item.Name) or item
            end
        end
    end
    
    for _, item in ipairs(character:GetChildren()) do
        if item:IsA("Tool") then
            return item
        end
    end
    
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                pcall(function()
                    humanoid:EquipTool(item)
                    SafeWait(0.2)
                end)
                return character:FindFirstChild(item.Name) or item
            end
        end
    end
    
    return nil
end

-- Performance-optimized target finding with dead target filtering
local function FindBestTarget(localPlayer, localPosition, currentTarget, data)
    local allTargets = {}
    local currentDistance = currentTarget and currentTarget.Distance or math.huge
    
    -- Limit the number of players we check for performance
    local players = Players:GetPlayers()
    local maxChecks = math.min(#players, 8)
    
    for i = 1, maxChecks do
        local player = players[i]
        if player and player ~= localPlayer and player.Character then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
            
            -- Critical fix: Check if target is valid and alive
            if humanoid and humanoid.Health >= Config.TargetHealthThreshold and rootPart then
                local distance = (rootPart.Position - localPosition).Magnitude
                
                if distance <= Config.MaxTargetDistance then
                    table.insert(allTargets, {
                        Player = player,
                        Humanoid = humanoid,
                        RootPart = rootPart,
                        Distance = distance,
                        Position = rootPart.Position,
                        LastSeen = tick(),
                        Health = humanoid.Health
                    })
                end
            else
                -- Track dead players
                if humanoid and humanoid.Health < Config.TargetHealthThreshold then
                    data.DeadTargets[player] = tick()
                end
            end
        end
    end
    
    if #allTargets == 0 then
        return nil
    end
    
    -- Sort by distance (closest first)
    table.sort(allTargets, function(a, b)
        return a.Distance < b.Distance
    end)
    
    -- Store known targets (limited for performance)
    data.KnownTargets = {}
    for i = 1, math.min(#allTargets, Config.MaxTargetsToTrack) do
        data.KnownTargets[allTargets[i].Player] = allTargets[i]
    end
    
    -- Always switch to closest valid target for aggression
    local closestTarget = allTargets[1]
    
    if not currentTarget or closestTarget.Distance < currentDistance - 5 or closestTarget.Player ~= currentTarget.Player then
        data.PerformanceStats.TargetSwitches = (data.PerformanceStats.TargetSwitches or 0) + 1
        DebugPrint("Switching to closer target: " .. closestTarget.Player.Name)
        return closestTarget
    end
    
    return currentTarget
end

-- Optimized raycast with budget management
local function SafeRaycast(origin, direction, params)
    if Performance.RaycastsThisFrame >= Config.RaycastBudget then
        return nil
    end
    
    Performance.RaycastsThisFrame = Performance.RaycastsThisFrame + 1
    return Workspace:Raycast(origin, direction, params)
end

-- Performance-optimized position safety check
local function IsPositionSafe(position, character)
    if position.Y < Config.VoidThreshold then
        return false, "void"
    end
    
    if tick() - Performance.LastRaycastReset > 0.1 then
        Performance.RaycastsThisFrame = 0
        Performance.LastRaycastReset = tick()
    end
    
    local rayOrigin = position + Vector3.new(0, 2, 0)
    local rayDirection = Vector3.new(0, -20, 0)
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local result = SafeRaycast(rayOrigin, rayDirection, raycastParams)
    
    return result ~= nil, result and "safe" or "no ground"
end

-- Enhanced pathfinding with memory
local function CalculateSmartPath(currentPos, targetPos, character, data)
    local direction = (targetPos - currentPos).Unit
    local distance = (targetPos - currentPos).Magnitude
    
    -- Check path memory first
    local memoryKey = math.floor(currentPos.X/10) .. "_" .. math.floor(currentPos.Z/10) .. 
                     "_" .. math.floor(targetPos.X/10) .. "_" .. math.floor(targetPos.Z/10)
    
    if data.PathMemory[memoryKey] and tick() - data.PathMemory[memoryKey].time < 30 then
        local memory = data.PathMemory[memoryKey]
        if IsPositionSafe(memory.position, character) then
            return memory.position, "cached"
        end
    end
    
    -- Check failed paths
    if data.FailedPaths[memoryKey] and tick() - data.FailedPaths[memoryKey] < 15 then
        return CalculateAlternativePath(currentPos, targetPos, character, data, "avoid_failed")
    end
    
    -- Try direct path first
    local moveDistance = math.min(Config.WaypointDistance, distance)
    local testPos = currentPos + (direction * moveDistance)
    
    local isSafe, reason = IsPositionSafe(testPos, character)
    
    if isSafe then
        data.PathMemory[memoryKey] = {
            position = testPos,
            time = tick()
        }
        return testPos, "direct"
    end
    
    return CalculateAlternativePath(currentPos, targetPos, character, data, reason)
end

-- Improved alternative path calculation
local function CalculateAlternativePath(currentPos, targetPos, character, data, reason)
    local direction = (targetPos - currentPos).Unit
    local distance = (targetPos - currentPos).Magnitude
    
    -- Strategy 1: Elevated path (for bridges)
    local elevatedPos = currentPos + Vector3.new(0, 8, 0) + (direction * math.min(10, distance))
    if IsPositionSafe(elevatedPos, character) then
        return elevatedPos, "elevated"
    end
    
    -- Strategy 2: Side paths with progressive distance
    local sideStrategies = {
        {dir = direction:Cross(Vector3.new(0, 1, 0)), dist = 4, name = "left"},
        {dir = direction:Cross(Vector3.new(0, -1, 0)), dist = 4, name = "right"},
        {dir = direction:Cross(Vector3.new(0, 1, 0)), dist = 8, name = "left_far"},
        {dir = direction:Cross(Vector3.new(0, -1, 0)), dist = 8, name = "right_far"}
    }
    
    for _, strategy in ipairs(sideStrategies) do
        local sidePos = currentPos + (strategy.dir * strategy.dist) + (direction * math.min(8, distance * 0.7))
        if IsPositionSafe(sidePos, character) then
            return sidePos, strategy.name
        end
    end
    
    -- Strategy 3: Step-based approach for complex navigation
    for step = 1, Config.PathfindingSteps do
        local stepDistance = math.min(6, distance / Config.PathfindingSteps * step)
        local stepPos = currentPos + (direction * stepDistance)
        
        local variations = {
            stepPos,
            stepPos + Vector3.new(0, 3, 0),
            stepPos + direction:Cross(Vector3.new(0, 1, 0)) * 2,
            stepPos + direction:Cross(Vector3.new(0, -1, 0)) * 2
        }
        
        for _, varPos in ipairs(variations) do
            if IsPositionSafe(varPos, character) then
                return varPos, "step_" .. step
            end
        end
    end
    
    -- Strategy 4: Fallback - small steps forward
    for i = 1, 3 do
        local smallStep = currentPos + (direction * i * 2)
        if IsPositionSafe(smallStep, character) then
            return smallStep, "small_step"
        end
    end
    
    -- Last resort: minimal movement
    local minimalPos = currentPos + (direction * 1)
    if IsPositionSafe(minimalPos, character) then
        return minimalPos, "minimal"
    end
    
    -- Mark as failed path
    local memoryKey = math.floor(currentPos.X/10) .. "_" .. math.floor(currentPos.Z/10) .. 
                     "_" .. math.floor(targetPos.X/10) .. "_" .. math.floor(targetPos.Z/10)
    data.FailedPaths[memoryKey] = tick()
    
    return currentPos, "stuck"
end

-- Aggressive combat behavior with target validation
local function ExecuteCombat(humanoid, rootPart, targetPos, distance, sword, lastAttackTime, data)
    local currentTime = tick()
    local direction = (targetPos - rootPart.Position).Unit
    
    -- Always face target aggressively
    humanoid:MoveTo(rootPart.Position + direction * 0.1)
    
    -- Aggressive combat mode selection
    local combatMode
    if distance <= Config.LungeRange then
        combatMode = "UltraAggressive"
    elseif distance <= Config.AttackRange then
        combatMode = "Aggressive"
    else
        combatMode = "Chasing"
    end
    
    data.CombatMode = combatMode
    
    -- Execute movement based on aggressive mode
    if combatMode == "Chasing" then
        local chasePos = rootPart.Position + (direction * Config.WaypointDistance)
        if IsPositionSafe(chasePos, humanoid.Parent) then
            humanoid:MoveTo(chasePos)
        end
    elseif combatMode == "Aggressive" then
        if distance > 5 then
            humanoid:MoveTo(targetPos)
        else
            data.StrafingDirection = data.StrafingDirection * -1
            local strafeDir = direction:Cross(Vector3.new(0, data.StrafingDirection, 0)).Unit
            local strafePos = rootPart.Position + (strafeDir * Config.StrafeDistance)
            
            if IsPositionSafe(strafePos, humanoid.Parent) then
                humanoid:MoveTo(strafePos)
            end
        end
    else -- UltraAggressive
        if distance > 3 then
            humanoid:MoveTo(targetPos)
        end
    end
    
    -- Aggressive attacking - attack whenever in range
    if distance <= Config.AttackRange and sword then
        if currentTime - lastAttackTime >= Config.AttackCooldown then
            for i = 1, Config.ComboAttacks do
                if sword and sword.Parent then
                    pcall(function() 
                        sword:Activate() 
                        if i % 2 == 0 and distance > 2 then
                            local lungePos = rootPart.Position + (direction * 2)
                            if IsPositionSafe(lungePos, humanoid.Parent) then
                                humanoid:MoveTo(lungePos)
                            end
                        end
                    end)
                end
                if i < Config.ComboAttacks then
                    SafeWait(Config.ComboDelay)
                end
            end
            return currentTime
        end
    end
    
    return lastAttackTime
end

-- Critical fix: Validate current target before processing
local function ValidateCurrentTarget(data)
    if not data.CurrentTarget then
        return false
    end
    
    -- Check if target validation is due
    local currentTime = tick()
    if currentTime - data.LastTargetValidation < Config.TargetValidationInterval then
        return data.CurrentTarget ~= nil -- Return cached result if validation not due
    end
    
    data.LastTargetValidation = currentTime
    
    -- Perform thorough target validation
    local isValid = IsTargetValid(data.CurrentTarget, data)
    
    if not isValid then
        DebugPrint("Target invalidated: " .. (data.CurrentTarget.Player and data.CurrentTarget.Player.Name or "Unknown"))
        data.CurrentTarget = nil
        
        if data.StatusGUI then
            data.StatusGUI.Update("Target", "None")
            data.StatusGUI.Update("Status", "Target Lost")
        end
    end
    
    return isValid
end

-- Performance monitoring
local function UpdatePerformanceStats(data, updateTime)
    data.PerformanceStats.FrameTime = updateTime * 1000
    data.PerformanceStats.UpdatesPerSecond = 1 / updateTime
    
    if data.StatusGUI and data.UpdateCount % 15 == 0 then
        local perfText = string.format("%.1fms (%.0f/s)", 
            data.PerformanceStats.FrameTime, 
            data.PerformanceStats.UpdatesPerSecond)
        data.StatusGUI.Update("Performance", perfText)
    end
end

-- Health monitoring
local function UpdateHealthDisplay(data)
    if not data.Humanoid or not data.StatusGUI then return end
    
    local health = data.Humanoid.Health
    local maxHealth = data.Humanoid.MaxHealth
    local healthPercent = math.floor((health / maxHealth) * 100)
    
    if not data.LastHealthPercent or math.abs(data.LastHealthPercent - healthPercent) > 5 then
        data.StatusGUI.Update("Health", healthPercent .. "%")
        data.LastHealthPercent = healthPercent
    end
end

-- Optimized main AI update function with dead target fix
local function AIUpdate(data)
    if not data.IsActive or not data.Character or not data.Humanoid or not data.RootPart then
        return
    end
    
    local updateStart = tick()
    
    -- Performance throttling
    if updateStart - data.LastUpdateTime < Config.UpdateThrottle then
        return
    end
    
    data.LastUpdateTime = updateStart
    data.UpdateCount = (data.UpdateCount or 0) + 1
    
    -- Reset performance counters
    Performance.RaycastsThisFrame = 0
    
    -- Memory cleanup (less frequent)
    if updateStart - data.LastCleanup > Config.CleanupInterval then
        collectgarbage("step")
        
        -- Clean up old path memory
        for key, memory in pairs(data.PathMemory) do
            if updateStart - memory.time > 60 then
                data.PathMemory[key] = nil
            end
        end
        
        -- Clean up old dead targets
        for player, deathTime in pairs(data.DeadTargets) do
            if updateStart - deathTime > Config.MaxDeadTargetTime then
                data.DeadTargets[player] = nil
            end
        end
        
        for key, time in pairs(data.FailedPaths) do
            if updateStart - time > 30 then
                data.FailedPaths[key] = nil
            end
        end
        
        data.LastCleanup = updateStart
    end
    
    -- Update health display
    UpdateHealthDisplay(data)
    
    -- CRITICAL FIX: Validate current target before any processing
    local hasValidTarget = ValidateCurrentTarget(data)
    
    -- Target acquisition (with dead target filtering)
    if updateStart - data.LastTargetUpdate > Config.TargetRefreshRate or not hasValidTarget then
        data.LastTargetUpdate = updateStart
        data.CurrentTarget = FindBestTarget(Players.LocalPlayer, data.RootPart.Position, data.CurrentTarget, data)
        
        if data.StatusGUI then
            if data.CurrentTarget then
                data.StatusGUI.Update("Target", data.CurrentTarget.Player.Name)
                data.StatusGUI.Update("Distance", string.format("%.1f", data.CurrentTarget.Distance))
                data.StatusGUI.Update("Status", "Engaging")
            else
                data.StatusGUI.Update("Target", "None")
                data.StatusGUI.Update("Distance", "0.0")
                data.StatusGUI.Update("Status", "Searching")
                data.StatusGUI.Update("Mode", "Idle")
            end
        end
    end
    
    -- Skip if no valid target
    if not data.CurrentTarget or not hasValidTarget then
        return
    end
    
    -- Update target position and distance
    data.CurrentTarget.Distance = (data.CurrentTarget.RootPart.Position - data.RootPart.Position).Magnitude
    data.CurrentTarget.Position = data.CurrentTarget.RootPart.Position
    
    -- Navigation and movement
    if updateStart - data.LastNavigationUpdate > Config.NavigationUpdate then
        data.LastNavigationUpdate = updateStart
        
        local movePos, pathType = CalculateSmartPath(
            data.RootPart.Position,
            data.CurrentTarget.Position,
            data.Character,
            data
        )
        
        if data.StatusGUI then
            data.StatusGUI.Update("Mode", data.CombatMode .. " - " .. pathType)
        end
        
        -- Execute aggressive combat behavior
        data.LastAttackTime = ExecuteCombat(
            data.Humanoid,
            data.RootPart,
            data.CurrentTarget.Position,
            data.CurrentTarget.Distance,
            data.Sword,
            data.LastAttackTime,
            data
        )
    end
    
    -- Update performance stats
    local updateTime = tick() - updateStart
    UpdatePerformanceStats(data, updateTime)
end

-- Character setup
local function SetupCharacter(data)
    local player = Players.LocalPlayer
    if not player then return false end
    
    data.Character = player.Character
    if not data.Character then
        DebugPrint("Waiting for character...")
        data.Character = player.CharacterAdded:Wait()
        SafeWait(1.5)
    end
    
    local startTime = tick()
    while tick() - startTime < 5 do
        data.Humanoid = data.Character:FindFirstChildOfClass("Humanoid")
        data.RootPart = data.Character:FindFirstChild("HumanoidRootPart")
        
        if data.Humanoid and data.RootPart then
            break
        end
        RunService.Heartbeat:Wait()
    end
    
    if not data.Humanoid or not data.RootPart then
        DebugPrint("Failed to find character components")
        return false
    end
    
    data.Humanoid.WalkSpeed = 16 * Config.MoveSpeedMultiplier
    
    data.Sword = EquipSword(data.Character, data.Humanoid)
    if data.Sword and data.StatusGUI then
        data.StatusGUI.Update("Status", "Armed & Ready")
    end
    
    if data.Connections.healthChange then
        data.Connections.healthChange:Disconnect()
    end
    
    data.Connections.healthChange = data.Humanoid.HealthChanged:Connect(function()
        UpdateHealthDisplay(data)
    end)
    
    return true
end

-- Main control functions
function LinkedSwordAI.Start()
    local data = InitializeAIState()
    
    if data.IsActive then
        DebugPrint("AI is already running")
        return true
    end
    
    DebugPrint("Starting LinkedSwordAI with dead target fix...")
    
    if not data.StatusGUI then
        data.StatusGUI = CreateStatusGUI()
    end
    
    if not SetupCharacter(data) then
        DebugPrint("Failed to setup character")
        return false
    end
    
    data.IsActive = true
    data.LastUpdateTime = 0
    data.UpdateCount = 0
    data.LastTargetValidation = 0
    
    if data.Connections.heartbeat then
        data.Connections.heartbeat:Disconnect()
    end
    
    data.Connections.heartbeat = RunService.Heartbeat:Connect(function()
        AIUpdate(data)
    end)
    
    if data.Connections.respawn then
        data.Connections.respawn:Disconnect()
    end
    
    data.Connections.respawn = Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        DebugPrint("Character respawned - reinitializing...")
        SafeWait(2)
        
        if data.IsActive then
            data.Character = newCharacter
            SetupCharacter(data)
            if data.StatusGUI then
                data.StatusGUI.Update("Status", "Respawned - Active")
            end
        end
    end)
    
    if data.StatusGUI then
        data.StatusGUI.Update("Status", "Active - Target Fix")
    end
    
    LinkedSwordAI.IsRunning = true
    DebugPrint("LinkedSwordAI with dead target fix started successfully")
    return true
end

function LinkedSwordAI.Stop()
    local data = InitializeAIState()
    
    if not data.IsActive then
        return true
    end
    
    DebugPrint("Stopping LinkedSwordAI...")
    
    data.IsActive = false
    LinkedSwordAI.IsRunning = false
    
    for name, connection in pairs(data.Connections) do
        if connection then
            connection:Disconnect()
        end
    end
    data.Connections = {}
    
    data.Character = nil
    data.Humanoid = nil
    data.RootPart = nil
    data.Sword = nil
    data.CurrentTarget = nil
    data.KnownTargets = {}
    data.DeadTargets = {}
    
    if data.StatusGUI then
        data.StatusGUI.Update("Status", "Stopped")
        data.StatusGUI.Update("Target", "None")
        data.StatusGUI.Update("Mode", "Inactive")
    end
    
    DebugPrint("LinkedSwordAI stopped")
    return true
end

function LinkedSwordAI.Toggle()
    if LinkedSwordAI.IsRunning then
        return LinkedSwordAI.Stop()
    else
        return LinkedSwordAI.Start()
    end
end

-- Auto-initialization
local function Initialize()
    pcall(function()
        if not game:IsLoaded() then
            game.Loaded:Wait()
        end
        
        if not Players.LocalPlayer then
            Players.PlayerAdded:Wait()
        end
        
        SafeWait(3)
        LinkedSwordAI.Start()
        
        DebugPrint("LinkedSwordAI initialized successfully")
    end)
end

-- Global control functions
_G.LinkedSwordAI_Start = LinkedSwordAI.Start
_G.LinkedSwordAI_Stop = LinkedSwordAI.Stop
_G.LinkedSwordAI_Toggle = LinkedSwordAI.Toggle
_G.LinkedSwordAI_Debug = function() _G.LinkedSwordAIDebug = true end

-- Start the AI
spawn(Initialize)

return LinkedSwordAI
