--[[
    Linked Sword AI Combat Script (Stable Version)
    
    This script implements autonomous sword fighting AI for the Linked Sword tool in Roblox.
    Stable version with proven performance and reliability.
]]

-- Force print to output console immediately
local function forcePrint(...)
    local message = table.concat({...}, " ")
    print(message)
    print("") -- Force flush
end

-- Debug function with timestamps
local function debugPrint(category, ...)
    local args = {...}
    local message = "[" .. category .. "] " .. table.concat(args, " ")
    local timestamp = os.date("%H:%M:%S")
    forcePrint(timestamp .. " - " .. message)
end

forcePrint("LinkedSwordAI: Script starting...")
debugPrint("INIT", "Debug logging enabled")

-- Global persistent data to maintain state across respawns
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {},
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        MovementHistory = {},
        FailedPaths = {},
        LastEquipAttempt = 0,
        EquipmentReady = false,
        KnownVoidAreas = {},
        PathCache = {},
        LastPathfindingTime = 0,
        PerformanceStats = {
            PathfindingTime = 0,
            CombatTime = 0,
            MovementTime = 0,
            LastOptimizationTime = 0
        },
        AlternativePaths = {},
        FrameCounter = 0,
        LastCleanupTime = 0
    }
end

local persistentData = _G.LinkedSwordAIPersistentData

-- Configuration
local CONFIG = {
    DETECTION_RADIUS = 200,
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.7,
    LUNGE_DELAY = 0.1,
    STUCK_CHECK_DISTANCE = 1.5,
    STUCK_CHECK_TIME = 1.0,
    MAX_TARGET_DISTANCE = 250,
    MIN_HEALTH_CHECK = 0,
    RETARGET_CHECK_TIME = 1.5,
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -100,
    FORCEFIELD_FLEE_DISTANCE = 0,
    SWORD_CHECK_INTERVAL = 7,
    RESPAWN_EQUIP_DELAY = 1.5,
    MOVEMENT_MEMORY_TIME = 0.7,
    SAFE_GAP_DISTANCE = 10,
    PATH_SMOOTHING_FACTOR = 0.7,
    MOVEMENT_RETRY_DELAY = 1.0,
    NARROW_PASSAGE_WIDTH = 3.5,
    PATHFINDING_STEPS = 10,
    COMBAT_BEHAVIOR_CHANGE_TIME = 4.0,
    COMBAT_DEFENSIVE_CHANCE = 0.25,
    COMBAT_OFFENSIVE_CHANCE = 0.45,
    STRAFE_DISTANCE = 4,
    BRIDGE_CHECK_DISTANCE = 25,
    PERFORMANCE_MODE = true,
    PATH_CACHE_TIME = 3.0,
    ALTERNATIVE_PATH_COUNT = 4,
    MIN_ATTACK_DISTANCE = 3,
    UPDATE_THROTTLE = 2,
    GUI_UPDATE_INTERVAL = 10
}

-- Create status GUI
local function CreateStatusGUI()
    local gui = {}
    
    local parentOptions = {
        game:GetService("CoreGui"),
        game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui"),
        game:GetService("Players").LocalPlayer.Character
    }
    
    local screenGui
    for _, parent in ipairs(parentOptions) do
        if parent then
            local success, result = pcall(function()
                local newGui = Instance.new("ScreenGui")
                newGui.Name = "LinkedSwordAI_Status"
                newGui.Parent = parent
                return newGui
            end)
            
            if success then
                screenGui = result
                break
            end
        end
    end
    
    if not screenGui then
        forcePrint("LinkedSwordAI: Failed to create GUI - No valid parent found")
        return nil
    end
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 120)
    frame.Position = UDim2.new(0.8, 0, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.5
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    frame.Parent = screenGui
    
    local status = Instance.new("TextLabel")
    status.Size = UDim2.new(1, -10, 0, 20)
    status.Position = UDim2.new(0, 5, 0, 5)
    status.BackgroundTransparency = 1
    status.TextColor3 = Color3.fromRGB(255, 255, 255)
    status.Text = "Status: Initializing..."
    status.Font = Enum.Font.SourceSans
    status.TextSize = 14
    status.TextXAlignment = Enum.TextXAlignment.Left
    status.Parent = frame
    
    local target = Instance.new("TextLabel")
    target.Size = UDim2.new(1, -10, 0, 20)
    target.Position = UDim2.new(0, 5, 0, 30)
    target.BackgroundTransparency = 1
    target.TextColor3 = Color3.fromRGB(255, 150, 150)
    target.Text = "Target: None"
    target.Font = Enum.Font.SourceSans
    target.TextSize = 14
    target.TextXAlignment = Enum.TextXAlignment.Left
    target.Parent = frame
    
    local distance = Instance.new("TextLabel")
    distance.Size = UDim2.new(1, -10, 0, 20)
    distance.Position = UDim2.new(0, 5, 0, 55)
    distance.BackgroundTransparency = 1
    distance.TextColor3 = Color3.fromRGB(150, 255, 150)
    distance.Text = "Distance: N/A"
    distance.Font = Enum.Font.SourceSans
    distance.TextSize = 14
    distance.TextXAlignment = Enum.TextXAlignment.Left
    distance.Parent = frame
    
    local debug = Instance.new("TextLabel")
    debug.Size = UDim2.new(1, -10, 0, 20)
    debug.Position = UDim2.new(0, 5, 0, 80)
    debug.BackgroundTransparency = 1
    debug.TextColor3 = Color3.fromRGB(255, 255, 0)
    debug.Text = "Debug: Starting..."
    debug.Font = Enum.Font.SourceSans
    debug.TextSize = 14
    debug.TextXAlignment = Enum.TextXAlignment.Left
    debug.Parent = frame
    
    function gui.UpdateStatus(text)
        if status then
            status.Text = "Status: " .. text
        end
    end
    
    function gui.UpdateTarget(text)
        if target then
            target.Text = "Target: " .. text
        end
    end
    
    function gui.UpdateDistance(dist)
        if distance then
            distance.Text = "Distance: " .. (dist and string.format("%.1f", dist) or "N/A")
        end
    end
    
    function gui.UpdateDebug(text)
        if debug then
            debug.Text = "Debug: " .. text
        end
    end
    
    return gui
end

-- Main execution in protected call
local function InitializeAI()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    
    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        forcePrint("LinkedSwordAI: LocalPlayer not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: LocalPlayer found - " .. LocalPlayer.Name)
    
    local Character = LocalPlayer.Character
    if not Character then
        forcePrint("LinkedSwordAI: Character not found")
        return false
    end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    
    if not Humanoid or not HumanoidRootPart then
        forcePrint("LinkedSwordAI: Humanoid or HumanoidRootPart not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: Character components found")
    
    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
        if persistentData.StatusGUI then
            forcePrint("LinkedSwordAI: Status GUI created")
        end
    end
    
    -- Find the Linked Sword tool
    local function FindLinkedSword()
        if persistentData.SwordToolName then
            local storedSword = Character:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                return storedSword
            end
            
            storedSword = LocalPlayer.Backpack:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                return storedSword
            end
        end
        
        for _, tool in pairs(Character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        
        return nil
    end
    
    -- Check for sword periodically
    local function CheckForSword()
        local currentTime = tick()
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword = FindLinkedSword()
            end
            persistentData.LastSwordCheckTime = currentTime
        end
    end
    
    -- Find players in range
    local function FindPlayersInRange()
        local playersInRange = {}
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and 
               player.Character:FindFirstChild("HumanoidRootPart") and
               player.Character:FindFirstChild("Humanoid") and
               player.Character.Humanoid.Health > CONFIG.MIN_HEALTH_CHECK then
                
                local playerHRP = player.Character.HumanoidRootPart
                local distance = (playerHRP.Position - HumanoidRootPart.Position).Magnitude
                
                if distance <= CONFIG.DETECTION_RADIUS then
                    table.insert(playersInRange, {
                        player = player,
                        distance = distance
                    })
                end
            end
        end
        
        table.sort(playersInRange, function(a, b)
            return a.distance < b.distance
        end)
        
        return playersInRange
    end
    
    -- Check if a position is in a void area
    local function IsVoidArea(position)
        for i, voidPos in ipairs(persistentData.KnownVoidAreas) do
            if (position - voidPos).Magnitude < 5 then
                return true
            end
        end
        
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            if #persistentData.KnownVoidAreas < 50 then
                table.insert(persistentData.KnownVoidAreas, position)
            else
                table.remove(persistentData.KnownVoidAreas, 1)
                table.insert(persistentData.KnownVoidAreas, position)
            end
            return true
        end
        
        local ray = Ray.new(position, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
        local hit = Workspace:FindPartOnRay(ray, Character)
        
        if not hit then
            if #persistentData.KnownVoidAreas < 50 then
                table.insert(persistentData.KnownVoidAreas, position)
            else
                table.remove(persistentData.KnownVoidAreas, 1)
                table.insert(persistentData.KnownVoidAreas, position)
            end
            return true
        end
        
        return false
    end
    
    -- Check if a gap between two points is safe to traverse
    local function IsSafeGap(startPos, endPos)
        local distance = (endPos - startPos).Magnitude
        
        if distance < 3 then
            return not IsVoidArea(endPos)
        end
        
        if distance < CONFIG.SAFE_GAP_DISTANCE then
            local ray = Ray.new(endPos, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
            local hit = Workspace:FindPartOnRay(ray, Character)
            return hit ~= nil
        end
        
        local direction = (endPos - startPos).Unit
        local checkCount = math.ceil(distance / 2)
        
        for i = 1, checkCount do
            local checkPoint = startPos + direction * (i * 2)
            local ray = Ray.new(checkPoint, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
            local hit = Workspace:FindPartOnRay(ray, Character)
            
            if not hit then
                return false
            end
        end
        
        return true
    end
    
    -- Check if path to target is safe (no voids)
    local function IsSafePath(targetPosition)
        if CONFIG.PERFORMANCE_MODE then
            local currentTime = tick()
            for cachedPath, data in pairs(persistentData.PathCache) do
                if (Vector3.new(cachedPath.x, cachedPath.y, cachedPath.z) - targetPosition).Magnitude < 5 and 
                   currentTime - data.time < CONFIG.PATH_CACHE_TIME then
                    return data.safe, data.bridgePath, data.alternativePath
                end
            end
        end
        
        local startTime = tick()
        
        for _, failedPath in ipairs(persistentData.FailedPaths) do
            if (targetPosition - failedPath.position).Magnitude < 5 and 
               tick() - failedPath.time < 10 then
                return false
            end
        end
        
        local startPos = HumanoidRootPart.Position
        local direction = (targetPosition - startPos).Unit
        local distance = (targetPosition - startPos).Magnitude
        
        local increment = math.min(5, distance / 5)
        
        for i = increment, distance, increment do
            local checkPos = startPos + direction * i
            if IsVoidArea(checkPos) then
                if #persistentData.FailedPaths >= 10 then
                    table.remove(persistentData.FailedPaths, 1)
                end
                table.insert(persistentData.FailedPaths, {
                    position = targetPosition,
                    time = tick()
                })
                
                if CONFIG.PERFORMANCE_MODE then
                    persistentData.PathCache[targetPosition] = {
                        safe = false,
                        time = tick(),
                        bridgePath = nil
                    }
                    persistentData.PerformanceStats.PathfindingTime = tick() - startTime
                end
                
                return false
            end
        end
        
        if IsVoidArea(targetPosition) then
            if #persistentData.FailedPaths >= 10 then
                table.remove(persistentData.FailedPaths, 1)
            end
            table.insert(persistentData.FailedPaths, {
                position = targetPosition,
                time = tick()
            })
            
            if CONFIG.PERFORMANCE_MODE then
                persistentData.PathCache[targetPosition] = {
                    safe = false,
                    time = tick(),
                    bridgePath = nil
                }
                persistentData.PerformanceStats.PathfindingTime = tick() - startTime
            end
            
            return false
        end
        
        if CONFIG.PERFORMANCE_MODE then
            persistentData.PathCache[targetPosition] = {
                safe = true,
                time = tick(),
                bridgePath = nil
            }
            persistentData.PerformanceStats.PathfindingTime = tick() - startTime
        end
        
        return true
    end
    
    -- Check if we're stuck on a player
    local function CheckIfStuck()
        if not persistentData.LastStuckPosition then
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = tick()
            return false
        end
        
        local currentTime = tick()
        local timeDiff = currentTime - persistentData.LastStuckTime
        
        if timeDiff > CONFIG.STUCK_CHECK_TIME then
            local distance = (HumanoidRootPart.Position - persistentData.LastStuckPosition).Magnitude
            
            if distance < CONFIG.STUCK_CHECK_DISTANCE then
                persistentData.IsStuck = true
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Stuck detected") end
                return true
            end
            
            persistentData.LastStuckPosition = HumanoidRootPart.Position
            persistentData.LastStuckTime = currentTime
        end
        
        return false
    end
    
    -- Handle being stuck on a player
    local function HandleStuckOnPlayer()
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("Unstucking from player") end
        
        local directions = {
            Vector3.new(1, 0, 0),
            Vector3.new(-1, 0, 0),
            Vector3.new(0, 0, 1),
            Vector3.new(0, 0, -1),
            Vector3.new(1, 0, 1).Unit,
            Vector3.new(-1, 0, 1).Unit,
            Vector3.new(1, 0, -1).Unit,
            Vector3.new(-1, 0, -1).Unit
        }
        
        for _, direction in ipairs(directions) do
            local targetPosition = HumanoidRootPart.Position + direction * 5
            
            if IsSafePath(targetPosition) then
                Humanoid:MoveTo(targetPosition)
                if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("Moving to unstuck") end
                return true
            end
        end
        
        if persistentData.StatusGUI then persistentData.StatusGUI.UpdateDebug("No safe path to unstuck") end
        return false
    end
    
    -- Smooth movement function
    local function MoveTo(targetPosition)
        local currentDirection = (targetPosition - HumanoidRootPart.Position).Unit
        local currentTime = tick()
        
        local smoothedDirection = currentDirection
        if persistentData.LastMovementDirection and 
           currentTime - persistentData.LastMovementTime < CONFIG.MOVEMENT_MEMORY_TIME then
            smoothedDirection = (persistentData.LastMovementDirection * CONFIG.PATH_SMOOTHING_FACTOR + 
                               currentDirection * (1 - CONFIG.PATH_SMOOTHING_FACTOR)).Unit
        end
        
        local smoothedTarget = HumanoidRootPart.Position + smoothedDirection * 
                              math.min(5, (targetPosition - HumanoidRootPart.Position).Magnitude)
        
        if IsSafeGap(HumanoidRootPart.Position, smoothedTarget) then
            persistentData.LastMovementDirection = smoothedDirection
            persistentData.LastMovementTime = currentTime
            Humanoid:MoveTo(smoothedTarget)
            return true
        else
            return false
        end
    end
    
    -- Execute attack
    local function ExecuteAttack()
        if not persistentData.LinkedSword then
            return
        end
        
        if persistentData.AttackSequenceActive then
            return
        end
        
        persistentData.AttackSequenceActive = true
        persistentData.LastAttackTime = tick()
        
        if not persistentData.CurrentCombatBehavior or 
           tick() - persistentData.LastBehaviorChangeTime > CONFIG.COMBAT_BEHAVIOR_CHANGE_TIME then
            
            local rand = math.random()
            if rand < CONFIG.COMBAT_DEFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "defensive"
            elseif rand < CONFIG.COMBAT_DEFENSIVE_CHANCE + CONFIG.COMBAT_OFFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "offensive"
            else
                persistentData.CurrentCombatBehavior = "offensive-defensive"
            end
            
            persistentData.LastBehaviorChangeTime = tick()
        end
        
        if persistentData.CurrentTarget and 
           persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
            HumanoidRootPart.CFrame = CFrame.new(
                HumanoidRootPart.Position,
                Vector3.new(targetPos.X, HumanoidRootPart.Position.Y, targetPos.Z)
            )
        end
        
        spawn(function()
            if persistentData.CurrentCombatBehavior == "defensive" then
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.2)
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.5)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (HumanoidRootPart.Position - targetPos).Unit
                    local backPos = HumanoidRootPart.Position + moveDir * 2
                    MoveTo(backPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            elseif persistentData.CurrentCombatBehavior == "offensive" then
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.6)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local forwardPos = HumanoidRootPart.Position + moveDir * 3
                    MoveTo(forwardPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.7)
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            else
                pcall(function() persistentData.LinkedSword:Activate() end)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local strafeDir = moveDir:Cross(Vector3.new(0, 1, 0)).Unit
                    
                    if math.random() > 0.5 then
                        strafeDir = -strafeDir
                    end
                    
                    local strafePos = HumanoidRootPart.Position + strafeDir * CONFIG.STRAFE_DISTANCE
                    MoveTo(strafePos)
                end
                
                wait(CONFIG.LUNGE_DELAY)
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local approachPos = HumanoidRootPart.Position + moveDir * 2
                    MoveTo(approachPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
            end
            
            wait(0.2)
            persistentData.AttackSequenceActive = false
        end)
    end
    
    -- Simple memory cleanup
    local function PerformMemoryCleanup()
        local currentTime = tick()
        
        -- Clean up path cache
        local cacheCount = 0
        for _ in pairs(persistentData.PathCache) do cacheCount = cacheCount + 1 end
        
        if cacheCount > 20 then
            local oldestTime = math.huge
            local oldestKey = nil
            for k, v in pairs(persistentData.PathCache) do
                if v.time < oldestTime then
                    oldestTime = v.time
                    oldestKey = k
                end
            end
            if oldestKey then persistentData.PathCache[oldestKey] = nil end
        end
        
        -- Clean up failed paths
        for i = #persistentData.FailedPaths, 1, -1 do
            if currentTime - persistentData.FailedPaths[i].time > 20 then
                table.remove(persistentData.FailedPaths, i)
            end
        end
        
        -- Clean up void areas
        if #persistentData.KnownVoidAreas > 50 then
            local removeCount = #persistentData.KnownVoidAreas - 50
            for i = 1, removeCount do
                table.remove(persistentData.KnownVoidAreas, 1)
            end
        end
        
        persistentData.LastCleanupTime = currentTime
    end
    
    -- Main update function
    local function Update()
        persistentData.FrameCounter = persistentData.FrameCounter + 1
        
        -- Only process heavy operations every Nth frame
        local shouldProcessHeavy = (persistentData.FrameCounter % CONFIG.UPDATE_THROTTLE == 0)
        
        if shouldProcessHeavy then
            PerformMemoryCleanup()
            CheckForSword()
        end
        
        local currentTime = tick()
        local needNewTarget = not persistentData.CurrentTarget or 
                             not persistentData.CurrentTarget.Character or 
                             not persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        
        local checkForCloserTarget = currentTime - persistentData.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME
        
        if needNewTarget or checkForCloserTarget then
            local playersInRange = FindPlayersInRange()
            
            if #playersInRange > 0 then
                local newTarget = playersInRange[1].player
                
                if newTarget ~= persistentData.CurrentTarget then
                    persistentData.CurrentTarget = newTarget
                    if persistentData.StatusGUI then 
                        persistentData.StatusGUI.UpdateTarget(newTarget.Name)
                    end
                end
            else
                persistentData.CurrentTarget = nil
                if persistentData.StatusGUI then 
                    persistentData.StatusGUI.UpdateTarget("None")
                end
            end
            
            persistentData.LastRetargetTime = currentTime
        end
        
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetHRP = persistentData.CurrentTarget.Character.HumanoidRootPart
            local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
            
            if persistentData.StatusGUI and (persistentData.FrameCounter % CONFIG.GUI_UPDATE_INTERVAL == 0) then
                persistentData.StatusGUI.UpdateDistance(distance)
            end
            
            if CheckIfStuck() then
                if shouldProcessHeavy then
                    HandleStuckOnPlayer()
                end
                return
            else
                persistentData.IsStuck = false
            end
            
            if IsSafePath(targetHRP.Position) then
                MoveTo(targetHRP.Position)
                
                HumanoidRootPart.CFrame = CFrame.lookAt(
                    HumanoidRootPart.Position, 
                    Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
                )
                
                if distance <= CONFIG.ATTACK_RANGE and 
                   persistentData.LinkedSword and 
                   currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    ExecuteAttack()
                elseif distance <= CONFIG.MIN_ATTACK_DISTANCE and 
                       persistentData.LinkedSword and 
                       currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                    persistentData.CurrentCombatBehavior = "offensive"
                    ExecuteAttack()
                end
            else
                if persistentData.StatusGUI and shouldProcessHeavy then
                    persistentData.StatusGUI.UpdateStatus("Finding safe path")
                end
            end
        else
            if persistentData.StatusGUI and shouldProcessHeavy then
                persistentData.StatusGUI.UpdateStatus("Idle")
            end
        end
    end
    
    -- Handle sword equipping on respawn
    spawn(function()
        wait(CONFIG.RESPAWN_EQUIP_DELAY)
        
        persistentData.LinkedSword = FindLinkedSword()
        if persistentData.LinkedSword then
            if persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword.Parent = Character
            end
        end
    end)
    
    -- Initialize
    persistentData.LinkedSword = FindLinkedSword()
    persistentData.LastSwordCheckTime = tick()
    
    -- Connect update function
    local updateConnection
    updateConnection = RunService.Heartbeat:Connect(function()
        local success, error = pcall(Update)
        if not success then
            forcePrint("LinkedSwordAI: Error in update - " .. tostring(error))
        end
    end)
    
    -- Handle character respawn
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        forcePrint("LinkedSwordAI: Character respawned, reinitializing...")
        wait(1)
        InitializeAI()
    end)
    
    if persistentData.StatusGUI then persistentData.StatusGUI.UpdateStatus("AI Running") end
    forcePrint("LinkedSwordAI: Script initialized successfully")
    
    return true
end

-- Start the AI
local success, errorMsg = pcall(InitializeAI)

if not success then
    forcePrint("LinkedSwordAI: Critical error - " .. tostring(errorMsg))
end
