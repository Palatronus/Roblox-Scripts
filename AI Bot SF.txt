--[[
    Linked Sword AI Combat Script (Stable Performance Edition)
    
    This script implements autonomous sword fighting AI for the Linked Sword tool in Roblox.
    Advanced performance optimizations with stable FPS and vanishing platform support.
]]

-- Force print to output console immediately
local function forcePrint(...)
    local message = table.concat({...}, " ")
    print(message)
    print("") -- Force flush
end

-- Debug function with timestamps
local function debugPrint(category, ...)
    local args = {...}
    local message = "[" .. category .. "] " .. table.concat(args, " ")
    local timestamp = os.date("%H:%M:%S")
    forcePrint(timestamp .. " - " .. message)
end

forcePrint("LinkedSwordAI: Script starting...")
debugPrint("INIT", "Debug logging enabled")

-- Global persistent data to maintain state across respawns
if not _G.LinkedSwordAIPersistentData then
    _G.LinkedSwordAIPersistentData = {
        LinkedSword = nil,
        CurrentTarget = nil,
        LastAttackTime = 0,
        LastSwordCheckTime = 0,
        LastRetargetTime = 0,
        LastStuckPosition = nil,
        LastStuckTime = 0,
        IsStuck = false,
        AttackSequenceActive = false,
        PlayersWithForceField = {},
        StatusGUI = nil,
        SwordToolName = nil,
        LastMovementDirection = nil,
        LastMovementTime = 0,
        -- Performance optimization fields
        FrameCounter = 0,
        LastCleanupTime = 0,
        CachedPlayers = {},
        LastPlayerCacheUpdate = 0,
        SafeTerrainCache = {},
        LastTerrainScan = 0,
        ImmediateSafeDirections = {},
        -- NEW: Memory management
        ActiveConnections = {},
        RunningThreads = {},
        LastGCTime = 0,
        -- NEW: Vanishing platform detection
        VanishingPlatforms = {},
        LastPlatformCheck = 0,
        FallingDetection = {
            IsFalling = false,
            FallStartTime = 0,
            FallStartPosition = nil
        }
    }
end

local persistentData = _G.LinkedSwordAIPersistentData

-- Configuration with maximum performance optimizations
local CONFIG = {
    DETECTION_RADIUS = 200,
    ATTACK_RANGE = 15,
    ATTACK_COOLDOWN = 0.7,
    LUNGE_DELAY = 0.1,
    STUCK_CHECK_DISTANCE = 1.5,
    STUCK_CHECK_TIME = 1.0,
    MAX_TARGET_DISTANCE = 250,
    MIN_HEALTH_CHECK = 0,
    RETARGET_CHECK_TIME = 2.0, -- Increased for performance
    VOID_CHECK_DISTANCE = 50,
    VOID_Y_THRESHOLD = -100,
    FORCEFIELD_FLEE_DISTANCE = 0,
    SWORD_CHECK_INTERVAL = 10, -- Increased for performance
    RESPAWN_EQUIP_DELAY = 1.5,
    MOVEMENT_MEMORY_TIME = 0.7,
    SAFE_GAP_DISTANCE = 10,
    PATH_SMOOTHING_FACTOR = 0.7,
    MOVEMENT_RETRY_DELAY = 1.0,
    NARROW_PASSAGE_WIDTH = 3.5,
    COMBAT_BEHAVIOR_CHANGE_TIME = 4.0,
    COMBAT_DEFENSIVE_CHANCE = 0.25,
    COMBAT_OFFENSIVE_CHANCE = 0.45,
    STRAFE_DISTANCE = 4,
    BRIDGE_CHECK_DISTANCE = 25,
    PERFORMANCE_MODE = true,
    MIN_ATTACK_DISTANCE = 3,
    -- Enhanced performance optimization settings
    UPDATE_THROTTLE = 3, -- Further reduced processing
    MAX_PLAYER_CACHE_TIME = 2.0, -- Increased cache time
    GUI_UPDATE_INTERVAL = 20, -- Much less frequent GUI updates
    -- NEW: Memory management
    GC_INTERVAL = 10, -- Force garbage collection every 10 seconds
    MAX_THREADS = 5, -- Maximum concurrent threads
    CONNECTION_CLEANUP_INTERVAL = 5, -- Cleanup connections every 5 seconds
    -- NEW: Vanishing platform detection
    VANISHING_PLATFORM_CHECK = 0.3, -- Check for vanishing platforms
    FALL_DETECTION_THRESHOLD = 0.5, -- Time threshold for fall detection
    PLATFORM_RAYCAST_DISTANCE = 10, -- Distance to check for platforms below
    QUICK_MOVEMENT_UPDATE = 2 -- Movement updates every 2nd frame
}

-- NEW: Memory management system
local MemoryManager = {
    Active = true,
    ThreadCount = 0,
    ConnectionCount = 0
}

function MemoryManager:RegisterThread(thread)
    if not self.Active then return thread end
    
    self.ThreadCount = self.ThreadCount + 1
    persistentData.RunningThreads[thread] = true
    
    -- Limit maximum threads
    if self.ThreadCount > CONFIG.MAX_THREADS then
        self:CleanupOldestThread()
    end
    
    return thread
end

function MemoryManager:RegisterConnection(connection)
    if not self.Active then return connection end
    
    self.ConnectionCount = self.ConnectionCount + 1
    persistentData.ActiveConnections[connection] = true
    
    return connection
end

function MemoryManager:CleanupOldestThread()
    local oldestThread, oldestTime = nil, math.huge
    for thread, _ in pairs(persistentData.RunningThreads) do
        if thread and type(thread) == "thread" then
            -- We can't get thread creation time, so we'll remove the first one we find
            oldestThread = thread
            break
        end
    end
    
    if oldestThread then
        persistentData.RunningThreads[oldestThread] = nil
        self.ThreadCount = math.max(0, self.ThreadCount - 1)
    end
end

function MemoryManager:CleanupAll()
    self.Active = false
    
    -- Disconnect all connections
    for connection, _ in pairs(persistentData.ActiveConnections) do
        if connection and typeof(connection) == "RBXScriptConnection" then
            connection:Disconnect()
        end
    end
    
    -- Clear all tables
    persistentData.ActiveConnections = {}
    persistentData.RunningThreads = {}
    persistentData.SafeTerrainCache = {}
    persistentData.CachedPlayers = {}
    persistentData.VanishingPlatforms = {}
    
    self.ThreadCount = 0
    self.ConnectionCount = 0
    
    -- Force garbage collection
    wait(0.1)
    game:GetService("RunService"):Heartbeat():Wait()
    collectgarbage()
end

function MemoryManager:PeriodicCleanup()
    local currentTime = tick()
    if currentTime - persistentData.LastCleanupTime > CONFIG.CONNECTION_CLEANUP_INTERVAL then
        -- Clean up dead threads
        local activeThreads = 0
        for thread, _ in pairs(persistentData.RunningThreads) do
            if thread and coroutine.status(thread) == "dead" then
                persistentData.RunningThreads[thread] = nil
            else
                activeThreads = activeThreads + 1
            end
        end
        self.ThreadCount = activeThreads
        
        -- Clean up disconnected connections
        local activeConnections = 0
        for connection, _ in pairs(persistentData.ActiveConnections) do
            if not connection.Connected then
                persistentData.ActiveConnections[connection] = nil
            else
                activeConnections = activeConnections + 1
            end
        end
        self.ConnectionCount = activeConnections
        
        persistentData.LastCleanupTime = currentTime
    end
    
    -- Force garbage collection periodically
    if currentTime - persistentData.LastGCTime > CONFIG.GC_INTERVAL then
        wait(0.05)
        collectgarbage()
        persistentData.LastGCTime = currentTime
    end
end

-- Create status GUI
local function CreateStatusGUI()
    local gui = {}
    
    local parentOptions = {
        game:GetService("CoreGui"),
        game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui")
    }
    
    local screenGui
    for _, parent in ipairs(parentOptions) do
        if parent then
            local success, result = pcall(function()
                local newGui = Instance.new("ScreenGui")
                newGui.Name = "LinkedSwordAI_Status"
                newGui.Parent = parent
                return newGui
            end)
            
            if success then
                screenGui = result
                break
            end
        end
    end
    
    if not screenGui then
        return nil
    end
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 100)
    frame.Position = UDim2.new(0.8, 0, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BackgroundTransparency = 0.7
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    
    local status = Instance.new("TextLabel")
    status.Size = UDim2.new(1, -10, 0, 25)
    status.Position = UDim2.new(0, 5, 0, 5)
    status.BackgroundTransparency = 1
    status.TextColor3 = Color3.fromRGB(255, 255, 255)
    status.Text = "Status: Initializing..."
    status.Font = Enum.Font.SourceSansBold
    status.TextSize = 14
    status.TextXAlignment = Enum.TextXAlignment.Left
    status.Parent = frame
    
    local target = Instance.new("TextLabel")
    target.Size = UDim2.new(1, -10, 0, 20)
    target.Position = UDim2.new(0, 5, 0, 30)
    target.BackgroundTransparency = 1
    target.TextColor3 = Color3.fromRGB(255, 150, 150)
    target.Text = "Target: None"
    target.Font = Enum.Font.SourceSans
    target.TextSize = 12
    target.TextXAlignment = Enum.TextXAlignment.Left
    target.Parent = frame
    
    local distance = Instance.new("TextLabel")
    distance.Size = UDim2.new(1, -10, 0, 20)
    distance.Position = UDim2.new(0, 5, 0, 50)
    distance.BackgroundTransparency = 1
    distance.TextColor3 = Color3.fromRGB(150, 255, 150)
    distance.Text = "Distance: N/A"
    distance.Font = Enum.Font.SourceSans
    distance.TextSize = 12
    distance.TextXAlignment = Enum.TextXAlignment.Left
    distance.Parent = frame
    
    local performance = Instance.new("TextLabel")
    performance.Size = UDim2.new(1, -10, 0, 20)
    performance.Position = UDim2.new(0, 5, 0, 70)
    performance.BackgroundTransparency = 1
    performance.TextColor3 = Color3.fromRGB(255, 255, 0)
    performance.Text = "Performance: Stable"
    performance.Font = Enum.Font.SourceSans
    performance.TextSize = 12
    performance.TextXAlignment = Enum.TextXAlignment.Left
    performance.Parent = frame
    
    function gui.UpdateStatus(text)
        if status then
            status.Text = "Status: " .. text
        end
    end
    
    function gui.UpdateTarget(text)
        if target then
            target.Text = "Target: " .. text
        end
    end
    
    function gui.UpdateDistance(dist)
        if distance then
            distance.Text = "Distance: " .. (dist and string.format("%.1f", dist) or "N/A")
        end
    end
    
    function gui.UpdatePerformance(text)
        if performance then
            performance.Text = "Performance: " .. text
        end
    end
    
    function gui.Destroy()
        if screenGui then
            screenGui:Destroy()
        end
    end
    
    return gui
end

-- NEW: Advanced vanishing platform detection
local function CheckForVanishingPlatforms(character, humanoidRootPart)
    local currentTime = tick()
    if currentTime - persistentData.LastPlatformCheck < CONFIG.VANISHING_PLATFORM_CHECK then
        return persistentData.VanishingPlatforms
    end
    
    persistentData.VanishingPlatforms = {}
    local workspace = game:GetService("Workspace")
    
    -- Check for platforms directly below
    local ray = Ray.new(humanoidRootPart.Position, Vector3.new(0, -CONFIG.PLATFORM_RAYCAST_DISTANCE, 0))
    local hit, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithWhitelist(ray, {workspace.Terrain}, character)
    
    if hit then
        -- Check if this might be a vanishing platform
        local platformKey = tostring(hitPoint.X) .. "_" .. tostring(hitPoint.Z)
        
        -- Store platform information
        persistentData.VanishingPlatforms[platformKey] = {
            position = hitPoint,
            part = hit,
            material = hitMaterial,
            lastSeen = currentTime
        }
    end
    
    -- Clean up old platform entries
    for key, platform in pairs(persistentData.VanishingPlatforms) do
        if currentTime - platform.lastSeen > 5 then -- Remove after 5 seconds
            persistentData.VanishingPlatforms[key] = nil
        end
    end
    
    persistentData.LastPlatformCheck = currentTime
    return persistentData.VanishingPlatforms
end

-- NEW: Improved falling detection for vanishing platforms
local function UpdateFallingDetection(humanoid, humanoidRootPart)
    local currentTime = tick()
    local fallingData = persistentData.FallingDetection
    
    if humanoid and humanoid:GetState() == Enum.HumanoidStateType.Freefall then
        if not fallingData.IsFalling then
            fallingData.IsFalling = true
            fallingData.FallStartTime = currentTime
            fallingData.FallStartPosition = humanoidRootPart.Position
        end
        
        -- Check if we've been falling for too long (possible vanishing platform)
        if currentTime - fallingData.FallStartTime > CONFIG.FALL_DETECTION_THRESHOLD then
            return true, currentTime - fallingData.FallStartTime
        end
    else
        fallingData.IsFalling = false
        fallingData.FallStartTime = 0
        fallingData.FallStartPosition = nil
    end
    
    return false, 0
end

-- NEW: Smart void detection that handles vanishing platforms
local function SmartVoidDetection(position, humanoid, humanoidRootPart)
    local workspace = game:GetService("Workspace")
    
    -- First, check if we're currently falling due to a vanishing platform
    local isFalling, fallDuration = UpdateFallingDetection(humanoid, humanoidRootPart)
    if isFalling and fallDuration > CONFIG.FALL_DETECTION_THRESHOLD then
        return true -- Treat prolonged falling as void
    end
    
    -- Basic Y-threshold check
    if position.Y < CONFIG.VOID_Y_THRESHOLD then
        return true
    end
    
    -- Check for solid ground below
    local ray = Ray.new(position, Vector3.new(0, -CONFIG.VOID_CHECK_DISTANCE, 0))
    local hit, hitPoint = workspace:FindPartOnRay(ray, humanoid.Parent)
    
    if not hit then
        -- No ground below, check if this might be a vanishing platform area
        local platforms = CheckForVanishingPlatforms(humanoid.Parent, humanoidRootPart)
        local nearbyPlatform = false
        
        for _, platform in pairs(platforms) do
            if (position - platform.position).Magnitude < 10 then
                nearbyPlatform = true
                break
            end
        end
        
        -- If no nearby platforms and no ground, it's a void
        if not nearbyPlatform then
            return true
        end
    end
    
    return false
end

-- Main execution in protected call
local function InitializeAI()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    
    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        forcePrint("LinkedSwordAI: LocalPlayer not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: LocalPlayer found - " .. LocalPlayer.Name)
    
    local Character = LocalPlayer.Character
    if not Character then
        forcePrint("LinkedSwordAI: Character not found")
        return false
    end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    
    if not Humanoid or not HumanoidRootPart then
        forcePrint("LinkedSwordAI: Humanoid or HumanoidRootPart not found")
        return false
    end
    
    forcePrint("LinkedSwordAI: Character components found")
    
    -- Initialize memory manager
    MemoryManager.Active = true
    
    -- Create status GUI if it doesn't exist
    if not persistentData.StatusGUI then
        persistentData.StatusGUI = CreateStatusGUI()
    end
    
    -- Find the Linked Sword tool (optimized)
    local function FindLinkedSword()
        if persistentData.SwordToolName then
            local storedSword = Character:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                return storedSword
            end
            
            storedSword = LocalPlayer.Backpack:FindFirstChild(persistentData.SwordToolName)
            if storedSword and storedSword:IsA("Tool") then
                return storedSword
            end
        end
        
        for _, tool in pairs(Character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:find("Sword") then
                persistentData.SwordToolName = tool.Name
                return tool
            end
        end
        
        return nil
    end
    
    -- Check for sword periodically (highly optimized)
    local function CheckForSword()
        local currentTime = tick()
        if currentTime - persistentData.LastSwordCheckTime > CONFIG.SWORD_CHECK_INTERVAL then
            if not persistentData.LinkedSword or persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword = FindLinkedSword()
            end
            persistentData.LastSwordCheckTime = currentTime
        end
    end
    
    -- Cache players for better performance
    local function UpdatePlayerCache()
        local currentTime = tick()
        if currentTime - persistentData.LastPlayerCacheUpdate < CONFIG.MAX_PLAYER_CACHE_TIME then
            return persistentData.CachedPlayers
        end
        
        persistentData.CachedPlayers = {}
        local players = Players:GetPlayers()
        
        for i = 1, #players do
            local player = players[i]
            if player ~= LocalPlayer and player.Character then
                persistentData.CachedPlayers[#persistentData.CachedPlayers + 1] = player
            end
        end
        
        persistentData.LastPlayerCacheUpdate = currentTime
        return persistentData.CachedPlayers
    end
    
    -- Find players in range (optimized)
    local function FindPlayersInRange()
        local playersInRange = {}
        local cachedPlayers = UpdatePlayerCache()
        local myPosition = HumanoidRootPart.Position
        
        for i = 1, #cachedPlayers do
            local player = cachedPlayers[i]
            if player.Character then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                
                if humanoid and hrp and humanoid.Health > CONFIG.MIN_HEALTH_CHECK then
                    local distance = (hrp.Position - myPosition).Magnitude
                    
                    if distance <= CONFIG.DETECTION_RADIUS then
                        playersInRange[#playersInRange + 1] = {
                            player = player,
                            distance = distance
                        }
                    end
                end
            end
        end
        
        table.sort(playersInRange, function(a, b)
            return a.distance < b.distance
        end)
        
        return playersInRange
    end
    
    -- NEW: Ultra-fast safety check
    local function QuickSafetyCheck(position)
        -- Fast Y-check first
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            return false
        end
        
        -- Quick ground check
        local ray = Ray.new(position, Vector3.new(0, -5, 0))
        return Workspace:FindPartOnRay(ray, Character) ~= nil
    end
    
    -- NEW: Smart path safety check with vanishing platform support
    local function SmartPathSafetyCheck(targetPosition)
        local startPos = HumanoidRootPart.Position
        local distance = (targetPosition - startPos).Magnitude
        
        -- For short distances, use quick checks
        if distance < 8 then
            return not SmartVoidDetection(targetPosition, Humanoid, HumanoidRootPart)
        end
        
        -- For longer distances, check intermediate points
        local direction = (targetPosition - startPos).Unit
        local steps = math.ceil(distance / 4) -- Reduced check frequency
        
        for i = 1, steps do
            local checkPos = startPos + direction * (i * 4)
            if SmartVoidDetection(checkPos, Humanoid, HumanoidRootPart) then
                return false
            end
        end
        
        return not SmartVoidDetection(targetPosition, Humanoid, HumanoidRootPart)
    end
    
    -- NEW: Immediate movement with vanishing platform awareness
    local function ImmediateMoveTo(targetPosition)
        local currentDirection = (targetPosition - HumanoidRootPart.Position).Unit
        local currentTime = tick()
        
        -- Apply smoothing
        local smoothedDirection = currentDirection
        if persistentData.LastMovementDirection and 
           currentTime - persistentData.LastMovementTime < CONFIG.MOVEMENT_MEMORY_TIME then
            smoothedDirection = (persistentData.LastMovementDirection * CONFIG.PATH_SMOOTHING_FACTOR + 
                               currentDirection * (1 - CONFIG.PATH_SMOOTHING_FACTOR)).Unit
        end
        
        local moveDistance = math.min(3, (targetPosition - HumanoidRootPart.Position).Magnitude)
        local smoothedTarget = HumanoidRootPart.Position + smoothedDirection * moveDistance
        
        -- Check if path is safe (including vanishing platforms)
        if SmartPathSafetyCheck(smoothedTarget) then
            persistentData.LastMovementDirection = smoothedDirection
            persistentData.LastMovementTime = currentTime
            Humanoid:MoveTo(smoothedTarget)
            return true
        end
        
        return false
    end
    
    -- Execute attack (optimized)
    local function ExecuteAttack()
        if not persistentData.LinkedSword or persistentData.AttackSequenceActive then
            return
        end
        
        persistentData.AttackSequenceActive = true
        persistentData.LastAttackTime = tick()
        
        if not persistentData.CurrentCombatBehavior or 
           tick() - persistentData.LastBehaviorChangeTime > CONFIG.COMBAT_BEHAVIOR_CHANGE_TIME then
            
            local rand = math.random()
            if rand < CONFIG.COMBAT_DEFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "defensive"
            elseif rand < CONFIG.COMBAT_DEFENSIVE_CHANCE + CONFIG.COMBAT_OFFENSIVE_CHANCE then
                persistentData.CurrentCombatBehavior = "offensive"
            else
                persistentData.CurrentCombatBehavior = "offensive-defensive"
            end
            
            persistentData.LastBehaviorChangeTime = tick()
        end
        
        if persistentData.CurrentTarget and 
           persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
            HumanoidRootPart.CFrame = CFrame.new(
                HumanoidRootPart.Position,
                Vector3.new(targetPos.X, HumanoidRootPart.Position.Y, targetPos.Z)
            )
        end
        
        -- Use memory manager to track this thread
        local attackThread = coroutine.create(function()
            if persistentData.CurrentCombatBehavior == "defensive" then
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.2)
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 1.5)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (HumanoidRootPart.Position - targetPos).Unit
                    local backPos = HumanoidRootPart.Position + moveDir * 2
                    ImmediateMoveTo(backPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            elseif persistentData.CurrentCombatBehavior == "offensive" then
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.6)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local forwardPos = HumanoidRootPart.Position + moveDir * 3
                    ImmediateMoveTo(forwardPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY * 0.7)
                pcall(function() persistentData.LinkedSword:Activate() end)
                
            else
                pcall(function() persistentData.LinkedSword:Activate() end)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local strafeDir = moveDir:Cross(Vector3.new(0, 1, 0)).Unit
                    
                    if math.random() > 0.5 then
                        strafeDir = -strafeDir
                    end
                    
                    local strafePos = HumanoidRootPart.Position + strafeDir * CONFIG.STRAFE_DISTANCE
                    ImmediateMoveTo(strafePos)
                end
                
                wait(CONFIG.LUNGE_DELAY)
                pcall(function() persistentData.LinkedSword:Activate() end)
                wait(CONFIG.LUNGE_DELAY)
                
                if persistentData.CurrentTarget and 
                   persistentData.CurrentTarget.Character and 
                   persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
                    
                    local targetPos = persistentData.CurrentTarget.Character.HumanoidRootPart.Position
                    local moveDir = (targetPos - HumanoidRootPart.Position).Unit
                    local approachPos = HumanoidRootPart.Position + moveDir * 2
                    ImmediateMoveTo(approachPos)
                end
                
                pcall(function() persistentData.LinkedSword:Activate() end)
            end
            
            wait(0.2)
            persistentData.AttackSequenceActive = false
        end)
        
        MemoryManager:RegisterThread(attackThread)
        coroutine.resume(attackThread)
    end
    
    -- NEW: Health monitoring for cleanup
    local function MonitorHealth()
        if Humanoid.Health <= 0 then
            forcePrint("LinkedSwordAI: Player died, cleaning up...")
            MemoryManager:CleanupAll()
            if persistentData.StatusGUI then
                persistentData.StatusGUI.UpdatePerformance("Cleaned Up")
            end
            return true
        end
        return false
    end
    
    -- Main update function with maximum optimization
    local function Update()
        if MonitorHealth() then return end
        
        persistentData.FrameCounter = persistentData.FrameCounter + 1
        
        -- Process memory management every frame
        MemoryManager:PeriodicCleanup()
        
        -- Only process heavy operations every Nth frame
        local shouldProcessHeavy = (persistentData.FrameCounter % CONFIG.UPDATE_THROTTLE == 0)
        local shouldUpdateMovement = (persistentData.FrameCounter % CONFIG.QUICK_MOVEMENT_UPDATE == 0)
        local shouldUpdateGUI = (persistentData.FrameCounter % CONFIG.GUI_UPDATE_INTERVAL == 0)
        
        if shouldProcessHeavy then
            CheckForSword()
        end
        
        local currentTime = tick()
        local needNewTarget = not persistentData.CurrentTarget or 
                             not persistentData.CurrentTarget.Character or 
                             not persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        
        local checkForCloserTarget = currentTime - persistentData.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME
        
        if (needNewTarget or checkForCloserTarget) and shouldProcessHeavy then
            local playersInRange = FindPlayersInRange()
            
            if #playersInRange > 0 then
                local newTarget = playersInRange[1].player
                
                if newTarget ~= persistentData.CurrentTarget then
                    persistentData.CurrentTarget = newTarget
                    if persistentData.StatusGUI and shouldUpdateGUI then
                        persistentData.StatusGUI.UpdateTarget(newTarget.Name)
                    end
                end
            else
                persistentData.CurrentTarget = nil
                if persistentData.StatusGUI and shouldUpdateGUI then
                    persistentData.StatusGUI.UpdateTarget("None")
                end
            end
            
            persistentData.LastRetargetTime = currentTime
        end
        
        if persistentData.CurrentTarget and persistentData.CurrentTarget.Character and 
           persistentData.CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            
            local targetHRP = persistentData.CurrentTarget.Character.HumanoidRootPart
            local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
            
            if persistentData.StatusGUI and shouldUpdateGUI then
                persistentData.StatusGUI.UpdateDistance(distance)
                persistentData.StatusGUI.UpdatePerformance("Stable")
            end
            
            -- Always face the target
            HumanoidRootPart.CFrame = CFrame.lookAt(
                HumanoidRootPart.Position, 
                Vector3.new(targetHRP.Position.X, HumanoidRootPart.Position.Y, targetHRP.Position.Z)
            )
            
            if shouldUpdateMovement then
                -- Check path safety with vanishing platform support
                local isSafe = SmartPathSafetyCheck(targetHRP.Position)
                
                if isSafe then
                    ImmediateMoveTo(targetHRP.Position)
                    
                    if distance <= CONFIG.ATTACK_RANGE and 
                       persistentData.LinkedSword and 
                       currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        ExecuteAttack()
                    elseif distance <= CONFIG.MIN_ATTACK_DISTANCE and 
                           persistentData.LinkedSword and 
                           currentTime - persistentData.LastAttackTime > CONFIG.ATTACK_COOLDOWN then
                        persistentData.CurrentCombatBehavior = "offensive"
                        ExecuteAttack()
                    end
                else
                    -- Find safe retreat position
                    local retreatDir = (HumanoidRootPart.Position - targetHRP.Position).Unit
                    local retreatPos = HumanoidRootPart.Position + retreatDir * 5
                    
                    if SmartPathSafetyCheck(retreatPos) then
                        ImmediateMoveTo(retreatPos)
                    end
                end
            else
                -- Light frame: just maintain movement
                if persistentData.LastMovementDirection then
                    Humanoid:Move(persistentData.LastMovementDirection)
                end
            end
        else
            if persistentData.StatusGUI and shouldUpdateGUI then
                persistentData.StatusGUI.UpdateStatus("Idle")
            end
        end
    end
    
    -- Handle sword equipping on respawn
    local equipThread = coroutine.create(function()
        wait(CONFIG.RESPAWN_EQUIP_DELAY)
        
        persistentData.LinkedSword = FindLinkedSword()
        if persistentData.LinkedSword then
            if persistentData.LinkedSword.Parent ~= Character then
                persistentData.LinkedSword.Parent = Character
                wait(0.5)
                
                if persistentData.LinkedSword.Parent == Character then
                    persistentData.EquipmentReady = true
                end
            else
                persistentData.EquipmentReady = true
            end
        end
    end)
    
    MemoryManager:RegisterThread(equipThread)
    coroutine.resume(equipThread)
    
    -- Initialize
    persistentData.LinkedSword = FindLinkedSword()
    persistentData.LastSwordCheckTime = tick()
    persistentData.FrameCounter = 0
    persistentData.LastGCTime = tick()
    
    -- Connect optimized update function with memory management
    local updateConnection = RunService.Heartbeat:Connect(function()
        local success, error = pcall(Update)
        if not success then
            forcePrint("LinkedSwordAI: Error in update - " .. tostring(error))
        end
    end)
    
    MemoryManager:RegisterConnection(updateConnection)
    
    -- Handle character respawn with proper cleanup
    local respawnConnection = LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        forcePrint("LinkedSwordAI: Character respawned, cleaning up and reinitializing...")
        
        -- Clean up before reinitializing
        MemoryManager:CleanupAll()
        wait(1)
        
        -- Reinitialize
        InitializeAI()
    end)
    
    MemoryManager:RegisterConnection(respawnConnection)
    
    -- Handle player removal (leaving game)
    local playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
        if player == LocalPlayer then
            forcePrint("LinkedSwordAI: Player leaving game, cleaning up...")
            MemoryManager:CleanupAll()
        end
    end)
    
    MemoryManager:RegisterConnection(playerRemovingConnection)
    
    if persistentData.StatusGUI then 
        persistentData.StatusGUI.UpdateStatus("AI Running (Stable)")
        persistentData.StatusGUI.UpdatePerformance("Optimized")
    end
    forcePrint("LinkedSwordAI: Stable performance script initialized successfully")
    
    return true
end

-- Start the AI with enhanced error handling
local success, errorMsg = pcall(function()
    -- Initial garbage collection
    collectgarbage()
    wait(0.1)
    
    InitializeAI()
end)

if not success then
    forcePrint("LinkedSwordAI: Critical error - " .. tostring(errorMsg))
    -- Attempt cleanup even on error
    pcall(function()
        if persistentData and persistentData.StatusGUI then
            persistentData.StatusGUI.UpdateStatus("Error: " .. tostring(errorMsg))
        end
    end)
end
