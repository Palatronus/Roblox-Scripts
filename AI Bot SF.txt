-- LinkedSwordAI_Final.lua
-- Final optimized version with reliable pathfinding for Heights map

-- Force print function to ensure output is visible
local function forcePrint(...)
    local args = {...}
    local message = ""
    for i, v in ipairs(args) do
        message = message .. tostring(v) .. (i < #args and " " or "")
    end
    
    print(message)
    warn(message)
    pcall(function() rconsoleprint(message .. "\n") end)
end

forcePrint("LinkedSwordAI: Final optimized script starting...")

-- Optimized Configuration for Heights Map
local CONFIG = {
    DETECTION_RADIUS = 100,
    ATTACK_RANGE = 12,
    ATTACK_COOLDOWN = 0.7,
    LUNGE_DELAY = 0.1,
    MAX_TARGET_DISTANCE = 150,
    RETARGET_CHECK_TIME = 0.5,
    VOID_Y_THRESHOLD = -25,
    FORCEFIELD_FLEE_DISTANCE = 25,
    SWORD_CHECK_INTERVAL = 3,
    EQUIP_DELAY = 0.3,
    PATH_REFRESH_RATE = 0.5,
    DIRECT_PATH_ATTEMPT_DISTANCE = 30,
    OBSTACLE_AVOIDANCE_DISTANCE = 5,
    PLATFORM_EDGE_MARGIN = 3
}

-- Lightweight status GUI
local function CreateStatusGUI()
    local success, ScreenGui = pcall(function()
        local gui = Instance.new("ScreenGui")
        gui.Name = "LinkedSwordAI_Final"
        gui.Parent = game:GetService("CoreGui")
        return gui
    end)
    
    if not success then return nil end
    
    local Frame = Instance.new("Frame")
    Frame.Size = UDim2.new(0, 220, 0, 80)
    Frame.Position = UDim2.new(0, 10, 0, 10)
    Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Frame.BackgroundTransparency = 0.5
    Frame.BorderSizePixel = 2
    
    local labels = {}
    local labelNames = {"Status", "Target", "Mode", "Distance"}
    
    for i, name in ipairs(labelNames) do
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 0, 20)
        label.Position = UDim2.new(0, 0, 0, (i-1)*20)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(255, 255, 255)
        label.Text = name .. ": N/A"
        label.Font = Enum.Font.SourceSans
        label.TextSize = 12
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = Frame
        labels[name] = label
    end
    
    Frame.Parent = ScreenGui
    
    local statusInterface = {}
    for name, label in pairs(labels) do
        statusInterface["Update" .. name] = function(text)
            if label then
                label.Text = name .. ": " .. (text or "N/A")
            end
        end
    end
    
    return statusInterface
end

-- Simple direct pathfinding with obstacle avoidance
local function CreateSmartNavigation()
    local nav = {}
    nav.lastPathUpdate = 0
    nav.currentDestination = nil
    nav.avoidanceDirection = 1
    nav.lastAvoidanceChange = 0
    
    -- Robust void detection for Heights map
    function nav.IsPositionSafe(position, character)
        if position.Y < CONFIG.VOID_Y_THRESHOLD then
            return false, "below void threshold"
        end
        
        -- Multi-directional ground check
        local rayOrigin = position + Vector3.new(0, 2, 0)
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {character}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        
        -- Check multiple points around the position
        local checkOffsets = {
            Vector3.new(0, 0, 0),
            Vector3.new(2, 0, 0),
            Vector3.new(-2, 0, 0),
            Vector3.new(0, 0, 2),
            Vector3.new(0, 0, -2)
        }
        
        local safeChecks = 0
        for _, offset in ipairs(checkOffsets) do
            local checkPos = rayOrigin + offset
            local result = workspace:Raycast(checkPos, Vector3.new(0, -10, 0), rayParams)
            if result then
                safeChecks = safeChecks + 1
            end
        end
        
        return safeChecks >= 3, safeChecks >= 3 and "safe" or "unsafe ground"
    end
    
    -- Check if direct path to target is clear
    function nav.IsDirectPathClear(startPos, targetPos, character)
        local direction = (targetPos - startPos).Unit
        local distance = (targetPos - startPos).Magnitude
        
        -- Check for obstacles
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {character}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        
        local obstacleCheck = workspace:Raycast(startPos, direction * math.min(distance, 50), rayParams)
        if obstacleCheck then
            return false, "obstacle detected"
        end
        
        -- Check path safety
        for i = 5, math.min(distance, 40), 10 do
            local checkPoint = startPos + direction * i
            local isSafe, reason = nav.IsPositionSafe(checkPoint, character)
            if not isSafe then
                return false, reason
            end
        end
        
        return true, "clear"
    end
    
    -- Smart movement with obstacle avoidance
    function nav.MoveToTarget(humanoid, targetPos, currentPos, character, statusGUI)
        local currentTime = tick()
        
        -- Check if we can take direct path
        local isClear, reason = nav.IsDirectPathClear(currentPos, targetPos, character)
        
        if isClear then
            if statusGUI then
                statusGUI.UpdateMode("Direct")
            end
            
            -- Direct path is safe, move to target
            humanoid:MoveTo(targetPos)
            nav.currentDestination = targetPos
            return "moving_direct"
        else
            if statusGUI then
                statusGUI.UpdateMode("Smart: " .. reason)
            end
            
            -- Find safe alternative path
            return nav.FindAlternativePath(humanoid, targetPos, currentPos, character, statusGUI)
        end
    end
    
    -- Find alternative path when direct path is blocked
    function nav.FindAlternativePath(humanoid, targetPos, currentPos, character, statusGUI)
        local direction = (targetPos - currentPos).Unit
        local horizontalDir = Vector3.new(direction.X, 0, direction.Z).Unit
        
        -- Try different avoidance strategies
        local strategies = {
            {name = "Left", offset = horizontalDir:Cross(Vector3.new(0, 1, 0)) * 8},
            {name = "Right", offset = horizontalDir:Cross(Vector3.new(0, -1, 0)) * 8},
            {name = "Elevated", offset = Vector3.new(0, 5, 0) + horizontalDir * 6},
            {name = "Retreat", offset = -horizontalDir * 10}
        }
        
        for _, strategy in ipairs(strategies) do
            local testPos = currentPos + strategy.offset
            
            -- Check if this alternative is safe
            local isSafe, reason = nav.IsPositionSafe(testPos, character)
            if isSafe then
                local pathClear, pathReason = nav.IsDirectPathClear(currentPos, testPos, character)
                if pathClear then
                    humanoid:MoveTo(testPos)
                    nav.currentDestination = testPos
                    
                    if statusGUI then
                        statusGUI.UpdateMode("Alt: " .. strategy.name)
                    end
                    
                    return "moving_alternative"
                end
            end
        end
        
        -- If all alternatives fail, try small movements away from edges
        local safeRetreat = currentPos - horizontalDir * CONFIG.PLATFORM_EDGE_MARGIN
        if nav.IsPositionSafe(safeRetreat, character) then
            humanoid:MoveTo(safeRetreat)
            return "moving_safe"
        end
        
        -- Last resort: stay put
        return "stuck"
    end
    
    -- Forcefield evasion
    function nav.HandleForceFieldEvasion(humanoid, currentPos, forceFieldPlayers, statusGUI)
        local closestFFPlayer = nil
        local closestDistance = math.huge
        
        for player, _ in pairs(forceFieldPlayers) do
            if player.Character then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local distance = (hrp.Position - currentPos).Magnitude
                    if distance < CONFIG.FORCEFIELD_FLEE_DISTANCE and distance < closestDistance then
                        closestDistance = distance
                        closestFFPlayer = player
                    end
                end
            end
        end
        
        if closestFFPlayer and closestFFPlayer.Character then
            local ffPos = closestFFPlayer.Character.HumanoidRootPart.Position
            local fleeDir = (currentPos - ffPos).Unit
            local fleeTarget = currentPos + fleeDir * 15
            
            -- Ensure flee target is safe
            if nav.IsPositionSafe(fleeTarget, character) then
                humanoid:MoveTo(fleeTarget)
                
                if statusGUI then
                    statusGUI.UpdateStatus("Evading FF")
                end
                
                return true
            end
        end
        
        return false
    end
    
    return nav
end

-- Enhanced combat system with professional behaviors
local function CreateCombatManager()
    local combat = {}
    combat.lastModeChange = 0
    combat.currentMode = "Balanced"
    combat.strafeDirection = 1
    
    -- Professional combat modes
    function combat.SelectCombatMode(distance, currentTime)
        if currentTime - combat.lastModeChange > 3 then -- Change mode every 3 seconds
            combat.lastModeChange = currentTime
            
            if distance > 20 then
                combat.currentMode = "Approaching"
            elseif distance > 10 then
                -- Random selection for mid-range
                if math.random() < 0.5 then
                    combat.currentMode = "Defensive"
                else
                    combat.currentMode = "Aggressive"
                end
            else
                combat.currentMode = "Aggressive"
            end
        end
        
        return combat.currentMode
    end
    
    -- Execute combat behavior based on mode
    function combat.ExecuteCombatBehavior(humanoid, targetPos, currentPos, distance, mode, statusGUI)
        -- Always face target
        local lookVector = (targetPos - currentPos).Unit
        humanoid:MoveTo(currentPos + lookVector * 0.1)
        
        if mode == "Approaching" then
            -- Move directly toward target
            humanoid:MoveTo(targetPos)
            if statusGUI then statusGUI.UpdateStatus("Approaching") end
            
        elseif mode == "Defensive" then
            -- Strafe while maintaining distance
            combat.strafeDirection = combat.strafeDirection * -1
            local strafeDir = lookVector:Cross(Vector3.new(0, 1, 0)).Unit * combat.strafeDirection
            local strafePos = currentPos + strafeDir * 4 + lookVector * 2
            humanoid:MoveTo(strafePos)
            if statusGUI then statusGUI.UpdateStatus("Defensive") end
            
        else -- Aggressive
            -- Close distance aggressively
            local chargePos = targetPos - lookVector * 2 -- Stop just before target
            humanoid:MoveTo(chargePos)
            if statusGUI then statusGUI.UpdateStatus("Aggressive") end
        end
    end
    
    -- Smooth attack execution
    function combat.ExecuteAttack(sword, lastAttackTime)
        if not sword or tick() - lastAttackTime < CONFIG.ATTACK_COOLDOWN then
            return lastAttackTime
        end
        
        local newAttackTime = tick()
        
        spawn(function()
            for i = 1, 3 do
                pcall(function()
                    if sword and sword.Parent then
                        sword:Activate()
                    end
                end)
                wait(CONFIG.LUNGE_DELAY)
            end
        end)
        
        return newAttackTime
    end
    
    return combat
end

-- Main optimized execution
local function InitializeAI()
    forcePrint("LinkedSwordAI: Initializing final version...")
    
    -- Clean persistent data
    if not _G.LinkedSwordAIData then
        _G.LinkedSwordAIData = {
            StatusGUI = nil,
            LinkedSword = nil,
            CurrentTarget = nil,
            LastAttackTime = 0,
            LastRetargetTime = 0,
            Navigation = nil,
            Combat = nil,
            PlayersWithForceField = {}
        }
    end
    
    local data = _G.LinkedSwordAIData
    
    -- Initialize systems
    if not data.Navigation then
        data.Navigation = CreateSmartNavigation()
    end
    
    if not data.Combat then
        data.Combat = CreateCombatManager()
    end
    
    if not data.StatusGUI then
        data.StatusGUI = CreateStatusGUI()
    end
    
    if data.StatusGUI then
        data.StatusGUI.UpdateStatus("Initializing")
    end
    
    -- Get services
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local RunService = game:GetService("RunService")
    
    if not LocalPlayer then
        forcePrint("ERROR: LocalPlayer not found")
        return
    end
    
    -- Fast character acquisition
    local Character = LocalPlayer.Character
    if not Character then
        Character = LocalPlayer.CharacterAdded:Wait()
        wait(0.2) -- Brief stabilization period
    end
    
    local Humanoid = Character:WaitForChild("Humanoid", 3)
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart", 3)
    
    if not Humanoid or not HumanoidRootPart then
        forcePrint("ERROR: Character components missing")
        return
    end
    
    -- Fast sword equipping
    local function EquipSword()
        -- Check character first
        for _, item in pairs(Character:GetChildren()) do
            if item:IsA("Tool") then
                data.LinkedSword = item
                forcePrint("Found sword: " .. item.Name)
                return item
            end
        end
        
        -- Check backpack
        local Backpack = LocalPlayer:FindFirstChild("Backpack")
        if Backpack then
            for _, item in pairs(Backpack:GetChildren()) do
                if item:IsA("Tool") then
                    pcall(function() Humanoid:EquipTool(item) end)
                    wait(0.1)
                    data.LinkedSword = Character:FindFirstChild(item.Name) or item
                    forcePrint("Equipped sword: " .. item.Name)
                    return data.LinkedSword
                end
            end
        end
        
        forcePrint("WARNING: No sword found")
        return nil
    end
    
    -- Immediate equipment attempt
    spawn(function()
        wait(CONFIG.EQUIP_DELAY)
        EquipSword()
    end)
    
    -- Optimized player detection
    local function FindPlayersInRange()
        local playersInRange = {}
        local playersWithFF = {}
        local currentPos = HumanoidRootPart.Position
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                local hum = player.Character:FindFirstChild("Humanoid")
                
                if hrp and hum and hum.Health > 0 then
                    local distance = (hrp.Position - currentPos).Magnitude
                    
                    if distance <= CONFIG.MAX_TARGET_DISTANCE then
                        if player.Character:FindFirstChild("ForceField") then
                            playersWithFF[player] = true
                            forcePrint("ForceField detected on: " .. player.Name)
                        else
                            table.insert(playersInRange, {
                                Player = player,
                                Distance = distance,
                                Position = hrp.Position
                            })
                        end
                    end
                end
            end
        end
        
        data.PlayersWithForceField = playersWithFF
        table.sort(playersInRange, function(a, b) return a.Distance < b.Distance end)
        
        return playersInRange
    end
    
    -- Main update loop
    local lastUpdate = 0
    local updateConnection
    
    local function Update()
        local currentTime = tick()
        if currentTime - lastUpdate < 0.1 then return end -- 10 FPS limit
        lastUpdate = currentTime
        
        -- Periodic sword check
        if currentTime % 5 < 0.1 then -- Every ~5 seconds
            EquipSword()
        end
        
        -- Handle forcefield evasion first
        if data.Navigation.HandleForceFieldEvasion(Humanoid, HumanoidRootPart.Position, data.PlayersWithForceField, data.StatusGUI) then
            return
        end
        
        -- Find targets
        local playersInRange = FindPlayersInRange()
        
        -- Target selection
        if #playersInRange > 0 and (not data.CurrentTarget or currentTime - data.LastRetargetTime > CONFIG.RETARGET_CHECK_TIME) then
            data.LastRetargetTime = currentTime
            data.CurrentTarget = playersInRange[1].Player
            
            if data.StatusGUI then
                data.StatusGUI.UpdateTarget(data.CurrentTarget.Name)
            end
            
            forcePrint("New target: " .. data.CurrentTarget.Name)
        end
        
        -- Target engagement
        if data.CurrentTarget and data.CurrentTarget.Character then
            local targetChar = data.CurrentTarget.Character
            local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
            local targetHum = targetChar:FindFirstChild("Humanoid")
            
            if targetHRP and targetHum and targetHum.Health > 0 then
                local distance = (targetHRP.Position - HumanoidRootPart.Position).Magnitude
                
                if data.StatusGUI then
                    data.StatusGUI.UpdateDistance(math.floor(distance))
                end
                
                -- Smart navigation
                data.Navigation.MoveToTarget(Humanoid, targetHRP.Position, HumanoidRootPart.Position, Character, data.StatusGUI)
                
                -- Professional combat behavior
                local combatMode = data.Combat.SelectCombatMode(distance, currentTime)
                data.Combat.ExecuteCombatBehavior(Humanoid, targetHRP.Position, HumanoidRootPart.Position, distance, combatMode, data.StatusGUI)
                
                -- Attack when in range
                if distance <= CONFIG.ATTACK_RANGE then
                    data.LastAttackTime = data.Combat.ExecuteAttack(data.LinkedSword, data.LastAttackTime)
                end
            else
                data.CurrentTarget = nil
                if data.StatusGUI then
                    data.StatusGUI.UpdateTarget("None")
                end
            end
        else
            data.CurrentTarget = nil
            if data.StatusGUI then
                data.StatusGUI.UpdateStatus("Searching")
                data.StatusGUI.UpdateTarget("None")
                data.StatusGUI.UpdateMode("Idle")
            end
        end
    end
    
    updateConnection = RunService.Heartbeat:Connect(Update)
    
    -- Cleanup on death
    Humanoid.Died:Connect(function()
        forcePrint("Character died - cleaning up")
        if updateConnection then
            updateConnection:Disconnect()
        end
    end)
    
    if data.StatusGUI then
        data.StatusGUI.UpdateStatus("Active")
    end
    
    forcePrint("LinkedSwordAI: Final version activated successfully")
end

-- Fast respawn handling
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

if LocalPlayer then
    LocalPlayer.CharacterAdded:Connect(function(character)
        forcePrint("Character respawned - reinitializing")
        wait(0.3) -- Minimal delay
        InitializeAI()
    end)
end

-- Initial startup
wait(0.5)
InitializeAI()

forcePrint("LinkedSwordAI: Final script loaded completely")
