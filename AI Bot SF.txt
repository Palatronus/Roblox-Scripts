-- LinkedSwordAI_HealthTargetFix.lua
-- Fixed health display and active target switching

local LinkedSwordAI = {}
LinkedSwordAI.Version = "3.1"
LinkedSwordAI.IsRunning = false

-- Configuration
local Config = {
    -- Targeting
    DetectionRadius = 100,
    MaxTargetDistance = 150,
    TargetRefreshRate = 0.3,
    TargetSwitchDistanceThreshold = 10, -- Switch if new target is this much closer
    
    -- Combat
    AttackRange = 16,
    LungeRange = 12,
    AttackCooldown = 0.9,
    ComboAttacks = 3,
    ComboDelay = 0.1,
    
    -- Movement
    WaypointDistance = 10,
    NavigationUpdate = 0.2,
    StrafeDistance = 4,
    MoveSpeedMultiplier = 1.2,
    
    -- Safety
    VoidThreshold = -20,
    
    -- Performance
    UpdateThrottle = 0.08,
    CleanupInterval = 15
}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- Debug output
local function DebugPrint(message)
    if _G.LinkedSwordAIDebug then
        print("[LinkedSwordAI]: " .. tostring(message))
    end
end

-- Safe wait that respects Heartbeat
local function SafeWait(seconds)
    local start = tick()
    while tick() - start < seconds do
        RunService.Heartbeat:Wait()
    end
end

-- Initialize persistent AI state
local function InitializeAIState()
    if not _G.LinkedSwordAIData then
        _G.LinkedSwordAIData = {
            IsActive = false,
            StatusGUI = nil,
            CurrentTarget = nil,
            LastAttackTime = 0,
            LastTargetUpdate = 0,
            LastNavigationUpdate = 0,
            LastCleanup = tick(),
            LastHealthUpdate = 0,
            Connections = {},
            StrafingDirection = 1,
            CombatMode = "Approaching",
            KnownTargets = {} -- Track multiple targets
        }
    end
    return _G.LinkedSwordAIData
end

-- Status GUI
local function CreateStatusGUI()
    local success, screenGui = pcall(function()
        local gui = Instance.new("ScreenGui")
        gui.Name = "LinkedSwordAI_Status_v3"
        gui.Parent = game:GetService("CoreGui")
        return gui
    end)
    
    if not success then return nil end
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 220, 0, 100)
    frame.Position = UDim2.new(0, 10, 0, 10)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    frame.BackgroundTransparency = 0.2
    frame.BorderSizePixel = 0
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = frame
    
    local labels = {}
    local labelInfo = {
        {"Status", "Initializing"},
        {"Target", "None"},
        {"Distance", "0.0"},
        {"Action", "Idle"},
        {"Health", "100%"}
    }
    
    for i, info in ipairs(labelInfo) do
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, -10, 0, 20)
        label.Position = UDim2.new(0, 5, 0, (i-1)*20)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(220, 220, 220)
        label.Text = info[1] .. ": " .. info[2]
        label.Font = Enum.Font.SourceSansSemibold
        label.TextSize = 12
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = frame
        labels[info[1]] = label
    end
    
    frame.Parent = screenGui
    
    return {
        Update = function(field, value)
            if labels[field] then
                labels[field].Text = field .. ": " .. (value or "N/A")
            end
        end,
        Destroy = function()
            pcall(function() screenGui:Destroy() end)
        end
    }
end

-- Sword equipping
local function EquipSword(character, humanoid)
    if not character or not humanoid then return nil end
    
    -- Check character first
    for _, item in ipairs(character:GetChildren()) do
        if item:IsA("Tool") then
            return item
        end
    end
    
    -- Check backpack
    local player = Players.LocalPlayer
    local backpack = player:FindFirstChild("Backpack")
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                pcall(function()
                    humanoid:EquipTool(item)
                    SafeWait(0.3)
                end)
                return character:FindFirstChild(item.Name) or item
            end
        end
    end
    
    return nil
end

-- Improved target finding that considers multiple targets
local function FindBestTarget(localPlayer, localPosition, currentTarget, data)
    local allTargets = {}
    local currentDistance = currentTarget and currentTarget.Distance or math.huge
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
            
            if humanoid and humanoid.Health > 0 and rootPart then
                local distance = (rootPart.Position - localPosition).Magnitude
                
                if distance <= Config.MaxTargetDistance then
                    table.insert(allTargets, {
                        Player = player,
                        Humanoid = humanoid,
                        RootPart = rootPart,
                        Distance = distance,
                        Position = rootPart.Position,
                        LastSeen = tick()
                    })
                end
            end
        end
    end
    
    if #allTargets == 0 then
        return nil
    end
    
    -- Sort by distance (closest first)
    table.sort(allTargets, function(a, b)
        return a.Distance < b.Distance
    end)
    
    -- Store known targets for switching logic
    data.KnownTargets = {}
    for _, target in ipairs(allTargets) do
        data.KnownTargets[target.Player] = target
    end
    
    -- If we have a current target, check if we should switch
    if currentTarget then
        local closestTarget = allTargets[1]
        
        -- Switch target if:
        -- 1. New target is significantly closer
        -- 2. Current target is no longer valid
        -- 3. Random chance to switch for unpredictability
        local shouldSwitch = false
        
        if closestTarget.Distance < currentDistance - Config.TargetSwitchDistanceThreshold then
            shouldSwitch = true
            DebugPrint("Switching to closer target: " .. closestTarget.Player.Name)
        elseif not currentTarget.RootPart or not currentTarget.Humanoid or currentTarget.Humanoid.Health <= 0 then
            shouldSwitch = true
            DebugPrint("Current target invalid, switching")
        elseif math.random(1, 100) <= 10 then -- 10% chance to randomly switch
            shouldSwitch = true
            DebugPrint("Random target switch for unpredictability")
        end
        
        if shouldSwitch then
            return closestTarget
        else
            return currentTarget -- Keep current target
        end
    end
    
    -- No current target, return closest
    return allTargets[1]
end

-- Improved navigation with movement
local function IsPositionSafe(position, character)
    if position.Y < Config.VoidThreshold then
        return false, "void"
    end
    
    local rayOrigin = position + Vector3.new(0, 3, 0)
    local rayDirection = Vector3.new(0, -25, 0)
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local result = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    
    return result ~= nil, result and "safe" or "no ground"
end

local function CalculateMovement(currentPos, targetPos, character, data)
    local direction = (targetPos - currentPos).Unit
    local distance = (targetPos - currentPos).Magnitude
    
    -- Always try direct path first
    local moveDistance = math.min(Config.WaypointDistance, distance)
    local testPos = currentPos + (direction * moveDistance)
    
    local isSafe, reason = IsPositionSafe(testPos, character)
    
    if isSafe then
        return testPos, "direct"
    end
    
    -- Try different strategies for Heights map
    local strategies = {
        -- Elevated path (for bridges)
        currentPos + Vector3.new(0, 6, 0) + (direction * moveDistance),
        -- Left strafe
        currentPos + (direction:Cross(Vector3.new(0, 1, 0)) * 3) + (direction * moveDistance * 0.8),
        -- Right strafe
        currentPos + (direction:Cross(Vector3.new(0, -1, 0)) * 3) + (direction * moveDistance * 0.8),
        -- Small step forward
        currentPos + (direction * 3)
    }
    
    for i, pos in ipairs(strategies) do
        if IsPositionSafe(pos, character) then
            return pos, "strategy_" .. i
        end
    end
    
    -- If all else fails, retreat slightly
    local retreatPos = currentPos - (direction * 2)
    if IsPositionSafe(retreatPos, character) then
        return retreatPos, "retreat"
    end
    
    -- Last resort: stay put but look at target
    return currentPos, "hold"
end

-- Combat behavior that actually moves
local function ExecuteCombat(humanoid, rootPart, targetPos, distance, sword, lastAttackTime, data)
    local currentTime = tick()
    local direction = (targetPos - rootPart.Position).Unit
    
    -- Face the target
    humanoid:MoveTo(rootPart.Position + direction * 0.1)
    
    -- Determine combat mode
    local combatMode
    if distance <= Config.LungeRange then
        combatMode = "Aggressive"
    elseif distance <= Config.AttackRange then
        combatMode = "Balanced"
    else
        combatMode = "Approaching"
    end
    
    data.CombatMode = combatMode
    
    -- Execute movement based on mode
    if combatMode == "Approaching" then
        -- Move directly toward target
        local movePos = rootPart.Position + (direction * Config.WaypointDistance)
        if IsPositionSafe(movePos, humanoid.Parent) then
            humanoid:MoveTo(movePos)
        end
    elseif combatMode == "Balanced" then
        -- Strafing movement
        data.StrafingDirection = data.StrafingDirection * -1
        local strafeDir = direction:Cross(Vector3.new(0, data.StrafingDirection, 0)).Unit
        local movePos = rootPart.Position + (strafeDir * Config.StrafeDistance) + (direction * 2)
        
        if IsPositionSafe(movePos, humanoid.Parent) then
            humanoid:MoveTo(movePos)
        end
    else -- Aggressive
        -- Close combat - minimal movement
        if distance > 3 then
            humanoid:MoveTo(targetPos)
        end
    end
    
    -- Attack if in range
    if distance <= Config.AttackRange and sword then
        if currentTime - lastAttackTime >= Config.AttackCooldown then
            -- Execute combo attack
            for i = 1, Config.ComboAttacks do
                if sword and sword.Parent then
                    pcall(function() sword:Activate() end)
                end
                if i < Config.ComboAttacks then
                    SafeWait(Config.ComboDelay)
                end
            end
            return currentTime -- Return new attack time
        end
    end
    
    return lastAttackTime -- Return unchanged attack time
end

-- Health monitoring function
local function UpdateHealthDisplay(data)
    if not data.Humanoid or not data.StatusGUI then return end
    
    local health = data.Humanoid.Health
    local maxHealth = data.Humanoid.MaxHealth
    local healthPercent = math.floor((health / maxHealth) * 100)
    
    data.StatusGUI.Update("Health", healthPercent .. "%")
    
    -- Color code health display
    if healthPercent <= 25 then
        data.StatusGUI.Update("Health", healthPercent .. "% [LOW]")
    elseif healthPercent <= 50 then
        data.StatusGUI.Update("Health", healthPercent .. "% [MEDIUM]")
    else
        data.StatusGUI.Update("Health", healthPercent .. "% [HIGH]")
    end
end

-- Main AI update function
local function AIUpdate(data)
    if not data.IsActive or not data.Character or not data.Humanoid or not data.RootPart then
        return
    end
    
    local currentTime = tick()
    
    -- Performance throttling
    if currentTime - data.LastUpdateTime < Config.UpdateThrottle then
        return
    end
    data.LastUpdateTime = currentTime
    
    -- Memory cleanup
    if currentTime - data.LastCleanup > Config.CleanupInterval then
        collectgarbage("step")
        data.LastCleanup = currentTime
    end
    
    -- Update health display every frame (fixed the health issue)
    UpdateHealthDisplay(data)
    
    -- Target acquisition with improved switching
    if currentTime - data.LastTargetUpdate > Config.TargetRefreshRate then
        data.LastTargetUpdate = currentTime
        data.CurrentTarget = FindBestTarget(Players.LocalPlayer, data.RootPart.Position, data.CurrentTarget, data)
        
        if data.StatusGUI then
            if data.CurrentTarget then
                data.StatusGUI.Update("Target", data.CurrentTarget.Player.Name)
                data.StatusGUI.Update("Distance", string.format("%.1f", data.CurrentTarget.Distance))
                data.StatusGUI.Update("Status", "Engaging")
                
                -- Show how many targets are known
                local targetCount = 0
                for _ in pairs(data.KnownTargets) do
                    targetCount = targetCount + 1
                end
                if targetCount > 1 then
                    data.StatusGUI.Update("Action", "Engaging (" .. targetCount .. " targets)")
                end
            else
                data.StatusGUI.Update("Target", "None")
                data.StatusGUI.Update("Distance", "0.0")
                data.StatusGUI.Update("Status", "Searching")
                data.StatusGUI.Update("Action", "Idle")
            end
        end
    end
    
    -- Skip if no target
    if not data.CurrentTarget or not data.CurrentTarget.RootPart or not data.CurrentTarget.Humanoid or data.CurrentTarget.Humanoid.Health <= 0 then
        data.CurrentTarget = nil
        return
    end
    
    -- Update target distance (in case target moved)
    data.CurrentTarget.Distance = (data.CurrentTarget.Position - data.RootPart.Position).Magnitude
    data.CurrentTarget.Position = data.CurrentTarget.RootPart.Position
    
    -- Navigation and movement
    if currentTime - data.LastNavigationUpdate > Config.NavigationUpdate then
        data.LastNavigationUpdate = currentTime
        
        local movePos, pathType = CalculateMovement(
            data.RootPart.Position,
            data.CurrentTarget.Position,
            data.Character,
            data
        )
        
        if data.StatusGUI then
            data.StatusGUI.Update("Action", data.CombatMode .. " - " .. pathType)
        end
        
        -- Execute combat behavior (which includes movement)
        data.LastAttackTime = ExecuteCombat(
            data.Humanoid,
            data.RootPart,
            data.CurrentTarget.Position,
            data.CurrentTarget.Distance,
            data.Sword,
            data.LastAttackTime,
            data
        )
    end
end

-- Character setup
local function SetupCharacter(data)
    local player = Players.LocalPlayer
    if not player then return false end
    
    -- Wait for character
    data.Character = player.Character
    if not data.Character then
        DebugPrint("Waiting for character...")
        data.Character = player.CharacterAdded:Wait()
        SafeWait(1) -- Allow character to load
    end
    
    -- Get character components
    data.Humanoid = data.Character:WaitForChild("Humanoid", 5)
    data.RootPart = data.Character:WaitForChild("HumanoidRootPart", 5)
    
    if not data.Humanoid or not data.RootPart then
        DebugPrint("Failed to find character components")
        return false
    end
    
    -- Set movement speed
    data.Humanoid.WalkSpeed = 16 * Config.MoveSpeedMultiplier
    
    -- Equip sword
    data.Sword = EquipSword(data.Character, data.Humanoid)
    if data.Sword and data.StatusGUI then
        data.StatusGUI.Update("Action", "Sword equipped")
    end
    
    -- Set up death handling (but don't stop the AI)
    if data.Connections.characterDeath then
        data.Connections.characterDeath:Disconnect()
    end
    
    data.Connections.characterDeath = data.Humanoid.Died:Connect(function()
        DebugPrint("Character died - will respawn and continue")
        if data.StatusGUI then
            data.StatusGUI.Update("Status", "Respawning...")
        end
    end)
    
    -- Health monitoring connection
    if data.Connections.healthChange then
        data.Connections.healthChange:Disconnect()
    end
    
    data.Connections.healthChange = data.Humanoid.HealthChanged:Connect(function()
        UpdateHealthDisplay(data)
    end)
    
    return true
end

-- Main control functions
function LinkedSwordAI.Start()
    local data = InitializeAIState()
    
    if data.IsActive then
        DebugPrint("AI is already running")
        return true
    end
    
    DebugPrint("Starting LinkedSwordAI...")
    
    -- Create GUI if needed
    if not data.StatusGUI then
        data.StatusGUI = CreateStatusGUI()
    end
    
    -- Setup character
    if not SetupCharacter(data) then
        DebugPrint("Failed to setup character")
        return false
    end
    
    data.IsActive = true
    data.LastUpdateTime = 0
    
    -- Main update loop
    if data.Connections.heartbeat then
        data.Connections.heartbeat:Disconnect()
    end
    
    data.Connections.heartbeat = RunService.Heartbeat:Connect(function()
        AIUpdate(data)
    end)
    
    -- Auto-respawn handling (this is key for persistence)
    if data.Connections.respawn then
        data.Connections.respawn:Disconnect()
    end
    
    data.Connections.respawn = Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        DebugPrint("Character respawned - reinitializing...")
        SafeWait(1.5) -- Wait for character to fully load
        
        -- Update character references but keep AI running
        if data.IsActive then
            data.Character = newCharacter
            SetupCharacter(data) -- Re-setup with new character
            if data.StatusGUI then
                data.StatusGUI.Update("Status", "Respawned - Active")
            end
        end
    end)
    
    if data.StatusGUI then
        data.StatusGUI.Update("Status", "Active")
        UpdateHealthDisplay(data) -- Initial health update
    end
    
    LinkedSwordAI.IsRunning = true
    DebugPrint("LinkedSwordAI started successfully")
    return true
end

function LinkedSwordAI.Stop()
    local data = InitializeAIState()
    
    if not data.IsActive then
        return true
    end
    
    DebugPrint("Stopping LinkedSwordAI...")
    
    data.IsActive = false
    LinkedSwordAI.IsRunning = false
    
    -- Disconnect all connections
    for name, connection in pairs(data.Connections) do
        if connection then
            connection:Disconnect()
        end
    end
    data.Connections = {}
    
    -- Clear character references
    data.Character = nil
    data.Humanoid = nil
    data.RootPart = nil
    data.Sword = nil
    data.CurrentTarget = nil
    data.KnownTargets = {}
    
    if data.StatusGUI then
        data.StatusGUI.Update("Status", "Stopped")
        data.StatusGUI.Update("Target", "None")
        data.StatusGUI.Update("Action", "Inactive")
        data.StatusGUI.Update("Health", "N/A")
    end
    
    DebugPrint("LinkedSwordAI stopped")
    return true
end

function LinkedSwordAI.Toggle()
    if LinkedSwordAI.IsRunning then
        return LinkedSwordAI.Stop()
    else
        return LinkedSwordAI.Start()
    end
end

-- Auto-initialization with proper error handling
local function Initialize()
    pcall(function()
        -- Wait for game to load
        if not game:IsLoaded() then
            game.Loaded:Wait()
        end
        
        -- Wait for player
        if not Players.LocalPlayer then
            Players.PlayerAdded:Wait()
        end
        
        SafeWait(3) -- Initial delay
        
        -- Auto-start the AI
        LinkedSwordAI.Start()
        
        DebugPrint("LinkedSwordAI initialized successfully")
    end)
end

-- Global control functions
_G.LinkedSwordAI_Start = LinkedSwordAI.Start
_G.LinkedSwordAI_Stop = LinkedSwordAI.Stop
_G.LinkedSwordAI_Toggle = LinkedSwordAI.Toggle
_G.LinkedSwordAI_Debug = function() _G.LinkedSwordAIDebug = true end

-- Start the AI
spawn(Initialize)

return LinkedSwordAI
