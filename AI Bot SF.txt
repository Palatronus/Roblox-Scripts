--[[
    Linked Sword AI Combat Script
    
    This script implements autonomous sword fighting AI for the Linked Sword tool in Roblox.
    Designed for external executor usage.
    
    Features:
    - Autonomous sword swinging when players enter 15-stud radius
    - Advanced pathfinding for smooth navigation
    - Tactical AI behaviors with RNG-based decision making
    - Target validation (excludes god mode players and those beyond reach)
    - Strategic jumping mechanics accounting for Linked Sword physics
]]

-- Configuration
local CONFIG = {
    DETECTION_RADIUS = 15,           -- Stud radius for detecting players
    ATTACK_COOLDOWN = 1.2,           -- Time between attacks in seconds
    FEINT_CHANCE = 0.3,              -- Probability of performing a feint (0-1)
    CHARGE_ATTACK_CHANCE = 0.25,     -- Probability of charging an attack (0-1)
    DEFENSIVE_CHANCE = 0.2,          -- Probability of taking defensive posture (0-1)
    JUMP_CHANCE = 0.15,              -- Probability of tactical jumping (0-1)
    PATHFINDING_UPDATE_RATE = 0.1,   -- How often to update pathfinding in seconds
    MAX_TARGET_DISTANCE = 20,        -- Maximum effective reach in studs
    MIN_HEALTH_CHECK = 0,            -- Minimum health to consider player valid (for god mode detection)
    DEBUG_MODE = true                -- Enable debug visualization and logging
}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")
local UserInputService = game:GetService("UserInputService")

-- Variables
local LocalPlayer = Players.LocalPlayer
local Character
local Humanoid
local HumanoidRootPart
local LinkedSword = nil
local CurrentTarget = nil
local LastAttackTime = 0
local CurrentPath = nil
local Waypoints = {}
local CurrentWaypointIndex = 0
local CurrentTactic = "Approach" -- "Approach", "Attack", "Feint", "Defensive"
local IsExecuting = false
local JumpCooldown = 0

-- Debug function
local function DebugPrint(message)
    if CONFIG.DEBUG_MODE then
        print("[LinkedSwordAI] " .. message)
    end
end

-- Find the Linked Sword tool
local function FindLinkedSword()
    for _, tool in pairs(Character:GetChildren()) do
        if tool:IsA("Tool") and tool.Name:find("Sword") then
            return tool
        end
    end
    
    -- If not found in character, check backpack
    for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
        if tool:IsA("Tool") and tool.Name:find("Sword") then
            return tool
        end
    end
    
    return nil
end

-- Validate target (check if they have god mode or are too far)
local function IsValidTarget(player)
    if not player or not player.Character then return false end
    
    local playerHumanoid = player.Character:FindFirstChild("Humanoid")
    local playerHRP = player.Character:FindFirstChild("HumanoidRootPart")
    
    if not playerHumanoid or not playerHRP then return false end
    
    -- Check for god mode (negative or extremely high health)
    if playerHumanoid.Health <= CONFIG.MIN_HEALTH_CHECK then return false end
    
    -- Check distance
    local distance = (playerHRP.Position - HumanoidRootPart.Position).Magnitude
    if distance > CONFIG.MAX_TARGET_DISTANCE then return false end
    
    return true
end

-- Find the nearest valid player
local function FindNearestPlayer()
    local nearestPlayer = nil
    local shortestDistance = CONFIG.DETECTION_RADIUS
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (player.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                
                if distance <= shortestDistance and IsValidTarget(player) then
                    shortestDistance = distance
                    nearestPlayer = player
                end
            end
        end
    end
    
    return nearestPlayer
end

-- Pathfinding to target
local function PathfindToTarget(target)
    if not target or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local targetPosition = target.Character.HumanoidRootPart.Position
    
    -- Create a new path
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true
    })
    
    -- Compute the path
    local success, errorMessage = pcall(function()
        path:ComputeAsync(HumanoidRootPart.Position, targetPosition)
    end)
    
    if success and path.Status == Enum.PathStatus.Success then
        CurrentPath = path
        Waypoints = path:GetWaypoints()
        CurrentWaypointIndex = 1
        
        if CONFIG.DEBUG_MODE then
            print("Path created with " .. #Waypoints .. " waypoints")
        end
    else
        if CONFIG.DEBUG_MODE then
            warn("Path computation failed: " .. tostring(errorMessage))
        end
        CurrentPath = nil
        Waypoints = {}
    end
end

-- Move to waypoint
local function MoveToWaypoint(waypoint)
    if not waypoint then return end
    
    Humanoid:MoveTo(waypoint.Position)
    
    -- Handle jumping at waypoints that require it
    if waypoint.Action == Enum.PathWaypointAction.Jump and JumpCooldown <= 0 then
        Humanoid.Jump = true
        JumpCooldown = 1 -- 1 second cooldown on jumps
    end
end

-- Tactical decision making with RNG
local function DecideTactic()
    local rand = math.random()
    
    -- If target is close enough for attack
    if CurrentTarget and CurrentTarget.Character and 
       (CurrentTarget.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude < 8 then
        
        -- Chance to perform a charged attack
        if rand < CONFIG.CHARGE_ATTACK_CHANCE then
            return "ChargeAttack"
        -- Chance to perform a feint
        elseif rand < CONFIG.CHARGE_ATTACK_CHANCE + CONFIG.FEINT_CHANCE then
            return "Feint"
        -- Otherwise regular attack
        else
            return "Attack"
        end
    else
        -- If target is further away, decide between approach and defensive
        if rand < CONFIG.DEFENSIVE_CHANCE then
            return "Defensive"
        else
            return "Approach"
        end
    end
end

-- Execute attack with the Linked Sword
local function ExecuteAttack(attackType)
    if not LinkedSword then
        LinkedSword = FindLinkedSword()
        if not LinkedSword then return end
    end
    
    -- Equip the sword if it's not already equipped
    if LinkedSword.Parent ~= Character then
        LinkedSword.Parent = Character
    end
    
    -- Different attack types
    if attackType == "Attack" then
        -- Regular attack - simple click
        LinkedSword:Activate()
        LastAttackTime = tick()
    elseif attackType == "ChargeAttack" then
        -- Charged attack - hold and release
        mouse1press()
        wait(0.5) -- Hold for half a second
        mouse1release()
        LastAttackTime = tick() + 0.5 -- Additional cooldown for charged attacks
    elseif attackType == "Feint" then
        -- Feint - start attack motion but cancel with movement
        LinkedSword:Activate()
        wait(0.1)
        -- Quick direction change to simulate feint
        local targetPos = HumanoidRootPart.Position + HumanoidRootPart.CFrame.LookVector * -3
        Humanoid:MoveTo(targetPos)
        wait(0.2)
        -- Re-engage after feint
        if CurrentTarget and CurrentTarget.Character then
            Humanoid:MoveTo(CurrentTarget.Character.HumanoidRootPart.Position)
        end
        LastAttackTime = tick() - 0.5 -- Reduced cooldown for feints to allow quick follow-up
    end
end

-- Strategic jumping with physics consideration
local function ExecuteStrategicJump()
    if JumpCooldown <= 0 and math.random() < CONFIG.JUMP_CHANCE then
        -- Calculate jump direction based on target position
        if CurrentTarget and CurrentTarget.Character then
            local targetPos = CurrentTarget.Character.HumanoidRootPart.Position
            local direction = (targetPos - HumanoidRootPart.Position).Unit
            
            -- Jump toward or away from target based on situation
            if (targetPos - HumanoidRootPart.Position).Magnitude < 5 then
                -- Jump backward if too close
                Humanoid:MoveTo(HumanoidRootPart.Position - direction * 5)
            else
                -- Jump toward target
                Humanoid:MoveTo(HumanoidRootPart.Position + direction * 5)
            end
            
            Humanoid.Jump = true
            JumpCooldown = 2 -- 2 second cooldown on strategic jumps
        end
    end
end

-- Main update loop
local function Update()
    -- Update cooldowns
    if JumpCooldown > 0 then
        JumpCooldown = JumpCooldown - RunService.Heartbeat:Wait()
    end
    
    -- Find or validate current target
    if not CurrentTarget or not IsValidTarget(CurrentTarget) then
        CurrentTarget = FindNearestPlayer()
    end
    
    -- If we have a target, execute AI behavior
    if CurrentTarget then
        -- Update pathfinding periodically
        if not CurrentPath or tick() % CONFIG.PATHFINDING_UPDATE_RATE < 0.01 then
            PathfindToTarget(CurrentTarget)
        end
        
        -- Follow current path
        if CurrentPath and CurrentWaypointIndex <= #Waypoints then
            local currentWaypoint = Waypoints[CurrentWaypointIndex]
            MoveToWaypoint(currentWaypoint)
            
            -- Check if we've reached the waypoint
            if (HumanoidRootPart.Position - currentWaypoint.Position).Magnitude < 3 then
                CurrentWaypointIndex = CurrentWaypointIndex + 1
            end
        end
        
        -- Face the target
        if CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("HumanoidRootPart") then
            local targetPosition = CurrentTarget.Character.HumanoidRootPart.Position
            HumanoidRootPart.CFrame = CFrame.lookAt(HumanoidRootPart.Position, Vector3.new(targetPosition.X, HumanoidRootPart.Position.Y, targetPosition.Z))
        end
        
        -- Execute combat tactics
        if tick() - LastAttackTime > CONFIG.ATTACK_COOLDOWN then
            local tactic = DecideTactic()
            
            if tactic == "Attack" or tactic == "ChargeAttack" or tactic == "Feint" then
                ExecuteAttack(tactic)
            elseif tactic == "Defensive" then
                -- In defensive mode, wait for player to approach
                -- Occasionally perform strategic jumps
                if math.random() < CONFIG.JUMP_CHANCE * 2 then -- Double jump chance in defensive mode
                    ExecuteStrategicJump()
                end
            end
        end
        
        -- Consider strategic jumping
        ExecuteStrategicJump()
    end
end

-- Initialize the script
local function Initialize()
    DebugPrint("Linked Sword AI Combat Script initializing...")
    
    -- Wait for LocalPlayer to be available
    if not LocalPlayer then
        DebugPrint("Waiting for LocalPlayer...")
        repeat wait(0.1) until Players.LocalPlayer
        LocalPlayer = Players.LocalPlayer
        DebugPrint("LocalPlayer found: " .. LocalPlayer.Name)
    end
    
    -- Wait for Character to be available
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Humanoid") then
        DebugPrint("Waiting for Character...")
        
        if LocalPlayer.Character then
            Character = LocalPlayer.Character
        else
            Character = LocalPlayer.CharacterAdded:Wait()
        end
        
        DebugPrint("Character loaded")
    else
        Character = LocalPlayer.Character
        DebugPrint("Character already available")
    end
    
    -- Get Humanoid and HumanoidRootPart
    Humanoid = Character:WaitForChild("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    DebugPrint("Humanoid and HumanoidRootPart found")
    
    -- Find the Linked Sword
    LinkedSword = FindLinkedSword()
    if LinkedSword then
        DebugPrint("Linked Sword found: " .. LinkedSword.Name)
    else
        DebugPrint("Linked Sword not found! Please equip it first.")
    end
    
    -- Connect to RunService for the main loop
    DebugPrint("Connecting to RunService...")
    RunService:BindToRenderStep("LinkedSwordAI", Enum.RenderPriority.Character.Value, Update)
    
    -- Handle character respawning
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        DebugPrint("Character respawned")
        Character = newCharacter
        Humanoid = Character:WaitForChild("Humanoid")
        HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
        LinkedSword = FindLinkedSword()
    end)
    
    DebugPrint("Initialization complete!")
end

-- Start the script with pcall to catch any errors
pcall(function()
    DebugPrint("Starting script execution...")
    Initialize()
    DebugPrint("Script started successfully")
end)
